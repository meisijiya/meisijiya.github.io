<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>老江湖来咯</title>
    <url>/2025/09/16/%E8%80%81%E6%B1%9F%E6%B9%96%E6%9D%A5%E5%92%AF/</url>
    <content><![CDATA[老江湖来咯，哈哈哈哈哈哈哈哈哈哈
]]></content>
      <categories>
        <category>碎碎念</category>
      </categories>
      <tags>
        <tag>开心</tag>
      </tags>
  </entry>
  <entry>
    <title>02-短信登录-基于session方案</title>
    <url>/2025/09/20/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/02-%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95-%E5%9F%BA%E4%BA%8Esession%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[
前置：基于Session实现登录HttpSession 对象HttpSession_百度百科 Servlet Session 跟踪 | 菜鸟教程
Servlet提供了HttpSession接口，该接口中提供了一种跨多个页面请求或访问网站时识别用户以及存储有关用户信息的方式。Servlet 容器使用这个接口来创建一个 HTTP 客户端和 HTTP 服务器之间的 session 会话。会话持续一个指定的时间段，跨多个连接或页面请求。
@RestController结合了 @Controller 和 @ResponseBody。被被标记的类中，每个方法的返回值都会以JSON或XML的形式直接写入HTTP响应体中（@ResponseBody）。@Controller处理客户端发起的请求，并负责返回适当的视图（View）作为响应，搭配上@ResponseBody，使得以方法的返回值作为响应的主题内容，而不是解析为视图。
Spring中处理HTTP请求映射的注解@RestController@RequestMapping(&quot;/users&quot;)public class UserController&#123; @PostMapping(&quot;/create&quot;)/@GetMapping(&quot;list&quot;)public XXX  xxx&#123;        ...    &#125;&#125;

@RequestMapping
将web请求映射到具体方法上，标注在方法上。也可标注在类上，标注在类上时，表示类中所有响应请求的方法都是以该路径为父路径。
@PostMapping
组合注解。是@RequestMapping(method=RequestMethod.POST)的缩写。它用于处理HTTP POST请求的方法，只能标注在方法上。使用@PostMapping注解的方法将仅响应POST请求。
@GetMapping
组合注解。是@RequestMapping(method = RequestMethod.GET)的缩写。它用于处理HTTP GET请求的方法，也只能标注在方法上。使用@GetMapping注解的方法将仅响应GET请求。
SpringMVC接收前端传递的参数的注解@RequestParam 和 @RequestBody 都是从 HttpServletRequest request 中取参的，而 @PathVariable 是映射 URI 请求参数中的占位符到目标方法的参数中的.

@RequestParam  请求格式为：http://...?...=...&amp;...=...接收参数如下

defaultValue 如果本次请求没有携带这个参数，或者参数为空，那么就会启用默认值
name 绑定本次参数的名称，要跟URL上面的一样
required 这个参数不是必须的，如果为 true，不传参数会报错
value 跟name一样的作用，是name属性的一个别名


@RequestBody  两种接收方式： 一种是建立与 JSON 数据与之对应的实体，二是直接使用 Map&lt;String,Object&gt; 对象接收。使用需要满足如下条件：

Content-Type 为 application&#x2F;json，确保传递是 JSON 数据；
参数转化的配置必须统一，否则无法接收数据，比如 json、request 混用等


@PathVariable     请求格式：.../&#123;&#125;/&#123;&#125;同.../&#123;&#125;?...=... 接收参数如下

name 绑定参数的名称，默认不传递时，绑定为同名的形参。 赋值但名称不一致时则报错
value 跟name一样的作用，是name属性的一个别名
required 这个参数不是必须的，如果为 true，不传参数会报错

需要注意两点：

参数接收类型使用基本类型
如果@PathVariable标明参数名称，则参数名称必须和URL中参数名称一致



1、在 GET 请求中可以使用 @RequestParam，不能使用 @RequestBody，@RequestBody 是用来获取请求体中的参数，因为 GET 请求没有请求体，所以不能使用。
2.在post请求中

@RequestParam 适用于获取键值对形式的请求参数，来源包括 URL 查询字符串、application&#x2F;x-www-form-urlencoded 格式的请求体（表单默认格式）、multipart&#x2F;form-data 格式中的普通字段（非文件类型）。
@RequestBody 用于接收请求体中的完整数据，适用于非键值对形式的结构化数据（如 application&#x2F;json、application&#x2F;xml 等），通过消息转换器将请求体内容解析为目标 Java 对象。
特殊场景：multipart&#x2F;form-data 格式中的文件上传需用 @RequestPart；application&#x2F;x-www-form-urlencoded 格式为键值对结构，不适合用 @RequestBody 接收（会得到原始字符串，非推荐用法）。

3、一个方法中，可以同时使用多个 @RequestParam ，但是只能使用一个 @RequestBody，否则会报错。
4、@PathVariable 起到的作用就是 URI 请求参数中的占位符到目标方法参数的映射。
5、前端请求的  Content-Type ，默认值为 application/x-www-form-urlencoded，在这种格式下，后端直接使用 @RequestParam 就可以直接获取指定的参数，但是一旦前端传递的是 JSON 数据，也就是 Content-Type 的值为 application/json，那么使用 @RequestParam 是取不到值的，不但取不到值还报错。
Mybatis-plus优秀的 ORM 框架，致力于简化和提高 Java 应用程序对数据库访问的效率。
@Transactional只能应用到接口方法、类、还有public方法上。一般在@service标记的类上添加，可以将整个service类纳入Spring事务管理，采用统一的事务管理方式。
常用属性总结：

propagation：控制事务传播行为（如是否复用父事务），默认REQUIRED；
isolation：设置事务隔离级别（解决并发问题），默认用数据库默认值；
rollbackFor&#x2F;noRollbackFor：指定需要 &#x2F; 不需要回滚的异常类型；
readOnly：标记只读事务（优化查询性能），默认false；
timeout：设置事务超时时间（防止长事务，单位秒），默认无限制。

BaseMapper、IService和ServiceImpl在典型的三层架构中：

Controller 层：接收请求、返回结果
Service 层：业务逻辑编排
DAO 层 (Mapper)：直接操作数据库

MyBatis-Plus 提供了 BaseMapper 简化了 DAO 层的 CRUD，而在 Service 层，通常需要编写一堆相似的增删改查逻辑。为此，MyBatis-Plus 提供了 IService 接口 + ServiceImpl 实现类，将通用逻辑抽象出来。
IService&lt;T&gt;   ←——  通用 Service 接口（定义通用方法）   ↑ServiceImpl&lt;M extends BaseMapper&lt;T&gt;, T&gt;   ←——  通用 Service 实现类   ↑自定义 Service 实现类（继承 ServiceImpl）

常见问题
必须继承 ServiceImpl 吗？


不是必须。你也可以只用 BaseMapper，在 Controller 里直接调用。但这样会让业务层缺失，代码耦合度较高，推荐通过 ServiceImpl 来隔离业务逻辑与持久化。


如果要写自定义方法怎么办？


直接在 Service 接口和实现类中新增即可


与 Mapper 的关系？


Mapper：最贴近数据库，负责 SQL 层
ServiceImpl：封装 Mapper，并为业务提供统一接口

最佳实践：
接口分离：定义 Service 接口，避免直接在 Controller 注入 ServiceImpl
扩展业务逻辑：在继承的 ServiceImpl 上增加自己的方法，不要随意修改通用方法
批量操作：使用 saveBatch、updateBatchById 提升性能
LambdaQueryWrapper：结合 ServiceImpl 的查询方法，写法更简洁安全

BaseMapper主要作用是定义 DAO 层的数据库操作方法，例如数据的增删改查等。
通过智能的SQL生成机制，只要继承并指定对应的实体类，即可直接使用这些通用方法，无需手动编写 SQL 语句，从而减少了代码量和重复劳动。
// 定义一个继承 BaseMapper 的自定义 Mapper 接口public interface XXXMapper extends BaseMapper&lt;xxx&gt; &#123;    // 无需手写SQL，Mybatis-Plus 根据命名规范自动生成SQL&#125;

IService将常见的业务操作抽象化，包括保存、删除、更新、查询等。通过继承 IService 接口，并指定对应的实体类，即可直接使用这些通用方法，无需手动编写业务逻辑代码，使得代码更加简洁和易于维护。
封装的方法分为七类：save、remove、update、get、list、count、page（分页查询）
// 定义一个继承 IService 的自定义 Service 接口public interface XXXService extends IService&lt;xxx&gt; &#123;    // 定义常用的业务逻辑方法&#125;

ServiceImpl是 IService 接口的默认实现。是针对业务逻辑层的实现，并调用 BaseMapper 来操作数据库。还额外赋予了一些更加高级的查询操作，如 lambdaQuery、page 等
//源码public class ServiceImpl&lt;M extends BaseMapper&lt;T&gt;, T&gt; implements IService&lt;T&gt; &#123;    @Autowired    protected M baseMapper;        //...方法&#125;

常见方法如下：

新增


save(T entity)
saveBatch(Collection entityList)
saveOrUpdate(T entity)


删除


removeById(Serializable id)
removeByIds(Collection&lt;? extends Serializable&gt; idList)
remove(Wrapper queryWrapper)


修改


updateById(T entity)
update(T entity, Wrapper updateWrapper)
updateBatchById(Collection entityList)


查询


getById(Serializable id)
listByIds(Collection&lt;? extends Serializable&gt; idList)
list(Wrapper queryWrapper)
page(Page page, Wrapper queryWrapper)
getOne(Wrapper queryWrapper)


统计与判断


count()
exists(Wrapper queryWrapper)

ServiceImpl 对事务管理提供了支持。通过 @Transactional 注解，能够轻松地实现事务的控制。
实践代码：
// 在业务逻辑实现中继承 ServiceImpl，轻松构建业务方法@Service@Transactionalpublic class XXXServiceImpl extends ServiceImpl&lt;M, T&gt; implements XXXService &#123;    ...&#125;

传入的参数为 M 和 T：

M：Mapper 接口类型
T：对应实体类的类型

Wrapper
不直接关联 Mapper 接口，需手动传递给 Mapper 方法执行查询。
需调用 Mapper 方法（如 selectList(wrapper)）
分两步：先构建条件，再调用 Mapper
运用于复杂逻辑（如条件复用、动态判断）

QueryWrapper查询构造器，通过链式调用，灵活直观地进行复杂SQL查询，而无需手动编写SQL语句。不直接关联 Mapper 接口，需手动传递给 Mapper 方法执行查询。
操作流程：

创建QueryWrapper实例QueryWrapper&lt;实体类（代表数据库中的一张表）&gt; wrapper = new QueryWrapper&lt;&gt;()
添加查询条件（方法），支持链式调用
eq：等于  ne：不等于
gt：大于  ge：大于等于
lt：小于  le：小于等于
(not)like(left/right)：模糊匹配 (not)between 区间
(not)in：(不)在某个集合中
and   or
nested - 嵌套条件
orderby 排序
select
last在 SQL 末尾追加自定义片段  apply添加动态SQL片段


执行查询构造好的QueryWrapper，通过传递给Mybatis-Plus的Mapper接口方法来执行查询。返回值  x = xxxMapper.xxx方法(wrapper)

QueryWrapper与其他Wrapper的区别
QueryWrapper：专注于构建 SELECT 查询的条件。

UpdateWrapper：用于构建 UPDATE 语句，支持条件和 SET 子句。（set）

LambdaQueryWrapper：QueryWrapper 的 Lambda 版本，使用 Lambda 表达式指定字段。
// 效果同QueryWrapper示例，但用Lambda引用字段LambdaQueryWrapper&lt;User&gt; lambdaQuery = new LambdaQueryWrapper&lt;&gt;();lambdaQuery.gt(User::getAge, 18)  // 用Lambda表达式引用字段，编译期检查           .like(User::getUsername, &quot;张&quot;);List&lt;User&gt; userList = userMapper.selectList(lambdaQuery);

LambdaUpdateWrapper：UpdateWrapper 的 Lambda 版本。
// 效果同UpdateWrapper示例，用Lambda引用字段LambdaUpdateWrapper&lt;User&gt; lambdaUpdate = new LambdaUpdateWrapper&lt;&gt;();lambdaUpdate.set(User::getAge, 20)            .set(User::getStatus, 1)            .eq(User::getId, 1)            .eq(User::getUsername, &quot;张三&quot;);userMapper.update(null, lambdaUpdate);

ChainWrapper
内置 Mapper，创建时绑定
自带执行方法（如 list()、update()）
链式调用，一步完成条件 + 执行
简单查询 &#x2F; 更新，追求代码简洁

QueryChainWrapperquery() 方法是 BaseMapper 接口提供的一个默认方法

快速创建 QueryChainWrapper 实例（自动绑定当前 Mapper）；
支持直接链式调用查询条件方法（eq、like 等）和执行方法（list、one 等）；
让代码更简洁，减少手动创建包装器的模板代码。

// 简化方式：通过 mapper.query() 获取 QueryChainWrapperList&lt;User&gt; users = userMapper.query()  // 直接获取链式查询包装器    .eq(&quot;status&quot;, 1)    .list();

query() 方法与 Service 层的结合
在 Service 实现类中（通常继承 ServiceImpl&lt;M extends BaseMapper&lt;T&gt;, T&gt;），调用 BaseMapper 提供的 query() 方法，获取 QueryChainWrapper&lt;User&gt; 实例，进一步简化代码。
User user=query().eq(&quot;phone&quot;,phone).one();

若不用链式查询，等价代码如下
QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();queryWrapper.eq(&quot;phone&quot;, phone);User user = userMapper.selectOne(queryWrapper); // 手动调用 Mapper 方法

QueryChainWrapper：

作用：用于构建查询条件（WHERE、ORDER BY 等），并直接执行查询操作（如查询列表、单条数据、数量等）。

核心方法：

条件方法：eq()（等于）、like()（模糊查询）、orderBy()（排序）等（与 QueryWrapper 一致）。
执行方法：list()（查询列表）、one()（查询单条）、count()（查询数量）等。


// 常规方法，链式查询：查询name为&quot;张三&quot;且age≥18的用户列表
List&lt;User&gt; users = new QueryChainWrapper&lt;&gt;(userMapper)
    .eq(&quot;name&quot;, &quot;张三&quot;)
    .ge(&quot;age&quot;, 18)
    .orderByDesc(&quot;create_time&quot;)
    .list(); // 直接执行查询
#### UpdateChainWrapper- **作用**：用于构建更新条件（`SET` 字段值 + `WHERE` 条件），并直接执行更新操作。- 核心方法：  - 字段方法：`set()`（设置更新字段）、`setSql()`（直接写 SQL 片段）等。  - 条件方法：`eq()`、`in()` 等（与 `UpdateWrapper` 一致）。  - 执行方法：`update()`（执行更新）。- ```java  // 链式更新：将name为&quot;张三&quot;的用户age改为20  boolean success = new UpdateChainWrapper&lt;&gt;(userMapper)      .set(&quot;age&quot;, 20)      .eq(&quot;name&quot;, &quot;张三&quot;)      .update(); // 直接执行更新



ThreadLocal在 Tomcat 处理 HTTP 请求的流程中，每个用户请求都会由 Tomcat 线程池中的「独立线程」处理（线程从池内取出 → 处理请求 → 用完回收）。由于不同用户的请求由不同线程执行，且线程会经过 Controller、Service、DAO 等多层组件调用，此时需要一种机制，让 “当前请求的专属数据” 能在线程内的各组件间共享，同时又不与其他线程的请求数据冲突 —— 这正是 ThreadLocal 的核心价值。
ThreadLocal的作用与适配性：
ThreadLocal 的原理是 为每个线程维护一份「独立的变量副本」：
当 Tomcat 的工作线程开始处理请求时，会把「当前请求的上下文数据」（比如用户身份信息、事务管理器、自定义的请求作用域数据等）存入 ThreadLocal；
之后，在该线程执行过程中（从 Controller 接收参数，到 Service 处理业务，再到 DAO 操作数据库），所有组件都能从 ThreadLocal 中获取 “当前请求专属” 的数据，且不会与其他线程（其他用户的请求）的数据产生冲突。
总结：
因为 “每个用户请求对应独立线程” 的特性，ThreadLocal 能让每个线程只操作自己的那份数据，既保证了 “同一请求内多组件共享数据”，又天然实现了 “线程隔离”，完美适配 Web 应用中 “请求 - 线程 - 多组件协作” 的场景。
拦截器HandlerInterceptorSpring MVC 的 HandlerInterceptor 是贯彻 AOP 思想、用于拦截 Spring MVC 请求的核心组件，仅作用于 Spring MVC 处理的请求，生命周期由 Spring 管理，可在请求到 Controller 前、Controller 执行后、视图渲染完成后三个阶段插入自定义逻辑，实现权限验证、日志记录、资源清理等横切需求。
其核心有 3 个方法：

preHandle（正序执行）：请求前置处理，返回true则继续请求，false则中断，常用于登录校验；
postHandle（逆序执行）：Controller 执行后、视图渲染前处理，可修改ModelAndView，如加全局数据；
afterCompletion（逆序执行）：请求全流程结束后执行（无论成败），用于资源清理，如关连接、清ThreadLocal。

拦截器通过HandlerExecutionChain封装成链，执行规则为 “preHandle 正序、后两个方法逆序”；与 Servlet Filter 相比，它对 Spring MVC 请求控制更精细，配置依赖WebMvcConfigurer，还可通过Ordered&#x2F;@Order排序、MappedInterceptor动态匹配路径，优化时需避免耗时操作、控制作用范围。
要使拦截器生效，需要配置拦截器需要在实现了WebMvcConfigurer的配置类（@Configuration），编写addInterceptors(InterceptroRegistry registry)方法，使用注册器registry通过addInterceptor方法来配置拦截路径。
import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;// 拦截器配置类（@Configuration 标记为Spring配置类）@Configurationpublic class MvcInterceptorConfig implements WebMvcConfigurer &#123;    /**     * 注册拦截器，并配置拦截/排除路径     */    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        // 1. 注册自定义的LoginInterceptor        registry.addInterceptor(new LoginInterceptor())                // 2. 配置「需要拦截」的路径（Ant风格，/** 表示所有请求）                .addPathPatterns(&quot;/**&quot;)                 // 3. 配置「不需要拦截」的路径（排除登录、静态资源等）                .excludePathPatterns(                        &quot;/login&quot;,          // 登录接口（未登录时需访问，不拦截）                        &quot;/register&quot;,       // 注册接口（同理不拦截）                        &quot;/static/**&quot;,      // 静态资源（CSS、JS、图片等，不拦截）                        &quot;/error&quot;           // 错误页面（如404、500，不拦截）                );    &#125;&#125;

若需注册多个拦截器（如 “登录拦截器”+“日志拦截器”），可在 addInterceptors 中多次调用
使用Hutool工具类进行对象属性拷贝Hutool 提供了 BeanUtil 和 CollUtil 工具类，可简洁实现实体类对象及 List 集合的属性拷贝（相同属性值复制），无需手动编写 set&#x2F;get 代码。
以下是具体实现方式：

实体类对象拷贝（单个对象）
使用 BeanUtil.copyProperties 方法，自动复制两个对象间名称和类型相同的属性。

List 集合拷贝（批量对象）
通过 BeanUtil.copyProperties 结合流处理，批量拷贝集合中所有对象的属性。


拷贝规则：

仅复制名称和类型均相同的属性（类型需兼容，如 int 与 Integer 可互转）。
目标对象中独有的属性（如 UserDTO 的 extra）会被忽略，源对象中独有的属性也不会影响目标对象。

注意事项：

若属性名不同，可通过 BeanUtil.copyProperties 的重载方法自定义映射规则（如 CopyOptions）。

隐藏用户信息前后端数据交互的标准最佳实践：
通过DTO对象类进行前后端传递数据。entity类负责跟数据库交换数据。

Entity 类（与数据库交互，含敏感字段）
DTO 类（前后端传输，隐藏敏感信息）

代码实现发送验证码IUserService声明，UserServiceImpl实现
@Overridepublic Result sendCode(String phone, HttpSession session) &#123;    // 1.校验手机号    if (RegexUtils.isPhoneInvalid(phone)) &#123;        // 2.如果不符合，返回错误信息        return Result.fail(&quot;手机号格式错误！&quot;);    &#125;    // 3.符合，生成验证码    String code = RandomUtil.randomNumbers(6);    // 4.保存验证码到 session    session.setAttribute(&quot;code&quot;,code);    // 5.发送验证码    log.debug(&quot;发送短信验证码成功，验证码：&#123;&#125;&quot;, code);    // 返回ok    return Result.ok();&#125;

登录 @Override   public Result login(LoginFormDTO loginForm, HttpSession session) &#123;       // 1.校验手机号       String phone = loginForm.getPhone();       if (RegexUtils.isPhoneInvalid(phone)) &#123;           // 2.如果不符合，返回错误信息           return Result.fail(&quot;手机号格式错误！&quot;);       &#125;       // 3.校验验证码       Object cacheCode = session.getAttribute(&quot;code&quot;);       String code = loginForm.getCode();       if(cacheCode == null || !cacheCode.toString().equals(code))&#123;           //3.不一致，报错           return Result.fail(&quot;验证码错误&quot;);       &#125;       // 4.验证码一致，查询用户       User user=query().eq(&quot;phone&quot;,phone).one();       if(user == null)&#123;           // 5.用户不存在，创建           user =  createUserWithPhone(phone);       &#125;       //6.保护用户信息到session       session.setAttribute(&quot;user&quot;,user);       //7.返回ok       return Result.ok();   &#125;   private User createUserWithPhone(String phone) &#123;       User user = new User();       user.setPhone(phone);       return user;&#125;

登录校验拦截器拦截器代码，在utils包下创建
public class LoginInterceptor implements HandlerInterceptor &#123;    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;    &#125;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        //1.获取session        HttpSession session = request.getSession();        //2.获取session中的用户        Object user = session.getAttribute(&quot;user&quot;);        //3.判断用户是否存在        if(user != null) &#123;            //4.不存在就拦截，返回401状态码            response.setStatus(401);            return false;        &#125;        //5.存在,保存用户信息到ThreadLocal        UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class);        UserHolder.saveUser(userDTO);        //6.放行        return true;    &#125;&#125;

添加拦截器，配置类
public class MvcConfig implements WebMvcConfigurer &#123;    @Resource    private StringRedisTemplate stringRedisTemplate;    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        // 登录拦截器        registry.addInterceptor(new LoginInterceptor())                .excludePathPatterns(                        &quot;/shop/**&quot;,                        &quot;/voucher/**&quot;,                        &quot;/shop-type/**&quot;,                        &quot;/upload/**&quot;,                        &quot;/blog/hot&quot;,                        &quot;/user/code&quot;,                        &quot;/user/login&quot;                ).order(1);    &#125;&#125;

]]></content>
      <categories>
        <category>黑马点评笔记</category>
      </categories>
      <tags>
        <tag>session</tag>
        <tag>Hutool工具</tag>
        <tag>Mybatis-plus</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>01-总览</title>
    <url>/2025/09/20/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/01-%E6%80%BB%E8%A7%88/</url>
    <content><![CDATA[
黑马点评的收获概览极大的提高基础编程能力
Java8新特性
stream流的用法
函数式编程


深化mybatis plus
mp的高级用法，sql与api穿插解决问题
mp框架的一些小问题（比如，list查id的时候，是乱序的），能够如何去优化


模型转换概念（pojo、entity、vo、dto、requires）
线程池的实际使用
java阻塞队列初识

深度学习redis所有数据结构用法，深度理解缓存概念
8种数据结构，每种都匹配了实际的开发需求功能
对于缓存的知识讲解全面，cache aside等业界常用缓存方案
深度练习springboot中的redis的api

对具体业务理解能力的提高提高编程效率，更加高效的使用工具类，编写工具类
使用hutool工具包
结合泛型高级应用与函数式编程，手搓适合自己的工具类

面试能力的提升
能够掌握分布式锁、缓存击穿、缓存穿透、缓存雪崩等面试必考点
redisson源码解读，掌握redis的高级用法，看门狗机制，muti-lock机制等面试加分亮点

进阶技能拓展
redis秒杀场景教学
原子性的深度理解与应用
多种秒杀方案讲解，针对单体和微服务并发情况展开。


学会lua脚本的基本编写，了解lua脚本的使用场景。lua脚本就是做原子性的业务，也可以做在nginx服务器的脚本去调redis。
学会nginx轻量服务器的搭建以及各种使用场景
多级缓存的的搭建，本地缓存caffine的使用
feed流的两种模式

希望我能够做到
提升业务熟练度⬆
提升写sql的熟练度⬆

如何转化到自己的简历上
更换内容
技术点嵌套
缓存解决方案
秒杀-分布式锁
多级缓存



]]></content>
      <categories>
        <category>黑马点评笔记</category>
      </categories>
      <tags>
        <tag>学习大纲</tag>
      </tags>
  </entry>
  <entry>
    <title>新增代码复制按钮功能</title>
    <url>/2025/09/21/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE/%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81%E5%A4%8D%E5%88%B6%E6%8C%89%E9%92%AE%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[
参考文章Add Copy Button to Code Blocks in Hexo | Hexo
照着大佬来就好了！祝大家幸福美满。
]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>博客功能</tag>
      </tags>
  </entry>
  <entry>
    <title>改善黑暗模式中的代码显示</title>
    <url>/2025/09/21/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE/%E6%94%B9%E5%96%84%E9%BB%91%E6%9A%97%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[
参考文章：Sync Code Block Theme with Dark Mode in Hexo Chic | Hexo
没什么好说的，照着来就行。祝大家生活愉快，心想事成。
]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>博客功能</tag>
      </tags>
  </entry>
  <entry>
    <title>新增评论功能</title>
    <url>/2025/09/17/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE/%E6%96%B0%E5%A2%9E%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[使用giscus增加博客评论功能利用 GitHub Discussions 实现的评论系统

开源。🌏
无跟踪，无广告，永久免费。📡 🚫
无需数据库。所有数据均储存在 GitHub Discussions 中。:octocat:
支持自定义主题！🌗
支持多种语言。🌐
高可配置性。🔧
自动从 GitHub 拉取新评论与编辑。🔃
可自建服务！🤳

不同主题不同配置方法
以下是大佬的文章：
hexo 博客添加评论系统 | Jachin’s Blog
附上适合本主题的大佬链接Hexo and Chic themes add Giscus comment system | Hexo
]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title>记录搭建博客流程😗</title>
    <url>/2025/09/16/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE/%E8%AE%B0%E5%BD%95%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%B5%81%E7%A8%8B%F0%9F%98%97/</url>
    <content><![CDATA[说明记录一下博客搭建流程，为了能够以后更好的复现。
框架及工具
前端框架：hexo
后台管理系统插件：hexo pro
静态网站托管：github page
免费的 CDN 加速站点：cloudflare

准备需要准备 node 环境和 git
可以使用到 node 的版本管理工具****nvm 来下载 node。
# 访问 nvm 的 GitHub 仓库页面：https://github.com/nvm-sh/nvm# 可以在 Releases 页面（https://github.com/coreybutler/nvm-windows/releases）找到 nvm-setup.zip 安装文件并下载。# 解压并运行安装程序，按照提示进行安装。# nvm -v可以检查是否安装成功#NVM换源将如下代码加入settings.txt文件中。node_mirror: https://npmmirror.com/mirrors/nodenpm_mirror: https://npmmirror.com/mirrors/npm#NVM命令nvm version                # 查看NVM版本，是否安装成功nvm list available         # 查看可安装的node版本nvm list                   # 查看已安装的node版本nvm install 版本号          # 安装nodenvm uninstall 版本号        # 卸载nodenvm use 版本号              # 切换使用node版本nvm current                # 当前使用node版本nvm node_mirror [url]      # 切换node镜像[https://npm.taobao.org/mirrors/node/]nvm npm_mirror [url]       # 切换npm镜像[https://npm.taobao.org/mirrors/npm/]nvm alias default version  # 设置默认版本 #其他npm install -g yarn           # 全局安装yarnnpm install -g gitbook-cli   # 全局安装gitbook

通过 nvm 下载前需要把已经安装的 node 卸载
可以通过 Geek 卸载Geek Uninstaller - Download
通过 nvm 来下载：
1.打开终端（Windows 上是命令提示符或 PowerShell）
2.nvm list available 这个可以列出可以安装的 node 所有的版本
3.选择您想要安装的版本，例如安装 Node.js 版本 16.18.0 ，输入以下命令：nvm install 16.18.0
4.然后可以使用 nvm list 查看自己下载的版本
5.nvm use 16.18.0 安装完成后，可以使用命令切换到已安装的版本
6.再次 node -v 就可以看到安装的版本了
开始初始化 hexo 项目先安装 Hexo文档 | Hexo
npm install -g hexo-cli
创建文件夹，并进入到该文件夹的命令提示符（cmd）
输入hexo init 项目就会初始化
出现Start blogging with Hexo!表示成功
紧接着执行npm install
初始化后，您的项目文件夹将如下所示：
.├── _config.yml   #hexo的主配置文件├── package.json    #项目的依赖管理文件├── scaffolds   #模板文件夹├── source  #资源文件夹|   ├── _drafts #存放草稿文章|   └── _posts  #存放已经发布的文章└── themes  #主题文件夹

本地部署指令：hexo server 或 hexo s

访问 🔗，即可看到刚刚部署的网页了。
安装 hexo pro 插件wuzheng228&#x2F;hexo-pro
接下来安装 hexo pro 插件
# 1. 安装 Hexo Pro 插件npm install --save hexo-pro# 2. 启动 Hexo 服务器hexo server# 3. 访问后台管理页面http://localhost:4000/pro/

界面如下：

接下来我们就可以在这个系统里轻松地上传内容、更改配置、部署。
更改 hexo 配置更改_config.yml 的配置内容的操作自行根据官网文档来改。这边不多赘述。
配置 | Hexo
配置 github pagesGitHub Pages 文档 - GitHub 文档
首先默认大家有 GitHub 账户。
创建仓库（官网非常详细，我就粘下来啦）
在任何页面的右上角，选择 ，然后单击“新建存储库”。
**输入 **username.github.io 作为存储库名称。 将 username 替换为你的 GitHub 用户名。 例如，如果用户名为 octocat，则存储库名称应为 octocat.github.io。
选择仓库可见性。 有关详细信息，请参阅“关于仓库”。（默认 public）
选择“使用 README 初始化此存储库”。****（可选）
单击“创建存储库”。

部署代码连接 GitHub 的两种方式第一种使用 HTTPS 连接复制 GitHub 链接

第二种使用 SSH 连接如果选择 SSH 则需要通过 SSH 连接到 GitHub - GitHub 文档

执行以下命令生成 ssh 公钥，此公钥用于你的计算机连接 Github
ssh-keygen -t rsa -C &quot;你的邮箱&quot;

如下：

之后打开 C 盘下用户文件夹下的.ssh 的文件夹，会看到 id_rsa.pub
用记事本打开上述图片中的公钥（id_rsa.pub），复制里面的内容，然后开始在 github 中配置 ssh 密钥。

将 SSH KEY 配置到 GitHub 进入 github，点击右上角头像 选择settings，进入设置页后选择 SSH and GPG keys，名字随便起，公钥填到 Key 那一栏。

测试连接，输入以下命令
ssh -T git@github.com


出现连接到账户的信息，说明已经大功告成。


配置连接方式注意：通过Hexo Pro部署目前只能通过HTTPS的链接。
接下来只需要修改_config.yml 中最后一行的 deploy 的属性
deploy:  type: git   repo: #粘贴刚才所复制的HTTPS链接  branch: main #注意是main，不是master  message: &#x27;Site updated: &#123;&#123; now(&quot;YYYY-MM-DD HH:mm:ss&quot;) &#125;&#125;&#x27;

注意： yml 格式的文件，对应低一级的字段要在上级字段前至少空两格
现在我们在部署这栏中填写我们的仓库地址

仓库地址格式: username&#x2F;repository
紧接着点击执行部署即可。
然后就可以访问啦。😁
使用ssh部署，只能通过命令行也是先把仓库链接填上
deploy:  type: git  repo: git@github.com:meisijiya/meisijiya.github.io.git  branch: main  message: &#x27;Site updated: &#123;&#123; now(&quot;YYYY-MM-DD HH:mm:ss&quot;) &#125;&#125;&#x27;

部署的命令如下：

hexo clean：删除之前生成的文件，若未生成过静态文件，可忽略此命令。
hexo generate：生成静态文章，可以用 hexo g 缩写
hexo deploy：部署文章，可以用 hexo d 缩写

以下内容备用（一般执行完上面的步骤就可以了）
在存储库名称下，单击 “设置”。 如果看不到“设置”选项卡，请选择“”下拉菜单，然后单击“设置”。

在边栏的“代码和自动化”部分中，单击“ Pages”。

在“生成和部署”的“源”下，选择“从分支进行部署”。

在“生成和部署”的“分支”下，使用分支下拉菜单并选择发布源。8、9 的操作如下：


（可选）打开存储库的README.md 文件。 README.md 文件是你将为站点编写内容的位置。 您可以编辑文件或暂时保留默认内容。

访问 username.github.io 以查看新网站。 请注意，对站点的更改在推送到 GitHub 后，最长可能需要 10 分钟才会发布。


更改标题和说明（粘自官网）默认情况下，站点的标题为 username.github.io。 可通过编辑存储库中的 _config.yml 文件来更改标题。 您还可以为您的网站添加说明。

单击存储库的“代码”选项卡。
在文件列表中，单击 _config.yml 以打开该文件。
单击 编辑文件。
_config.yml 文件已包含指定站点主题的行。 添加一个新行，其中 title: 后跟所需的标题。 添加一个新行，其中 description: 后跟所需的描述。 例如：theme: jekyll-theme-minimaltitle: Octocat&#x27;s homepagedescription: Bookmark this to keep an eye on my project updates!
编辑完文件后，单击“提交更改”。

购买域名并更换域名域名购买参考如下：全网最全的域名解析和网站备案-CSDN 博客
替换域名
每次 deploy 的时候这里都会被重置为空
解决方法是在你博客项目下的****public 文件夹中创建一个名为 CNAME 的文件,注意，该文件无后缀。
用文本编辑器打开并填入你的域名（注意，不需要加入 https:&#x2F;&#x2F;，只需要域名）
这样就不用每部署一次就来填写一次自己的域名了。
此时访问你的域名，就会直接跳转到你的 github page 项目中。
使用 cloudflare 做 cdn 加速当然也有别的选择如，Vercel、Netlify、Railway、Render、Fleek、Zeabur
**这里我选择 cloudflare  **https://dash.cloudflare.com/
在账户主页 那一栏，点击 加入域

添加域名，然后点继续，接着选择免费计划即可。
接下来添加 DNS 记录
点击添加记录
名称一栏填 @，地址填下面出现的四个 ip 地址


使域名指向 github 的 IPv4 地址，这四个 IP（185.199.108.153、185.199.109.153、185.199.110.153、185.199.111.153）是 GitHub Pages 官方指定的用于内容分发的 IP，配置后域名会指向 GitHub 的服务器，从而能访问部署在 GitHub Pages 上的内容。
**保持后等待即可，因为 **DNS 解析依赖 “缓存” 和 “全球节点同步”，这两个机制决定了配置变更不会立即生效。
进阶–使用 Chic 主题Themes | Hexo
选择喜欢的主题，点击进入开发者产品的 readme 来一步一步配置即可。
我选择 Chic 这个主题，因为简单哈哈哈，当然也简洁美。🥰
hexo-theme-Chic&#x2F;README-CN.md at master · Siricee&#x2F;hexo-theme-Chic
操作步骤
cd your-blog/themes #进入到themes文件夹中git clone https://github.com/Siricee/hexo-theme-Chic.git Chic #打开cmd，然后输入该指令克隆即可// Modify theme setting in _config.yml to Chic.###需要我们在主配置文件_config.yml中，修改theme的值为Chic

然后我们可以看到&#x2F;theme&#x2F;Chic 这个文件夹中有_config.yml 配置文件，修改值来改变样式即可
添加 Tag、Category 页面
Hexo 初始化没有 tag、category 页面，需要自行添加，本主题请按以下步骤进行:
执行命令
hexo new page taghexo new page category

进入页面目录
cd source/tag

增加 layout 字段
// source\tag\index.md---title: Taglayout: tag---

category 页面同理，layout 字段键值为 category。
剩下的内容再更新吧，谢谢观看]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title>新增本地搜索</title>
    <url>/2025/09/21/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE/%E6%96%B0%E5%A2%9E%E6%9C%AC%E5%9C%B0%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[
参考原文Custom Search Integration for Hexo Chic | Hexo
tip：改了改，感觉我的有点屎山（不太会前端，得恶补一下js）
1.基于hexo-generator-searchdb实现的本地搜索npm install hexo-generator-searchdb #安装插件依赖

2.配置根目录的_config.ymlsearch:  path: search.xml   field: all  content: true   format: striptags 


path - 生成的数据库文件的路径。支持.json和.xml格式。如果未提供文件扩展名，默认将使用JSON格式。 
field - 你想要搜索的范围，你可以选择： post（默认）- 仅涵盖你博客的所有文章。 page - 仅涵盖你博客的所有页面。 all - 涵盖你博客的所有文章和页面。 
content - 是否包含每篇文章的完整内容。如果为false，生成的结果仅包含标题和其他元信息，不包含正文。默认值为true。
format - 页面内容的形式，选项有： striptags（默认）- 原始html字符串被压缩，并移除所有标签。 html - 原始html字符串被压缩。 raw - 每个文章或页面的markdown文本。

3.新建 search.css建议路径: themes/hexo-theme-Chic/source/css/search.css
/* 搜索框容器 */.search-container &#123;  position: relative;  display: inline-block;  vertical-align: middle;  margin-right: 10px;&#125;.search-container a &#123;  padding-right: 6px;  cursor: pointer;  font-size: 1.1em;&#125;.nav-search-input &#123;  display: none;  padding: 6px 10px;  border: 1px solid #ccc;  border-radius: 4px;  width: 260px;  transition: all 0.3s ease;  vertical-align: middle;&#125;.nav-search-input.active &#123;  display: inline-block;&#125;.nav-search-result &#123;  position: absolute;  top: 100%;  left: 0;  background: white;  border: 1px solid #ccc;  border-radius: 6px;  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);  margin-top: 6px;  padding: 0.4em;  min-width: 260px;  max-height: 360px;  overflow-y: auto;  display: none;  z-index: 999;&#125;/* 搜索卡片 */.search-card &#123;  padding: 4px 6px;  margin-bottom: 3px;  border-bottom: 1px solid #eee;  transition: background 0.2s;&#125;.search-card:last-child &#123;  border-bottom: none;  margin-bottom: 0;&#125;.search-card:hover &#123;  background: #f9f9f9;&#125;.search-card-title &#123;  display: block;  font-weight: bold;  color: #1a0dab;  font-size: 1em;  line-height: 1.2em;  text-decoration: none;  margin: 0;  padding: 0;  text-align: left;&#125;.search-card-title:hover &#123;  text-decoration: underline;&#125;.search-card-snippet &#123;  font-size: 0.88em;  color: #444;  margin-top: 2px;  line-height: 1.3em;  display: -webkit-box;  -webkit-line-clamp: 2;  -webkit-box-orient: vertical;  overflow: hidden;&#125;/* 🌙 暗色主题适配 */.dark-theme .nav-search-input &#123;  background-color: #1e1e1e;  color: #eee;  border: 1px solid #555;&#125;.dark-theme .nav-search-result &#123;  background-color: #2a2a2a;  color: #eee;  border: 1px solid #555;&#125;.dark-theme .search-card &#123;  border-bottom: 1px solid #444;&#125;.dark-theme .search-card:hover &#123;  background: #333;&#125;.dark-theme .search-card-title &#123;  color: #4ea1ff;&#125;.dark-theme .search-card-snippet &#123;  color: #ccc;&#125;/* 移动端适配 *//* iPadmini适配 */@media (min-width: 481px) and (max-width: 767px) &#123;  .search-container a &#123;    display: none;  &#125;&#125;@media (max-width: 768px) &#123;  .nav-search-input &#123;    width: 90%;    display: block;    margin: 10px auto;  &#125;  /* 暗色主题下的移动端结果容器 */  .dark-theme .nav-search-result &#123;    background-color: #2a2a2a;  &#125;&#125;/* 全局定位的移动端搜索结果 */@media (max-width: 768px) &#123;  .nav-search-result &#123;    position: fixed;           /* 相对于视窗定位 */    top: 20%;                  /* 距离顶部20% */    left: 5%;    right: 5%;    z-index: 9999;             /* 更高的层级 */    max-height: 60vh;          /* 更大的最大高度 */    margin: 0;    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);  &#125;&#125;

4.修改主题配置打开theme/Chic/_config.yml ，在 stylesheets 下增加一行 search.css 确保加载样式文件：
stylesheets:  - /css/style.css  - /css/search.css

5.修改 header.ejs&lt;header&gt;  &lt;nav class=&quot;navbar&quot;&gt;    &lt;div class=&quot;container&quot;&gt;      &lt;div class=&quot;navbar-header header-logo&quot;&gt;        &lt;a href=&quot;&lt;%- config.root %&gt;&quot;&gt;&lt;%= theme.navname %&gt;&lt;/a&gt;      &lt;/div&gt;      &lt;div class=&quot;menu navbar-right&quot;&gt;        &lt;!-- 在电脑端的导航链接区域添加搜索功能 --&gt;        &lt;div class=&quot;search-container&quot;&gt;          &lt;a href=&quot;javascript:;&quot; onclick=&quot;toggleSearchInput()&quot;&gt;🔍&lt;/a&gt;          &lt;input            type=&quot;text&quot;            id=&quot;nav-search-input-desktop&quot;            class=&quot;nav-search-input&quot;            placeholder=&quot;想知道我什么秘密呢，搜搜看吧&quot;            oninput=&quot;navSearch(this)&quot;          /&gt;          &lt;div id=&quot;nav-search-result-desktop&quot; class=&quot;nav-search-result&quot;&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;% for (var i in theme.nav)&#123; %&gt;        &lt;a class=&quot;menu-item&quot; href=&quot;&lt;%- url_for(theme.nav[i]) %&gt;&quot;&gt;&lt;%= i %&gt;&lt;/a&gt;        &lt;% &#125; %&gt;        &lt;input id=&quot;switch_default&quot; type=&quot;checkbox&quot; class=&quot;switch_default&quot; /&gt;        &lt;label for=&quot;switch_default&quot; class=&quot;toggleBtn&quot;&gt;&lt;/label&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/nav&gt;  &lt;%# mobile %&gt;  &lt;nav class=&quot;navbar-mobile&quot; id=&quot;nav-mobile&quot;&gt;    &lt;div class=&quot;container&quot;&gt;      &lt;div class=&quot;navbar-header&quot;&gt;        &lt;div&gt;          &lt;a href=&quot;&lt;%- config.root %&gt;&quot;&gt;&lt;%= theme.navname %&gt;&lt;/a          &gt;&lt;a id=&quot;mobile-toggle-theme&quot;&gt;·&amp;nbsp;Light&lt;/a&gt;        &lt;/div&gt;        &lt;div class=&quot;menu-toggle&quot; onclick=&quot;mobileBtn()&quot;&gt;          &lt;svg            class=&quot;menu-icon&quot;            xmlns=&quot;http://www.w3.org/2000/svg&quot;            width=&quot;32&quot;            height=&quot;32&quot;            viewBox=&quot;0 0 24 24&quot;          &gt;            &lt;path              fill=&quot;currentColor&quot;              d=&quot;M4.5 17.27q-.213 0-.356-.145T4 16.768t.144-.356t.356-.143h15q.213 0 .356.144q.144.144.144.357t-.144.356t-.356.143zm0-4.77q-.213 0-.356-.144T4 11.999t.144-.356t.356-.143h15q.213 0 .356.144t.144.357t-.144.356t-.356.143zm0-4.77q-.213 0-.356-.143Q4 7.443 4 7.23t.144-.356t.356-.143h15q.213 0 .356.144T20 7.23t-.144.356t-.356.144z&quot;            /&gt;          &lt;/svg&gt;          &lt;svg            class=&quot;close-icon&quot;            xmlns=&quot;http://www.w3.org/2000/svg&quot;            width=&quot;32&quot;            height=&quot;32&quot;            viewBox=&quot;0 0 24 24&quot;          &gt;            &lt;!-- Icon from Material Symbols Light by Google - https://github.com/google/material-design-icons/blob/master/LICENSE --&gt;            &lt;path              fill=&quot;currentColor&quot;              d=&quot;m12 12.708l-5.246 5.246q-.14.14-.344.15t-.364-.15t-.16-.354t.16-.354L11.292 12L6.046 6.754q-.14-.14-.15-.344t.15-.364t.354-.16t.354.16L12 11.292l5.246-5.246q.14-.14.345-.15q.203-.01.363.15t.16.354t-.16.354L12.708 12l5.246 5.246q.14.14.15.345q.01.203-.15.363t-.354.16t-.354-.16z&quot;            /&gt;          &lt;/svg&gt;        &lt;/div&gt;      &lt;/div&gt;      &lt;div class=&quot;menu&quot; id=&quot;mobile-menu&quot;&gt;        &lt;% for (var i in theme.nav)&#123; %&gt;        &lt;a class=&quot;menu-item&quot; href=&quot;&lt;%- url_for(theme.nav[i]) %&gt;&quot;&gt;&lt;%= i %&gt;&lt;/a&gt;        &lt;% &#125; %&gt;        &lt;!-- 手机模式搜索框 --&gt;        &lt;div class=&quot;search-container mobile-container&quot;&gt;          &lt;a class=&quot;menu-item&quot; href=&quot;javascript:;&quot; onclick=&quot;toggleSearchInput()&quot;            &gt;🔍&lt;/a          &gt;          &lt;input            type=&quot;text&quot;            id=&quot;nav-search-input-mobile&quot;            class=&quot;nav-search-input&quot;            placeholder=&quot;想知道我什么秘密呢，搜搜看吧&quot;            oninput=&quot;navSearch(this)&quot;          /&gt;          &lt;div id=&quot;nav-search-result-mobile&quot; class=&quot;nav-search-result&quot;&gt;&lt;/div&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/nav&gt;&lt;/header&gt;&lt;script&gt;  var mobileBtn = function f() &#123;    var toggleMenu = document.getElementsByClassName(&quot;menu-toggle&quot;)[0];    var mobileMenu = document.getElementById(&quot;mobile-menu&quot;);    if (toggleMenu.classList.contains(&quot;active&quot;)) &#123;      toggleMenu.classList.remove(&quot;active&quot;);      mobileMenu.classList.remove(&quot;active&quot;);    &#125; else &#123;      toggleMenu.classList.add(&quot;active&quot;);      mobileMenu.classList.add(&quot;active&quot;);    &#125;  &#125;;  function toggleSearchInput() &#123;    const inputs = document.querySelectorAll(&quot;.nav-search-input&quot;);    const results = document.querySelectorAll(&quot;.nav-search-result&quot;);    inputs.forEach((input) =&gt; &#123;      input.classList.toggle(&quot;active&quot;);      if (input.classList.contains(&quot;active&quot;)) input.focus();    &#125;);    results.forEach((r) =&gt; (r.style.display = &quot;none&quot;));  &#125;  // 点击外部区域隐藏搜索框和结果容器的函数  function handleClickOutsideSearch(event) &#123;    const searchContainers = document.querySelectorAll(&quot;.search-container&quot;);    searchContainers.forEach((container) =&gt; &#123;      const searchInput = container.querySelector(&quot;.nav-search-input&quot;);      const searchIcon = container.querySelector(&quot;a&quot;);      // 如果点击的元素不是搜索输入框或搜索图标，则隐藏搜索框和结果容器      if (        !searchInput.contains(event.target) &amp;&amp;        !searchIcon.contains(event.target)      ) &#123;        searchInput.classList.remove(&quot;active&quot;);        searchInput.value = &quot;&quot;        // 根据输入框ID确定对应的结果容器        let resultContainer;        if (searchInput.id === &quot;nav-search-input-mobile&quot;) &#123;          // 移动端结果容器          resultContainer = document.querySelector(            &quot;.navbar-mobile .nav-search-result&quot;          );        &#125; else &#123;          // 桌面端结果容器          resultContainer = document.getElementById(            &quot;nav-search-result-desktop&quot;          );        &#125;        if (resultContainer) &#123;          resultContainer.style.display = &quot;none&quot;;          resultContainer.innerHTML = &quot;&quot;; // 清空结果容器内容        &#125;      &#125;    &#125;);  &#125;  // 添加全局点击事件监听器  document.addEventListener(&quot;click&quot;, function (event) &#123;    handleClickOutsideSearch(event);  &#125;);  // 新增：搜索功能实现  let searchData = []; // 全局变量存储搜索数据  // 页面加载完成后获取搜索数据  document.addEventListener(&quot;DOMContentLoaded&quot;, function () &#123;    fetch(&quot;&lt;%- config.root %&gt;search.xml&quot;)      .then((res) =&gt; res.text())      .then((xmlText) =&gt; &#123;        const parser = new DOMParser();        const xml = parser.parseFromString(xmlText, &quot;text/xml&quot;);        const entries = xml.getElementsByTagName(&quot;entry&quot;);        for (let entry of entries) &#123;          searchData.push(&#123;            title: entry.getElementsByTagName(&quot;title&quot;)[0]?.textContent || &quot;&quot;,            content:              entry.getElementsByTagName(&quot;content&quot;)[0]?.textContent || &quot;&quot;,            url: entry.getElementsByTagName(&quot;url&quot;)[0]?.textContent || &quot;&quot;,          &#125;);        &#125;      &#125;)      .catch((err) =&gt; &#123;        console.error(&quot;Failed to load search data:&quot;, err);      &#125;);  &#125;);  // 新增：导航搜索方法  function navSearch(inputElement) &#123;    const keyword = inputElement.value.trim().toLowerCase();    // 查找对应的搜索结果容器    let resultContainer;    if (inputElement.id === &quot;nav-search-input-desktop&quot;) &#123;      // 桌面端      resultContainer = document.getElementById(&quot;nav-search-result-desktop&quot;);    &#125; else if (inputElement.id === &quot;nav-search-input-mobile&quot;) &#123;      // 移动端      resultContainer =        inputElement.parentNode.querySelector(&quot;.nav-search-result&quot;);    &#125;    if (!resultContainer) return;    resultContainer.innerHTML = &quot;&quot;;    if (!keyword) &#123;      resultContainer.style.display = &quot;none&quot;;      return;    &#125;    // 显示结果容器    resultContainer.style.display = &quot;block&quot;;    // 过滤搜索数据    const results = searchData.filter(      (data) =&gt;        (data.title &amp;&amp; data.title.toLowerCase().includes(keyword)) ||        (data.content &amp;&amp; data.content.toLowerCase().includes(keyword))    );    if (results.length === 0) &#123;      resultContainer.innerHTML =        &#x27;&lt;p class=&quot;no-result&quot;&gt;没有结果哟，换个关键词试试吧&lt;/p&gt;&#x27;;      return;    &#125;    // 限制显示结果数量    const maxResults = 10;    const limitedResults = results.slice(0, maxResults);    // 构建结果HTML    const html = limitedResults      .map((item) =&gt; &#123;        // 提取包含关键字的内容片段        let contentSnippet = &quot;&quot;;        if (item.content) &#123;          // 找到包含关键字的内容片段          const contentLower = item.content.toLowerCase();          const keywordIndex = contentLower.indexOf(keyword);          // 提取关键字前后的内容          const start = Math.max(0, keywordIndex - 3 * keyword.length);          const end = Math.min(            item.content.length,            keywordIndex + 3 * keyword.length          );          contentSnippet = item.content.substring(start, end);        // 高亮关键字      const keywordRegex = new RegExp(`($&#123;keyword.replace(/[.*+?^$&#123;&#125;()|[\]\\]/g, &#x27;\\$&amp;&#x27;)&#125;)`, &#x27;gi&#x27;);      contentSnippet = contentSnippet.replace(        keywordRegex,        &quot;&lt;mark&gt;$1&lt;/mark&gt;&quot;      );        &#125;        return `&lt;div class=&quot;search-result-item&quot;&gt;  &lt;a href=&quot;$&#123;item.url&#125;&quot;&gt;    &lt;div&gt;标题：$&#123;item.title&#125;&lt;/div&gt;    &lt;div&gt;内容：$&#123;contentSnippet&#125;&lt;/div&gt;  &lt;/a&gt;&lt;/div&gt;`;      &#125;)      .join(&quot;&quot;);    resultContainer.innerHTML = html;  &#125;&lt;/script&gt;&lt;style&gt;  /* 手机端使用flexbox布局搜索容器 */  .mobile-container &#123;    display: flex;    align-items: center;    flex-direction: row;    margin-bottom: 10px;    margin-left: 10px;    flex-grow: 1;    max-width: calc(100% - 40px);  &#125;  .search-result-item &#123;  border: 1px solid #ddd; /* 边框 */  margin: 4px 0; /* 外层间距 */  padding: 0; /* 无内边距 */  background: #fff; /* 背景色 */&#125;.search-result-item a &#123;  display: block;  text-decoration: none;  color: inherit;&#125;.search-result-item div &#123;  padding: 3px 8px; /* 紧凑的内边距 */  margin: 0; /* 无外边距 */  line-height: 1.3; /* 紧凑的行高 */  word-wrap: break-word; /* 允许长单词换行 */  white-space: normal; /* 允许正常换行 */&#125;.search-result-item div:first-child &#123;  border-bottom: 1px solid #eee; /* 标题和内容之间的分隔线 */&#125;&lt;/style&gt;

6.实现效果
点击图标展示搜索框
实时匹配文章标题&#x2F;内容
结果以卡片形式展示
黑色模式样式自动选择
点击空白地方隐藏结果 + 清空文本
移动端页面适配

7. 新生成并运行 Hexo需要通过hexo g生成本地数据库
hexo cleanhexo ghexo s

]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>博客功能</tag>
      </tags>
  </entry>
  <entry>
    <title>改良代码块，过长则滚动展示</title>
    <url>/2025/09/21/%E6%94%B9%E8%89%AF%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%8C%E8%BF%87%E9%95%BF%E5%88%99%E6%BB%9A%E5%8A%A8%E5%B1%95%E7%A4%BA/</url>
    <content><![CDATA[在/themes/Chic/source/css/style.styl文件中添加如下
// 代码块滚动功能：限制高度并显示滚动条.highlight  // 核心：限制最大高度，超出部分滚动  max-height: 400px !important  overflow-y: auto !important  // 垂直滚动  overflow-x: auto !important  // 水平滚动（防止代码过长溢出）  white-space: pre !important  // 保留代码格式，不自动换行  height: auto !important      // 避免固定高度覆盖滚动逻辑  // 优化代码块内边距和视觉效果（可选，根据主题调整）  padding: 15px !important  border-radius: 6px !important// 暗色模式适配（如果主题支持暗色模式）.dark-theme  .highlight    background-color: #1e1e1e !important  // 暗色背景    border: 1px solid #333 !important     // 暗色边框// 响应式适配：移动端降低最大高度@media (max-width: 768px)  .highlight    max-height: 300px !important  // 手机端显示更少内容，避免占满屏幕

搭配改善在黑暗模式中的代码背景显示以及滚动条视觉优化的代码/themes/Chic/source/css/custom.css
pre,code,pre code,.highlight &#123;    background: inherit !important;    color: inherit !important;    box-shadow: none !important;    border: none !important;  &#125;body.dark-theme pre,body.dark-theme code,body.dark-theme .highlight &#123;    background: #0d1117 !important;  /* 暗色背景 */    color: #c9d1d9 !important;       /* 暗色文字 */    box-shadow: none !important;    border: none !important;&#125;body.dark-theme pre::-webkit-scrollbar-track,body.dark-theme code::-webkit-scrollbar-track &#123;    background: #0d1117 !important;  /* 修复滚动条白边 */&#125;
]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>博客功能</tag>
      </tags>
  </entry>
  <entry>
    <title>添加网站统计功能</title>
    <url>/2025/09/24/%E6%B7%BB%E5%8A%A0%E7%BD%91%E7%AB%99%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[
使用umami来统计网站数据

打开https://us.umami.is/
注册

用户信息随便填
填好网站名字、域名
数据保存到美国就行
然后将提供的js代码复制到自己的代码中

我把js代码复制到\themes\Chic\layout\layout.ejs中
&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&lt;%= config.language %&gt;&quot;&gt;&lt;head&gt;    &lt;%- partial(&#x27;_partial/head&#x27;,&#123;cache: true&#125;) %&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;        // this function is used to check current theme before page loaded.        (() =&gt; &#123;            const pagebody = document.getElementsByTagName(&#x27;body&#x27;)[0]            function setTheme(status) &#123;                if (status === &#x27;dark&#x27;) &#123;                    window.sessionStorage.theme = &#x27;dark&#x27;                    pagebody.classList.add(&#x27;dark-theme&#x27;);                &#125; else if (status === &#x27;light&#x27;) &#123;                    window.sessionStorage.theme = &#x27;light&#x27;                    pagebody.classList.remove(&#x27;dark-theme&#x27;);                &#125;            &#125;;            setTheme(window.sessionStorage.theme)        &#125;)();    &lt;/script&gt;    &lt;div class=&quot;wrapper&quot;&gt;        &lt;%- partial(&#x27;_partial/header&#x27;,&#123;cache: true&#125;) %&gt;            &lt;div class=&quot;main&quot;&gt;                &lt;%- body %&gt;            &lt;/div&gt;            &lt;%- partial(&#x27;_partial/footer&#x27;,&#123;cache: true&#125;) %&gt;    &lt;/div&gt;&lt;/body&gt;&lt;!-- umami 填入自己的 --&gt;&lt;script defer src=&quot;https://cloud.umami.is/script.js&quot; data-website-id=&quot;填入自己的&quot;&gt;&lt;/script&gt;&lt;/html&gt;

接着，在打开官网，找到自己的网站，点击edit。

然后复制这个链接

为了实现 umami 统计页面的反向代理而不改变 URL
我们可以创建一个Hexo页面来实现反向代理。
在\source\tongji\index.md中添加

然后在\themes\Chic_config.yml中添加这个页面的链接
# navigatior itemsnav:  归档: /archives  分类: /category  标签: /tag  时间线: /timeLine  网站统计: /tongji #新增  关于: /about

然后就大功告成。
]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>博客功能</tag>
        <tag>umami</tag>
      </tags>
  </entry>
  <entry>
    <title>idea的git菜单详解</title>
    <url>/2025/09/20/Git/00-idea%E6%93%8D%E4%BD%9Cgit/</url>
    <content><![CDATA[
常见指令
IDEA中的git菜单选项详解
以下是对该 Git 相关菜单中各选项的详细解释（以常见 IDE 如 IntelliJ IDEA 的 Git 集成为例）：
1. 提交 (I)…（Ctrl+K）
功能：将本地工作区的修改提交到本地 Git 仓库。
操作：点击后弹出 “提交” 窗口，可选择要提交的文件、填写提交信息（如功能更新、问题修复的描述），最终在本地仓库生成一条新的提交记录（但不影响远程仓库）。

2. 推送…（Ctrl+Shift+K）
功能：将本地仓库的提交推送到远程仓库（如 GitHub、GitLab 等）。
场景：本地多次commit后，通过 “推送” 一次性把这些提交同步到远程，远程仓库会完整保留本地的多条提交记录（每条提交的哈希、信息、时间都会记录）。

3. 更新项目 (U)…（Ctrl+T）
功能：拉取远程仓库的最新更新，并自动合并到本地当前分支（相当于 “拉取 + 合并” 的组合操作）。
作用：确保本地代码与远程仓库的最新状态同步，常用于多人协作时更新他人的提交。

4. 拉取…
功能：从远程仓库拉取最新提交到本地仓库，但不自动合并到当前工作分支。
特点：仅更新本地的 “远程分支引用”，如需合并到当前工作分支，需后续手动执行 “合并” 操作（或用 “更新项目”）。

5. 提取
功能：类似git fetch，从远程仓库获取提交对象、分支信息等，但完全不影响本地工作分支（更偏向 “底层数据同步”，一般用于精细控制或调试，普通开发更常用 “拉取” 或 “更新项目”）。

6. 合并…
功能：将指定分支的提交合并到当前分支。
场景：比如在feature分支开发后，要把master分支的最新代码合并进来，或把feature分支合并到master准备发布。合并时会自动处理（或提示解决）冲突。

7. 变基…
功能：执行git rebase操作，将当前分支的提交 “变基” 到目标分支的最新提交上，使提交历史更线性整洁。
对比 “合并”：合并会产生 “合并提交”，而变基会重写提交历史（把当前分支的提交 “接” 在目标分支最新提交之后），更适合多人协作时保持分支历史清晰。
git多次提交到本地仓库,然后一次性提交到远程仓库,远程仓库会记录到多次提交要消除历史提交，只保留合并后的单一提交记录，可以使用变基

8. 分支 (B)…（Ctrl+Shift+）
功能：分支的综合管理，包括查看所有分支、切换分支、删除分支等。
操作：点击后可浏览本地 &#x2F; 远程分支列表，快速切换工作分支（如从master切到feature/login）。

9. 新建分支…
功能：基于当前分支或指定提交，创建一个新的分支。
场景：开发新功能时，从master分支新建feature/xxx分支，实现 “分支隔离开发”。

10. 新建标记…
功能：创建 Git标签（Tag），用于标记重要版本（如发布版本v1.0.0）。
作用：标签是 “不可变的提交引用”，方便后续快速定位到某个版本（如回退到发布版本、生成版本包）。

11. 重置 HEAD…
功能：重置HEAD指针的位置（HEAD是当前分支的 “当前提交” 引用），用于撤销提交。
选项：
--soft：保留修改到 “暂存区”（可重新提交）；
--mixed（默认）：保留修改到 “工作区”（未暂存，需重新添加）；
--hard：直接丢弃修改（慎用，会丢失未提交的变更）。



12. 显示 Git 日志
功能：查看当前分支的提交历史，包括每个提交的哈希值、作者、时间、提交信息等。
作用：用于追溯代码变更记录（如谁在什么时候改了哪部分代码）。

13. 补丁文件
功能：生成 &#x2F; 应用 ** 补丁（Patch）** 文件，将提交的变更导出为文本文件，或从补丁文件导入变更。
场景：无直接远程连接时，通过补丁分享代码变更（如给第三方提交代码时，先导出补丁再发送）。

14. 未提交的更改 (U)
功能：查看工作区中尚未提交的修改（包括新增、修改、删除的文件）。
作用：提交前确认变更内容，避免误提交无关文件。

15. 选定目录
功能：对指定目录执行 Git 操作（如仅提交该目录下的修改、查看该目录的版本历史）。
场景：大型项目中，聚焦某个模块的变更管理。

16. GitHub
功能：与GitHub 平台集成的操作（如登录 GitHub 账号、创建远程仓库、将本地仓库关联到 GitHub 等）。
作用：简化与 GitHub 的交互（如一键 “推送到 GitHub”）。

17. 管理远程…
功能：配置远程仓库的信息（如添加、删除、修改远程仓库的 URL）。
示例：本地仓库关联远程时，可通过这里设置origin的地址为https://github.com/xxx/repo.git。

18. 克隆…
功能：从远程仓库克隆一个完整的仓库到本地（包括所有分支、提交历史）。
场景：首次获取他人 &#x2F; 团队的项目时使用。

19. VCS 操作弹出窗口…（Alt+）
功能：打开综合 VCS 操作面板，聚合更多 Git（或其他版本控制）的精细操作，方便快速访问。

这些选项覆盖了 Git“本地提交、远程同步、分支管理、版本追溯” 等核心流程，帮助开发者在 IDE 中高效完成版本控制。
Git 提交历史右键菜单
以下是对该 Git 提交历史右键菜单各选项的详细解释（基于 IDE 如 IntelliJ IDEA 的 Git 集成）：
1. 复制修订号（Ctrl+Alt+Shift+C）
作用：复制当前提交的哈希值（Git 提交的唯一标识，形如 a1b2c3...）。
场景：需在命令行引用该提交（如 git show &lt;哈希&gt;）、分享特定提交时，快速获取标识。

2. 创建补丁…
作用：将当前提交的代码变更导出为「补丁文件（.patch）」。
场景：无直接 Git 远程连接时，通过补丁文件传递代码变更（他人可执行 git apply &lt;补丁文件&gt; 应用变更）。

3. 优选（对应 git cherry-pick）
作用：将当前提交（不属于当前分支）复制到当前分支，生成新提交。
场景：把其他分支的 “单个有用提交”（如feature分支的某个修复）合并到当前分支，无需拉取整个分支。

4. 签出修订
作用：将工作区 &#x2F; 暂存区切换到当前提交的代码状态（即 “检出” 该提交）。
场景：查看历史版本代码，或基于旧提交新建分支（如 git checkout &lt;哈希&gt; -b new-branch）。

5. 在修订中显示仓库
作用：以当前提交为视角，展示仓库整体的文件结构与内容。
场景：查看该提交时仓库的完整状态（哪些文件被改 &#x2F; 增 &#x2F; 删）。

6. 与本地比较
作用：对比当前提交的代码与本地工作区的代码差异。
场景：确认本地变更与历史提交是否冲突，或查看本地对历史版本的修改。

7. 将当前分支重置到此处…
作用：把当前分支的HEAD 指针移动到当前提交，并可选择重置模式（–soft&#x2F;–mixed&#x2F;–hard
）：

--soft：仅移动HEAD，变更保留在暂存区；
--mixed（默认）：移动HEAD，暂存区重置，变更保留在工作区；
--hard：移动HEAD，暂存区 &#x2F; 工作区均重置（丢弃本地未提交变更，慎用）。


场景：回退分支到历史提交，按需保留 &#x2F; 丢弃后续变更。


8. 还原提交（对应 git revert）
作用：创建新提交，抵消当前提交的变更（不删除历史提交，而是 “反向修正”）。
场景：已推送到远程的提交需回退时，避免改写历史（不影响协作）。

9. 撤销提交…（对应 git reset 交互）
作用：回退当前分支到该提交之前，并交互选择如何处理后续变更（类似 “重置分支” 的友好界面）。

10. 编辑提交消息…（F2）
作用：修改当前提交的提交信息（commit message）。
场景：提交后发现消息写错，若未推送到远程可直接修改；已推送则需强制推送（慎用于协作分支）。

11. Fixup…（对应 git rebase -i 的 fixup）
作用：将当前提交合并到前一个提交，并丢弃当前提交的消息。
场景：修复前一个提交的小问题，无需保留 “修复提交” 的独立记录，让历史更整洁。

12. 压缩到…
作用：将当前提交合并到指定提交，可选择是否保留提交消息（比Fixup更灵活的合并）。

13. 删除提交
作用：从提交历史中移除当前提交（通常通过「交互式变基」实现）。
注意：若提交已推送到远程，删除后需强制推送，可能影响协作。

14. 从这里进行交互式变基…（对应 git rebase -i）
作用：启动交互式变基，可对 “当前提交之后的所有提交” 进行编辑（合并、拆分、改消息等）。
场景：整理提交历史（如把多个小提交合并为一个有意义的大提交），让分支历史更线性。

15. 推送此前所有提交…
作用：将当前提交及之前所有本地未推送的提交推送到远程仓库。
场景：同步本地积累的多次提交到远程。

16. 新建分支…
作用：基于当前提交创建新分支。
场景：从历史版本开始开发新功能，或保存当前提交的状态到独立分支。

17. 新建标记…（对应 git tag）
作用：为当前提交创建Git 标签（如v1.0.0），标记重要版本。
场景：标记发布版本、里程碑，方便后续快速定位。

18. 转到子提交（向左箭头）
作用：在提交历史的 “父子关系” 中，切换到当前提交的子提交（即基于当前提交后续创建的提交）。
场景：浏览提交历史的 “后续发展”。

19. 转到父提交（向右箭头）
作用：切换到当前提交的父提交（即当前提交基于哪个提交创建）。
场景：回溯提交历史的 “来源”。

20. 在 GitHub 上打开
作用：若项目托管在 GitHub，在浏览器中打开当前提交的 GitHub 网页详情。
场景：快速查看该提交在 GitHub 上的变更、讨论等信息。

这些选项覆盖了 Git“提交管理、历史编辑、分支 &#x2F; 标签操作” 等核心场景，帮助在 IDE 中高效操作版本控制。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>git详解</title>
    <url>/2025/10/11/Git/git/</url>
    <content><![CDATA[初始化设置Git的用户名和邮箱是每个仓库初始化后的必要配置（因为 Git 是分布式版本控制系统，所以需要填写用户名和邮箱作为一个标识。）
#配置全局用户名和邮箱git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;your.email@example.com&quot;

配置好的 Git 的用户名和邮箱存储在 C:\Users\账户名 目录下的 .gitconfig 文件中
可通过git config --list查看。
当然，如果配置了全局用户名和邮箱（–global参数），下面内容是单独给仓库配置局部用户名和邮箱，因此可以选填，按需选择。

# 设置用户信息git config user.name &quot;Your Name&quot;git config user.email &quot;your.email@example.com&quot;

最后可以设置凭证助手，帮助自动管理代码仓库的用户名和密码（或令牌），避免每次操作都需要手动输入。
git config --global credential.helper manager

本地仓库初始化idea中创建项目可以通过创建面板中勾选创建git仓库即可。
也可以进入到新建项目中的  顶层菜单栏–VCS–创建Git仓库。
或者通过命令方法创建(初始化)本地git仓库
# 进入项目目录cd your-project-directory#初始化git仓库git init

或克隆远程仓库
# 克隆远程仓库到本地git clone &lt;repository-url&gt;

验证仓库创建
# 查看仓库状态git status

关联远程仓库创建本地Git仓库后，会出现顶层菜单栏中的Git选项。点击Git选项后选择管理远程添加远程仓库url实现idea中管理远程仓库。
当然现在还关联不了，显示
git@gitee.com: Permission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists.

因此我们需要选定连接方式来同远程仓库进行连接。目前以下两种方式最受欢迎。

HTTPS：需要个人访问令牌。即使没有配置个人访问令牌，也是可以 git clone 的，但是 git push 的时候需要输入用户名和个人访问令牌。
SSH：需要密钥对。如果没有配置密钥对，既不能 git clone，也不能 git push。

SSH执行如下命令，生成 SSH 密钥对。
#-c的作用是给产生的密钥对加一个注释，推荐注释信息跟本台机器相关ssh-keygen -t rsa -C &quot;本机标识&quot;

生成的 SSH 密钥对存储在 C:\Users\账户名\.ssh 目录下

id_rsa  私钥
id_rsa.pub 公钥

复制公钥里的内容，可通过clip &lt; \x7e/.ssh/id_rsa.pub命令去复制。
将公钥拷贝到GitHub或Gitee上。一般在设置–安全设置–SSH公钥。
测试是否能连接上。
#GitHubssh -T git@github.com#Giteessh -T git@gitee.com

连接上会有一段问候语。
这时再点击顶层菜单栏中的Git选项–管理远程，添加远程仓库url。
此时点击 idea中的  工具窗口–Git–左边栏–虚线↙️，此时能获取远程仓库信息。
HTTPS使用HTTPS能够克隆远程仓库到本地，但是 每次fetch和push代码都需要输入账号和密码。
一样的先将远程仓库url填入到Git–管理远程
若在 IDEA 中推送代码时无需再次验证，是因为之前的凭证已经被 “缓存” 了（可能是 IDE 保存了你的登录状态，或系统 &#x2F; Git 工具已经存储了你的账号 + 密码 &#x2F; 令牌）

[!tip]
HTTPS 的本质：需要身份验证HTTPS 协议本身要求提供用户名 + 密码（或平台的 “个人访问令牌”，如 GitHub&#x2F;Gitee 的令牌） 来完成身份验证（比如git push时，需要证明你有权限操作远程仓库）。
免重复验证的核心：凭证缓存为了避免每次操作都输入账号密码，Git 支持 “凭证缓存” 机制 —— 把你的身份凭证（密码 &#x2F; 令牌）保存起来，后续自动复用：

系统级缓存：比如 Windows 的「凭据管理器」、macOS 的「钥匙串」，会存储 Git 的账号凭证；
Git 工具级缓存：可通过命令（如git config --global credential.helper store）配置本地缓存，把凭证存在项目或全局的配置文件中；
IDE 集成缓存：像 IntelliJ IDEA 这类开发工具，会和 Git 的凭证系统联动，甚至自身也会管理 Gitee&#x2F;GitHub 的登录状态（比如你在 IDE 中通过 “添加账户” 功能登录过平台，IDE 会保存这些凭证供后续 Git 操作使用）。

通过git config –list查看是否有credential.helper&#x3D;managercredential.helper=manager 表示 Git 配置了「凭证管理器」（通常是 git-credential-manager，简称 GCM）作为凭证缓存工具。
它的作用是：自动保存你通过 HTTPS 连接 Git 仓库时输入的账号、密码或令牌，并在后续操作中自动复用这些凭证，避免重复输入。
在 Windows 系统中，这个管理器通常会将凭证存储在「系统凭据管理器」中（可通过 控制面板 → 用户账户 → 凭据管理器 查看 &#x2F; 管理已缓存的 Git 凭证）；在 macOS 或 Linux 上则可能与系统钥匙串集成。

连接上后依然会有一段问候语。
此时点击 idea中的  工具窗口–Git–左边栏–虚线↙️，此时能获取远程仓库信息。
Git相关基本概念基本概念
origin：默认远程仓库。
HEAD：指向当前分支的指针。
HEAD^：上一个版本。
HEAD~4：上 4 个版本。

特殊文件
.git：Git 仓库的元数据和对象数据库。
.gitignore：忽略文件（不需要提交到仓库的文件）。
.gitattributes：指定文件属性（如换行符）。
.gitkeep：使空目录能被提交。
.gitmodules：记录子模块的信息。
.gitconfig：记录 Git 的配置信息。

Git 的四个区域
工作区（Working Directory）：你在电脑里能看到的目录。
暂存区（Stage&#x2F;Index）：一般存放在 .git 目录下的 index 文件，因此暂存区有时也叫 “索引”。
本地仓库（Repository）：工作区有隐藏目录 .git，它是 Git 的版本库（不算工作区）。
远程仓库（Remote）：托管在远程服务器上的仓库。

Git 的三种状态
已修改（Modified）：修改了文件，但未保存到暂存区。
已暂存（Staged）：把修改后的文件放到暂存区。
已提交（Committed）：把暂存区的文件提交到本地仓库。

Git指令概念
操作指令对应的中文翻译
Remote：远程仓库（托管在服务器上的 Git 仓库，如 GitHub&#x2F;Gitee 上的仓库）
fetch&#x2F;clone：获取 &#x2F; 克隆（fetch：拉取远程仓库的提交数据到本地仓库；clone：完整复制远程仓库到本地，包含所有历史记录）
Repository：本地仓库（存储版本历史的核心数据库，对应项目中的 .git 目录区域）
push：推送（将本地仓库的提交推送到远程仓库）
Index：暂存区（也叫 “索引”，是提交前的临时区域，用于准备下次提交的内容）
add：添加（将工作区的文件修改 “添加” 到暂存区，为提交做准备）
commit：提交（将暂存区的内容 “提交” 到本地仓库，生成新的版本记录）
checkout：检出&#x2F;签出（可用于切换分支，或从仓库 &#x2F; 暂存区恢复文件到工作区）
pull：拉取（相当于 fetch + merge，从远程仓库拉取数据并合并到当前分支）
workspace：工作区（本地编辑代码的目录，是能直接看到文件的 “工作目录” 区域）


添加和提交
添加一个文件到仓库
git add &lt;file&gt;

添加所有文件到仓库
git add .

提交所有暂存区的文件到仓库
git commit -m &quot;message&quot;

提交所有已修改的文件到仓库
git commit -am &quot;message&quot;


分支
查看所有本地分支（当前分支前有*；-v看远程分支，-a 看所有分支）
git branch

创建一个新分支
git branch &lt;branch-name&gt;

切换到指定分支，并更新工作区
git checkout &lt;branch-name&gt;

创建一个新分支，并切换到该分支
git checkout -b &lt;branch-name&gt;

删除一个已合并的分支
git branch -d &lt;branch-name&gt;

删除一个分支（不管是否合并）
git branch -D &lt;branch-name&gt;

给当前提交打标签（通常用于版本发布）
git tag &lt;tag-name&gt;


合并分支
合并分支（--no-ff 禁用 Fast forward 模式，保留分支历史；-ff用 Fast forward 模式，历史成直线）
git merge --no-ff -m &quot;message&quot; &lt;branch-namegit merge --ff -m &quot;message&quot; &lt;branch-name&gt;
合并 &amp; squash 所有提交到一个提交
git merge --squash &lt;branch-name&gt;


文件操作与版本回退
移动一个文件到新位置
git mv &lt;file&gt; &lt;new-file&gt;

从工作区和暂存区删除文件，并暂存删除操作
git rm &lt;file&gt;

只从暂存区删除文件（工作区文件不变）
git rm --cached &lt;file&gt;

恢复文件到之前的版本
git checkout &lt;file&gt; &lt;commit-id&gt;

创建新提交撤销指定提交（抵消后者所有变化并应用到当前分支）
git revert &lt;commit-id&gt;

重置分支HEAD 到指定提交（--hard重置工作区 + 暂存区；--soft重置暂存区；--mixed 重置工作区）
git reset --mixed &lt;commit-id&gt;

撤销暂存文件，放回工作区（git add 的反向操作）
git restore --staged &lt;file&gt;


Rebase 变基Rebase 可把本地未 push 的分叉提交历史整理成直线（多人协作时，不要对已推送到远程的分支执行 Rebase）：
git checkout &lt;dev&gt;git rebase &lt;main&gt;

撤销（Stash）
储藏工作现场（-u包含未跟踪文件；-a 包含未跟踪 + 忽略文件；&quot;message&quot; 为存储说明）
git stash -u &quot;message&quot;git stash -a &quot;message&quot;
查看所有 stash
git stash list

恢复最近一次 stash（并删除该 stash）
git stash pop

恢复指定 stash（如 stash@&#123;2&#125; 是第 3 个 stash）
git stash pop stash@&#123;2&#125;

重新应用最近一次 stash（不删除 stash）
git stash apply

删除指定 stash
git stash drop stash@&#123;2&#125;

删除所有 stash
git stash clear


查看
列出未提交的新文件 &#x2F; 修改文件
git status

查看提交历史（--oneline简化显示）
git log --oneline

查看未暂存文件的更新内容
git diff

查看两个提交之间的差异
git diff &lt;commit-id&gt; &lt;commit-id&gt;


远程仓库
添加远程仓库
git remote add &lt;remote-name&gt; &lt;remote-url&gt;

查看远程仓库（含地址等详情）
git remote -v

删除远程仓库
git remote rm &lt;remote-name&gt;


远程仓库进阶操作
重命名远程仓库
git remote rename &lt;old-name&gt; &lt;new-name&gt;

从远程仓库拉取代码
git pull &lt;remote-name&gt; &lt;branch-name&gt;

fetch 默认拉取仓库（如origin）当前分支代码并合并到本地分支
git pull

拉取并 Rebase 远程最新代码（保证提交历史线性）
git pull --rebase

推送代码到远程仓库
git push &lt;remote-name&gt; &lt;branch-name&gt;

获取所有远程分支
git fetch &lt;remote-name&gt;

查看远程分支
git branch -r

fetch 某一个特定的远程分支
git fetch &lt;remote-name&gt; &lt;branch-name&gt;


IDEA实操Git合并和变基合并将分支 A 合并 到分支 B（git merge）
目标：把分支 A 的所有更改整合到分支 B，并保留合并记录。
IDEA 图形化操作：
右下角点击当前分支 → 切换到分支 B。
顶部菜单 Git → Merge Changes，在弹出窗口选择分支 A，点击 Merge。
若有冲突，IDEA 会提示 “Resolve Conflicts”，点击进入合并工具：
左侧为分支 B 的内容，右侧为分支 A 的内容，中间为合并结果。
点击冲突行两侧的箭头选择保留内容，或直接编辑中间区域。
完成后点击 Apply，再点击 Commit 完成合并。



变基将分支 A 变基 到分支 B（git rebase）
目标：把分支 A 的提交 “重新基于” 分支 B 的最新提交，形成线性历史（仅推荐个人本地分支使用）。
IDEA 图形化操作：
右下角切换到分支 A。
顶部菜单 Git → Rebase，在弹出窗口选择 “目标分支 B”，点击 Rebase（变基）。
若有冲突，IDEA 会提示 “Resolve conflicts”，处理方式同合并冲突。
解决后点击 Continue Rebase，直到所有提交应用完成。

对比


操作
核心步骤差异
最终历史特点
适用场景



合并（Merge）
切换到目标分支 → 合并源分支 → 可能生成合并提交
保留分支分叉，可见合并点
公共分支（如 main）、需保留合并记录


变基（Rebase）
切换到源分支 → 基于目标分支变基 → 解决冲突后继续
历史线性，无合并提交
个人本地分支（未推送到远程）


注意：变基会改写历史，绝对不要对已推送到远程并被他人使用的分支执行变基，否则会导致团队代码冲突。
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>命令行基础指令总结</title>
    <url>/2025/10/11/Linux/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[
命令行基础指令总结1. ls：列出目录（文件夹）中的文件
作用：查看当前 &#x2F; 指定目录下的文件 &#x2F; 目录列表。
常用选项：
-l：以每行一个的详细格式列出（l 代表 long）。
-a：列出所有文件（包括以 . 开头的隐藏文件，a 代表 all）。
-S：按文件大小排序列出（S 代表 Size）。
-t：按修改时间排序列出（t 代表 time modified）。
-r：倒序列出文件（r 代表 reverse）。


选项叠加示例：ls -ltr → 每行显示一个文件，按修改日期倒序排列。

2. mkdir：新建目录（文件夹）
作用：创建新的目录（如 mkdir new_folder 可创建名为 new_folder 的目录）。

3. cd：切换目录（文件夹）
作用：改变当前工作目录。
常用用法：
cd ~：跳转到当前用户的home 目录。
cd ../..：跳转到当前目录的上两级父目录（../ 表示 “上一级目录”，叠加表示多级跳转）。



4. rm：删除文件或目录
作用：移除文件或目录。
常用选项：
-i：删除前提示确认（输入 y 确认删除，n 取消）。
-r：递归删除目录（包括目录内所有文件，r 可理解为 recursive，即 “递归”）。
-f：强制删除（不提示，直接执行，f 代表 force）。


选项叠加示例：rm -rf [目录名] → 直接强制删除指定目录（含其内部所有内容，谨慎使用）。

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>老婆21岁生日快乐</title>
    <url>/2025/10/12/%E8%80%81%E5%A9%8621%E5%B2%81%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90/</url>
    <content><![CDATA[老婆生日快乐

臭老婆今天是你的生日，我没搞什么特别复杂的花样，就想跟你说：往后的日子，还想继续跟你一起 “臭气相投”
我的臭老婆，愿你新的一岁，能少点烦恼，多点开心；愿你想要的都能慢慢实现，而我能一直在你身边，陪你吃遍想吃的，玩遍想玩的，把每一个生日都过成我们专属的小美好。
生日快乐呀，我最最可爱的臭老婆！

]]></content>
      <categories>
        <category>房间门</category>
      </categories>
      <tags>
        <tag>开心</tag>
        <tag>老婆生日</tag>
      </tags>
  </entry>
  <entry>
    <title>欢迎来到老江湖的世界</title>
    <url>/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E8%80%81%E6%B1%9F%E6%B9%96%E7%9A%84%E4%B8%96%E7%95%8C/index.html</url>
    <content><![CDATA[老江湖进房间门，这故事得从去年说起，说来话长，我们长话短说…
]]></content>
  </entry>
  <entry>
    <title>tag</title>
    <url>/tag/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>category</title>
    <url>/category/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>关于我</title>
    <url>/about/index.html</url>
    <content><![CDATA[我有个可爱的女友，希望我们能够长长久久。
❤️ 老江湖爱房间门。
博客的由来老江湖拿来记录学习情况，以及分享老江湖和房间门的趣事。
]]></content>
  </entry>
  <entry>
    <title>时间线</title>
    <url>/timeLine/index.html</url>
    <content><![CDATA[2024.10.5🎉老江湖和房间门确认关系的日子。
2024.10.12老江湖给房间门过的第一个生日🎂
2024.10.21房间门给老江湖过的第一个生日🎂
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/js/code-copy.js</url>
    <content><![CDATA[document.addEventListener('DOMContentLoaded', () => {
  document.querySelectorAll('figure.highlight').forEach((figure) => {
    if (figure.querySelector('.copy-btn')) return;

    const copyBtn = document.createElement('button');
    copyBtn.className = 'copy-btn';
    copyBtn.title = '复制';

    // 缩小后的复制图标（14*15）
    const copyIcon = `
      
        
      
    `;

    // 成功后显示的勾（14*15）
    const checkIcon = `
      
        
      
    `;

    copyBtn.innerHTML = copyIcon;

    // 按钮样式（浅灰底、缩小）
    Object.assign(copyBtn.style, {
      position: 'absolute',
      top: '8px',
      right: '8px',
      padding: '4px',
      background: '#aaa', 
      border: 'none',
      borderRadius: '4px',
      cursor: 'pointer', 
      opacity: '0.85',
      zIndex: 1000,
      transition: 'opacity 0.2s ease',
      boxShadow: '0 1px 3px rgba(0, 0, 0, 0.15)'
    });

    copyBtn.addEventListener('mouseover', () => copyBtn.style.opacity = '1');
    copyBtn.addEventListener('mouseout', () => copyBtn.style.opacity = '0.85');

    copyBtn.addEventListener('click', () => {
      const code = figure.querySelector('td.code');
      const text = code ? code.innerText : '';
      navigator.clipboard.writeText(text).then(() => {
        copyBtn.innerHTML = checkIcon;
        setTimeout(() => {
          copyBtn.innerHTML = copyIcon;
        }, 1000);
      });
    });

    figure.style.position = 'relative';
    figure.appendChild(copyBtn);
  });
});
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/tongji/index.html</url>
    <content><![CDATA[


]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/%E7%85%A7%E7%89%87%E5%A2%99/index.html</url>
    <content><![CDATA[

  
    
    
    照片墙展示
    
    
    
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              primary: "#3B82F6",
              secondary: "#6B7280",
              accent: "#EC4899",
            },
            fontFamily: {
              sans: ["Inter", "system-ui", "sans-serif"],
            },
          },
        },
      };
    
    
      @layer utilities {
        .content-auto {
          content-visibility: auto;
        }
        .masonry-grid {
          column-count: 1;
          column-gap: 1rem;
        }
        @screen md {
          .masonry-grid {
            column-count: 2;
          }
        }
        @screen lg {
          .masonry-grid {
            column-count: 3;
          }
        }
        @screen xl {
          .masonry-grid {
            column-count: 4;
          }
        }
        .masonry-item {
          break-inside: avoid;
          margin-bottom: 1rem;
        }
        .glass-effect {
          backdrop-filter: blur(8px);
          background-color: rgba(255, 255, 255, 0.15);
        }
        .photo-hover {
          transition: transform 0.3s ease, filter 0.3s ease;
        }
        .photo-info {
          opacity: 0;
          transform: translateY(10px);
          transition: opacity 0.3s ease, transform 0.3s ease;
        }
        .photo-container:hover .photo-hover {
          filter: brightness(0.7);
        }
        .photo-container:hover .photo-info {
          opacity: 1;
          transform: translateY(0);
        }
      }
    
  
  
    
    
      
      
    
    
    
      
      
        
      
      
      
        
      
      
      
        
        
      
    

    
    
      
        老江湖的照片墙
      
      
        记录生活中的美好瞬间，每一张照片都有一个故事
      
    

    

    
    
      
     
            
            
                
                    
                    
                        
                            广州塔和房间门
                            同房间门去广州拍的
                        
                    
                
            
            

    
    
      
      
        
          
        
        
          
            
          
          
            
            
              
              •
              
            
            
              
            
          
        
      
    

        
    
      
      
        
          
            
          
          背景音乐
          是否开启背景音乐以获得更好的浏览体验？ 开启后可以在左上角关闭音乐
          
            
              不开启
            
            
              开启音乐
            
          
        
      
    

    
      // 照片数据
      const photos = [
    {
        id: 0,
        src: "https://oss.itbaima.cn/hub/928/image-20250926zxxyud4i0.jpeg",
        alt: "同房间门去广州拍的",
        title: "广州塔和房间门",
        date: "2024年11月8日",
        location: "广州",
        description: "我和房间门在校运会的三天假期跑去广州玩，在前往广州塔的路上，经过这个公园，我觉得很好的景，就让房间门站那，然后我就拍了。"
    }
];


      // DOM 元素
      const modal = document.getElementById("photoModal");
      const modalContent = document.getElementById("modalContent");
      const modalImage = document.getElementById("modalImage");
      const modalTitle = document.getElementById("modalTitle");
      const modalDate = document.getElementById("modalDate");
      const modalLocation = document.getElementById("modalLocation");
      const modalDescription = document.getElementById("modalDescription");
      const closeModal = document.getElementById("closeModal");
      const modalOverlay = document.getElementById("modalOverlay");
      const photoContainers = document.querySelectorAll(".photo-container");
      const musicToggle = document.getElementById("musicToggle");
      const backgroundMusic = document.getElementById("backgroundMusic");

      // 打开模态框
      function openModal(photo) {
        modalImage.src = photo.src;
        modalImage.alt = photo.alt;
        modalTitle.textContent = photo.title;
        modalDate.innerHTML = `${photo.date}`;
        modalLocation.innerHTML = `${photo.location}`;
        modalDescription.textContent = photo.description;

        modal.classList.remove("opacity-0", "pointer-events-none");
        setTimeout(() => {
          modalContent.classList.remove("scale-95");
          modalContent.classList.add("scale-100");
        }, 10);

        document.body.style.overflow = "hidden";
      }

      // 关闭模态框
      function closeModalFunc() {
        modalContent.classList.remove("scale-100");
        modalContent.classList.add("scale-95");
        setTimeout(() => {
          modal.classList.add("opacity-0", "pointer-events-none");
          document.body.style.overflow = "";
        }, 300);
      }

      // 照片点击事件
      photoContainers.forEach((container) => {
        container.addEventListener("click", () => {
          const index = parseInt(container.dataset.index);
          openModal(photos[index]);
        });

        // 鼠标移动视差效果
        container.addEventListener("mousemove", (e) => {
          const rect = container.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;

          const xPos = (x / rect.width - 0.5) * 10;
          const yPos = (y / rect.height - 0.5) * 10;

          const img = container.querySelector("img");
          img.style.transform = `translate(${xPos}px, ${yPos}px)`;
        });

        // 鼠标离开时恢复
        container.addEventListener("mouseleave", () => {
          const img = container.querySelector("img");
          img.style.transform = "translate(0, 0)";
        });
      });

      // 关闭模态框事件
      closeModal.addEventListener("click", closeModalFunc);
      modalOverlay.addEventListener("click", closeModalFunc);

      // 音乐控制
      musicToggle.addEventListener("click", () => {
        if (backgroundMusic.paused) {
          backgroundMusic.play().catch((e) => {
            console.log("播放失败:", e);
            alert("自动播放被浏览器阻止，请手动点击播放按钮");
          });
          musicToggle.innerHTML = '';
        } else {
          backgroundMusic.pause();
          musicToggle.innerHTML = '';
        }
      });

 // 键盘ESC关闭模态框
      document.addEventListener("keydown", (e) => {
        if (
          e.key === "Escape" &&
          !modal.classList.contains("pointer-events-none")
        ) {
          closeModalFunc();
        }
      });

      // 音乐提示模态框
      const musicModal = document.getElementById("musicModal");
      const confirmMusic = document.getElementById("confirmMusic");
      const cancelMusic = document.getElementById("cancelMusic");

      // 页面加载完成后显示音乐提示
      window.addEventListener('load', () => {
        // 添加一个微小的延迟以确保页面完全加载
        setTimeout(() => {
          musicModal.classList.remove("opacity-0", "pointer-events-none");
          const musicModalContent = musicModal.querySelector('div.relative');
          setTimeout(() => {
            musicModalContent.classList.remove("scale-95");
            musicModalContent.classList.add("scale-100");
          }, 10);
        }, 1000);
      });

      // 确认播放音乐
      confirmMusic.addEventListener("click", () => {
        closeMusicModal();
        backgroundMusic.play().catch((e) => {
          console.log("播放失败:", e);
          // 播放失败时更新按钮状态
          musicToggle.innerHTML = '';
        });
        musicToggle.innerHTML = '';
      });

      // 取消播放音乐
      cancelMusic.addEventListener("click", closeMusicModal);

      // 关闭音乐提示模态框
      function closeMusicModal() {
        const musicModalContent = musicModal.querySelector('div.relative');
        musicModalContent.classList.remove("scale-100");
        musicModalContent.classList.add("scale-95");
        setTimeout(() => {
          musicModal.classList.add("opacity-0", "pointer-events-none");
        }, 300);
      }

    
  

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/manager/photo-manager.html</url>
    <content><![CDATA[


    
    
    照片管理器
    
    
    
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3B82F6',
                        secondary: '#6B7280',
                        accent: '#EC4899',
                    }
                }
            }
        }
    
    
        .glass-effect {
            backdrop-filter: blur(8px);
            background-color: rgba(255, 255, 255, 0.15);
        }
    


    
        
            照片管理器
            添加和管理您的照片墙内容
        

        
            
            
                添加新照片
                
                    
                        照片URL
                        
                    
                    
                        照片描述 (alt)
                        
                    
                    
                        照片标题
                        
                    
                    
                        拍摄日期
                        
                    
                    
                        拍摄地点
                        
                    
                    
                        详细描述
                        
                    
                    
                        
                            重置
                        
                        
                            添加照片
                        
                    
                
            

            
            
                照片列表
                
                    暂无照片
                
                
                生成代码
                
                    
                        生成照片墙代码
                    
                    
                    
                        复制代码
                    
                
            
        
    

    
        // 存储照片的数组
        let photos = [];

        // DOM 元素
        const photoForm = document.getElementById('photoForm');
        const photoList = document.getElementById('photoList');
        const generateCodeBtn = document.getElementById('generateCode');
        const generatedCode = document.getElementById('generatedCode');
        const copyCodeBtn = document.getElementById('copyCode');

        // 添加照片表单提交处理
        photoForm.addEventListener('submit', function(e) {
            e.preventDefault();
            
            // 获取表单数据
            const newPhoto = {
                id: Date.now(), // 使用时间戳作为唯一ID
                src: document.getElementById('photoSrc').value,
                alt: document.getElementById('photoAlt').value,
                title: document.getElementById('photoTitle').value,
                date: document.getElementById('photoDate').value,
                location: document.getElementById('photoLocation').value,
                description: document.getElementById('photoDescription').value
            };
            
            // 添加到照片数组
            photos.push(newPhoto);
            
            // 更新照片列表显示
            updatePhotoList();
            
            // 重置表单
            photoForm.reset();
            
            alert('照片已添加！');
        });

        // 更新照片列表显示
        function updatePhotoList() {
            if (photos.length === 0) {
                photoList.innerHTML = '暂无照片';
                return;
            }
            
            photoList.innerHTML = photos.map(photo => `
                
                    
                    
                        ${photo.title}
                        ${photo.alt}
                        
                            
                                 删除
                            
                        
                    
                
            `).join('');
        }

        // 删除照片
        function removePhoto(id) {
            if (confirm('确定要删除这张照片吗？')) {
                photos = photos.filter(photo => photo.id !== id);
                updatePhotoList();
            }
        }

        // 生成照片墙代码
        generateCodeBtn.addEventListener('click', function() {
            if (photos.length === 0) {
                alert('请先添加一些照片！');
                return;
            }
            
            // 生成照片数据部分
            const photoDataCode = `const photos = [\n${photos.map((photo, index) => `    {
        id: ${index},
        src: "${photo.src}",
        alt: "${photo.alt}",
        title: "${photo.title}",
        date: "${photo.date}",
        location: "${photo.location}",
        description: "${photo.description}"
    }`).join(',\n')}\n];`;
            
            // 生成照片HTML部分
            const photoHTMLCode = photos.map((photo, index) => `            
            
                
                    
                    
                        
                            ${photo.title}
                            ${photo.alt}
                        
                    
                
            `).join('\n\n');
            
            // 组合完整代码
            const fullCode = `// 照片数据\n${photoDataCode}\n\n// 照片墙HTML\n${photoHTMLCode}`;
            
            // 显示生成的代码
            generatedCode.value = fullCode;
            generatedCode.classList.remove('hidden');
            copyCodeBtn.classList.remove('hidden');
        });

        // 复制代码到剪贴板
        copyCodeBtn.addEventListener('click', function() {
            generatedCode.select();
            document.execCommand('copy');
            alert('代码已复制到剪贴板！');
        });
    

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/Timer/index.html</url>
    <content><![CDATA[


    
    
    任务计时器与待办事项
    
    
    
    
   
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3B82F6',
                        secondary: '#10B981',
                        danger: '#EF4444',
                        dark: '#1E293B',
                        light: '#F8FAFC'
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                    },
                }
            },
            darkMode: 'class'
        }
    
 
    @layer utilities {
        .content-auto {
            content-visibility: auto;
        }
        .progress-animation {
            transition: width 1s linear;
        }
        .card-shadow {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .menu-shadow {
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        }
        .btn-hover {
            @apply transition-all duration-300 hover:scale-105 active:scale-95;
        }
        .bg-blur {
            backdrop-filter: blur(8px);
        }
        .todo-complete {
            @apply line-through text-gray-500 dark:text-gray-400;
        }
        #timer-container {
            @apply text-dark dark:text-light;
        }
        #timer-display {
            @apply text-dark dark:text-light;
        }
        #current-task-name {
            @apply text-dark dark:text-light;
        }
        .task-item-text {
            @apply text-dark dark:text-light;
        }
        .todo-item-text {
            @apply text-dark dark:text-light;
        }
        .panel-text {
            @apply text-dark dark:text-light;
        }
        /* 添加触摸设备支持 */
        .touch-device {
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }
    }



    
    
        
    

    
    
        
        
            
                任务管理器
            
            
                
                    
                
                
                    
                    
                
                
                    
                
                
                    
                
            
        

        
        
            
                设置
            
            
                
                
                    背景设置
                    
                        
                            
                            选择本地图片
                            
                        
                        
                            
                            恢复默认背景
                        
                    
                

                
                
                    音效设置
                    
                        
                            
                            启用互动音效
                        
                        
                            
                            
                        
                    
                

                
                
                    数据清理
                    
                        
                            
                                
                                清除计时任务
                            
                            
                        
                        
                            
                                
                                清除待办事项
                            
                            
                        
                        
                            
                                
                                清除背景缓存
                            
                            
                        
                        
                            
                                
                                清除设置数据
                            
                            
                        
                        
                            
                                
                                清除所有数据
                            
                            
                        
                    
                
            
        

        
        
            
            
                
                    
                        未选择任务
                        
                        
                            
                                
                            
                        
                        
                        00:00:00
                        
                        
                            
                                
                                开始
                            
                            
                                
                                暂停
                            
                            
                                
                                重置
                            
                        
                    
                
            
            
            
            
                
                    
                    
                        计时任务
                        待办事项
                    
                    
                    
                    
                        
                            任务管理
                            
                                
                            
                        
                        
                        
                            
                            
                                
                                暂无任务，点击添加按钮创建任务
                            
                        
                    
                    
                    
                    
                        
                            待办事项
                            
                                
                            
                        
                        
                        
                        
                            
                                
                                
                                    
                                
                            
                        
                        
                        
                            
                            
                                
                                暂无待办事项，添加你的第一个待办
                            
                        
                    
                
            
        
    

    
    
        
            
                添加新任务
                
                    
                
            
            
            
                
                
                
                    任务名称
                    
                
                
                
                    任务时长
                    
                        
                            
                            小时
                        
                        
                            
                            分钟
                        
                        
                            
                            秒
                        
                    
                
                
                
                    取消
                    保存
                
            
        
    

    
    
        
            确认操作
            您确定要执行此操作吗？
            
            
                取消
                确认
            
        
    

    
    
        
            
                操作说明
                
                    
                
            
            
            
                
                    计时任务
                    
                        点击"+"按钮添加新计时任务
                        可以设置任务的小时、分钟和秒数
                        点击任务项选择该任务进行计时
                        选择任务后，点击"开始"按钮启动计时器
                        计时器运行中可以点击"暂停"暂停计时，点击"重置"重新开始
                    
                
                
                
                    待办事项
                    
                        点击"待办事项"标签切换到待办事项面板
                        在输入框中输入内容并点击"+"或按回车添加待办事项
                        点击待办事项前的复选框标记为已完成
                        点击删除图标可以删除待办事项
                        已完成的待办事项会显示删除线
                    
                
                
                
                    设置功能
                    
                        点击菜单按钮（三条横线）打开设置面板
                        可以上传本地图片作为背景，也可以恢复默认背景
                        可以开启或关闭互动音效
                        可以清理各类数据（计时任务、待办事项、设置数据或全部数据）
                    
                
                
                
                    其他功能
                    
                        点击月亮/太阳图标切换深色/浅色模式
                        所有数据保存在本地，刷新页面不会丢失
                        计时器支持后台运行，即使不打开页面也会继续计时
                    
                
            
        
    

 
    
        
    
    
        
    
    
        
    
    
        
    
    
        
    

    
         
        // 添加触摸事件支持函数
        function addTouchSupport(element, callback) {
            let touchStartTime = 0;
            
            element.addEventListener('touchstart', (e) => {
                touchStartTime = Date.now();
                // 防止页面滚动
                if (element.classList.contains('no-scroll')) {
                    e.preventDefault();
                }
            }, { passive: false });
            
            element.addEventListener('touchend', (e) => {
                const touchDuration = Date.now() - touchStartTime;
                // 只有当触摸时间少于200ms才触发点击事件，避免与滚动冲突
                if (touchDuration < 200) {
                    callback(e);
                }
            });
            
            // 保持原有的点击事件
            element.addEventListener('click', callback);
        }
        // 音效控制
        const sounds = {
            start: document.getElementById('sound-start'),
            complete: document.getElementById('sound-complete'),
            click: document.getElementById('sound-click'),
            cancel: document.getElementById('sound-cancel'),
            todo: document.getElementById('sound-todo')
        };

        // 播放音效
        function playSound(type) {
            const soundEnabled = localStorage.getItem('soundEnabled') !== 'false';
            if (soundEnabled && sounds[type]) {
                // 先尝试播放音频，如果失败则在用户交互后重试
                const sound = sounds[type];
                sound.volume = 0.3;
                const playPromise = sound.play();
                
                if (playPromise !== undefined) {
                    playPromise.catch(error => {
                        console.log('音效播放失败:', error);
                        // 用户交互后重试
                        const tryPlayAfterUserInteraction = () => {
                            sound.play().catch(e => console.log('音效播放失败:', e));
                            document.removeEventListener('click', tryPlayAfterUserInteraction);
                        };
                        document.addEventListener('click', tryPlayAfterUserInteraction);
                    });
                }
            }
        }
        // 添加全局点击音效函数
        // function playClickSound() {
        //     playSound('click');
        // }

        // 待办事项管理
        class TodoManager {
            constructor() {
                this.todos = JSON.parse(localStorage.getItem('todos')) || [];
                this.init();
            }

            // 初始化
            init() {
                this.renderTodos();
                this.setupEventListeners();
            }

            // 渲染待办事项列表
            renderTodos() {
                const todoList = document.getElementById('todo-list');
                
                if (this.todos.length === 0) {
                    todoList.innerHTML = `
                        
                            
                            暂无待办事项，添加你的第一个待办
                        
                    `;
                    return;
                }
                
                // 按创建时间排序，新的在前面
                const sortedTodos = [...this.todos].sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
                
                todoList.innerHTML = '';
                sortedTodos.forEach(todo => {
                    const todoElement = document.createElement('div');
                    todoElement.className = `p-3 border rounded-lg border-gray-200 dark:border-gray-700 hover:bg-gray-50 dark:hover:bg-gray-700/50 transition-colors flex items-center gap-3`;
                    todoElement.innerHTML = `
                        
                            
                        
                        ${todo.content}
                        
                            
                        
                    `;
                    
                    todoList.appendChild(todoElement);
                });
                
                // 添加事件监听
                document.querySelectorAll('.todo-checkbox').forEach(checkbox => {
                    checkbox.addEventListener('change', (e) => {
                        const todoId = e.target.getAttribute('data-id');
                        this.toggleTodoStatus(todoId);
                    });
                });
                
                document.querySelectorAll('.delete-todo').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const todoId = e.target.closest('.delete-todo').getAttribute('data-id');
                        this.deleteTodo(todoId);
                    });
                });
            }

            // 添加待办事项
            addTodo(content) {
                if (!content.trim()) return; // 不添加空内容
                
                const todo = {
                    id: Date.now().toString(),
                    content: content.trim(),
                    completed: false,
                    createdAt: new Date().toISOString()
                };
                
                this.todos.push(todo);
                this.saveTodos();
                this.renderTodos();
                playSound('todo');
            }

            // 切换待办事项状态
            toggleTodoStatus(id) {
                const todoIndex = this.todos.findIndex(todo => todo.id === id);
                if (todoIndex !== -1) {
                    this.todos[todoIndex].completed = !this.todos[todoIndex].completed;
                    this.saveTodos();
                    this.renderTodos();
                    playSound('click');
                }
            }

            // 删除待办事项
            deleteTodo(id) {
                this.todos = this.todos.filter(todo => todo.id !== id);
                this.saveTodos();
                this.renderTodos();
                playSound('cancel');
            }

            // 清除所有待办事项
            clearAllTodos() {
                this.todos = [];
                this.saveTodos();
                this.renderTodos();
            }

            // 保存待办事项到本地存储
            saveTodos() {
                localStorage.setItem('todos', JSON.stringify(this.todos));
            }

            // 设置事件监听
            setupEventListeners() {
                // 添加待办事项表单提交
                document.getElementById('todo-form').addEventListener('submit', (e) => {
                    e.preventDefault();
                    const todoInput = document.getElementById('todo-input');
                    const content = todoInput.value;
                    
                    if (content.trim()) {
                        this.addTodo(content);
                        todoInput.value = '';
                    }
                });
                
                // 添加待办事项按钮
                document.getElementById('add-todo-btn').addEventListener('click', () => {
                    const todoInput = document.getElementById('todo-input');
                    const content = todoInput.value;
                    
                    if (content.trim()) {
                        this.addTodo(content);
                        todoInput.value = '';
                    } else {
                        todoInput.focus();
                    }
                });
            }
        }

        // 任务数据管理
        class TaskManager {
            constructor() {
                this.tasks = JSON.parse(localStorage.getItem('tasks')) || [];
                this.currentTaskId = localStorage.getItem('currentTaskId') || null;
                this.timerInterval = null;
                this.init();
            }

            // 初始化
            init() {
                this.renderTasks();
                this.loadCurrentTask();
                this.setupEventListeners();
            }

            // 渲染任务列表
            renderTasks() {
                const taskList = document.getElementById('task-list');
                
                if (this.tasks.length === 0) {
                    taskList.innerHTML = `
                        
                            
                            暂无任务，点击添加按钮创建任务
                        
                    `;
                    return;
                }
                
                taskList.innerHTML = '';
                this.tasks.forEach(task => {
                    const isActive = task.id === this.currentTaskId;
                    const progress = task.totalSeconds > 0 ? Math.max(0, Math.min(100, (1 - task.remainingTime / task.totalSeconds) * 100)) : 0;
                    
                    // 格式化显示时长
                    const hours = Math.floor(task.totalSeconds / 3600);
                    const minutes = Math.floor((task.totalSeconds % 3600) / 60);
                    const seconds = task.totalSeconds % 60;
                    let durationText = '';
                    if (hours > 0) durationText += `${hours}小时`;
                    if (minutes > 0) durationText += `${minutes}分钟`;
                    if (seconds > 0 || durationText === '') durationText += `${seconds}秒`;
                    
                    const taskElement = document.createElement('div');
                    taskElement.className = `p-3 border rounded-lg ${isActive ? 'border-primary bg-primary/10' : 'border-gray-200 dark:border-gray-700 hover:bg-gray-50 dark:hover:bg-gray-700/50'} transition-colors cursor-pointer`;
                    taskElement.innerHTML = `
                        
                            ${task.name}
                            
                                
                                    
                                
                                
                                    
                                
                            
                        
                        
                            ${durationText}
                        
                        
                            
                        
                    `;
                    
                    taskElement.addEventListener('click', (e) => {
                        // 防止点击编辑/删除按钮时触发任务选择
                        if (!e.target.closest('.edit-task') && !e.target.closest('.delete-task')) {
                            this.selectTask(task.id);
                        }
                    });
                    
                    taskList.appendChild(taskElement);
                });
                
                // 添加编辑和删除事件监听
                document.querySelectorAll('.edit-task').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const taskId = btn.getAttribute('data-id');
                        this.editTask(taskId);
                    });
                });
                
                document.querySelectorAll('.delete-task').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const taskId = btn.getAttribute('data-id');
                        this.confirmDeleteTask(taskId);
                    });
                });
            }

            // 添加任务
            addTask(name, hours, minutes, seconds) {
                const totalSeconds = hours * 3600 + minutes * 60 + seconds;
                if (totalSeconds  task.id === id);
                if (taskIndex !== -1) {
                    const totalSeconds = hours * 3600 + minutes * 60 + seconds;
                    if (totalSeconds  task.id !== id);
                this.saveTasks();
                this.renderTasks();
                playSound('cancel');
            }

            // 确认删除任务
            confirmDeleteTask(id) {
                const task = this.tasks.find(t => t.id === id);
                if (!task) return;
                
                const confirmTitle = document.getElementById('confirm-title');
                const confirmMessage = document.getElementById('confirm-message');
                
                confirmTitle.textContent = '删除任务';
                confirmMessage.textContent = `您确定要删除任务"${task.name}"吗？此操作不可撤销。`;
                
                showConfirmModal(() => {
                    this.deleteTask(id);
                });
                playSound('click');
            }

            // 选择任务
            selectTask(id) {
                if (this.currentTaskId === id) return;
                
                // 停止当前计时器
                this.stopTimer();
                
                this.currentTaskId = id;
                localStorage.setItem('currentTaskId', id);
                this.loadCurrentTask();
                this.renderTasks();
                playSound('click');
            }

            // 加载当前任务
            loadCurrentTask() {
                const taskNameEl = document.getElementById('current-task-name');
                const startBtn = document.getElementById('start-timer');
                
                if (!this.currentTaskId) {
                    taskNameEl.textContent = '未选择任务';
                    startBtn.disabled = true;
                    this.updateTimerDisplay();
                    return;
                }
                
                const task = this.tasks.find(task => task.id === this.currentTaskId);
                if (task) {
                    taskNameEl.textContent = task.name;
                    startBtn.disabled = false;
                    this.updateTimerDisplay();
                } else {
                    // 如果任务不存在，清除当前任务ID
                    this.currentTaskId = null;
                    localStorage.removeItem('currentTaskId');
                    taskNameEl.textContent = '未选择任务';
                    startBtn.disabled = true;
                }
            }

            // 开始计时器
            startTimer() {
                if (!this.currentTaskId || this.timerInterval) return;
                
                const task = this.tasks.find(task => task.id === this.currentTaskId);
                if (!task) return;
                
                // 如果剩余时间为0，重置
                if (task.remainingTime  {
                    const task = this.tasks.find(task => task.id === this.currentTaskId);
                    if (!task) {
                        this.stopTimer();
                        return;
                    }
                    
                    task.remainingTime--;
                    this.saveTasks();
                    this.updateTimerDisplay();
                    this.renderTasks();
                    
                    // 时间到
                    if (task.remainingTime  {
                                if (permission === 'granted') {
                                    new Notification('任务完成', {
                                        body: `任务"${task.name}"已完成！`,
                                        icon: 'https://cdn-icons-png.flaticon.com/512/1006/1006771.png'
                                    });
                                }
                            });
                        }
                    }
                }, 1000);
            }

            // 暂停计时器
            stopTimer() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                    
                    const startBtn = document.getElementById('start-timer');
                    const pauseBtn = document.getElementById('pause-timer');
                    
                    startBtn.disabled = false;
                    pauseBtn.disabled = true;
                }
            }

             // 重置计时器
            resetTimer() {
                if (!this.currentTaskId) return;
                
                const task = this.tasks.find(task => task.id === this.currentTaskId);
                if (task) {
                    const confirmTitle = document.getElementById('confirm-title');
                    const confirmMessage = document.getElementById('confirm-message');
                    
                    confirmTitle.textContent = '重置计时器';
                    confirmMessage.textContent = `您确定要重置当前任务"${task.name}"的计时器吗？这将丢失当前进度。`;
                    
                    showConfirmModal(() => {
                        task.remainingTime = task.totalSeconds;
                        this.saveTasks();
                        this.updateTimerDisplay();
                        this.renderTasks();
                        playSound('click');
                    });
                }
            }

            // 更新计时器显示
            updateTimerDisplay() {
                const timerDisplay = document.getElementById('timer-display');
                const timerProgress = document.getElementById('timer-progress');
                
                if (!this.currentTaskId) {
                    timerDisplay.textContent = '00:00:00';
                    timerProgress.style.width = '0%';
                    return;
                }
                
                const task = this.tasks.find(task => task.id === this.currentTaskId);
                if (!task) {
                    timerDisplay.textContent = '00:00:00';
                    timerProgress.style.width = '0%';
                    return;
                }
                
                // 计算时分秒
                const totalSeconds = Math.max(0, task.remainingTime);
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;
                
                // 格式化显示
                const formattedTime = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                timerDisplay.textContent = formattedTime;
                
                // 更新进度条
                const progress = task.totalSeconds > 0 ? Math.max(0, Math.min(100, (1 - totalSeconds / task.totalSeconds) * 100)) : 0;
                timerProgress.style.width = `${progress}%`;
            }

            // 保存任务到本地存储
            saveTasks() {
                localStorage.setItem('tasks', JSON.stringify(this.tasks));
            }

            // 编辑任务
            editTask(id) {
                const task = this.tasks.find(task => task.id === id);
                if (!task) return;
                
                // 转换总秒数为时分秒
                const hours = Math.floor(task.totalSeconds / 3600);
                const minutes = Math.floor((task.totalSeconds % 3600) / 60);
                const seconds = task.totalSeconds % 60;
                
                document.getElementById('task-id').value = task.id;
                document.getElementById('task-name').value = task.name;
                document.getElementById('task-hours').value = hours;
                document.getElementById('task-minutes').value = minutes;
                document.getElementById('task-seconds').value = seconds;
                document.getElementById('modal-title').textContent = '编辑任务';
                
                showTaskModal();
            }

            // 清除所有任务
            clearAllTasks() {
                this.stopTimer();
                this.tasks = [];
                this.currentTaskId = null;
                localStorage.removeItem('currentTaskId');
                this.saveTasks();
                this.renderTasks();
                this.loadCurrentTask();
            }

            // 设置事件监听
            setupEventListeners() {
                // 开始计时器
                addTouchSupport(document.getElementById('start-timer'), () => {
                    this.startTimer();
                });
                
                // 暂停计时器
                addTouchSupport(document.getElementById('pause-timer'), () => {
                    this.stopTimer();
                });
                
                // 重置计时器
                addTouchSupport(document.getElementById('reset-timer'), () => {
                    this.resetTimer();
                });
                
                // 添加任务按钮
                addTouchSupport(document.getElementById('add-task-btn'), () => {
                    document.getElementById('task-form').reset();
                    document.getElementById('task-id').value = '';
                    document.getElementById('task-hours').value = 0;
                    document.getElementById('task-minutes').value = 25;
                    document.getElementById('task-seconds').value = 0;
                    document.getElementById('modal-title').textContent = '添加新任务';
                    showTaskModal();
                    playSound('click');
                });
                
                // 任务表单提交
                document.getElementById('task-form').addEventListener('submit', (e) => {
                    e.preventDefault();
                    
                    const taskId = document.getElementById('task-id').value;
                    const taskName = document.getElementById('task-name').value;
                    const hours = parseInt(document.getElementById('task-hours').value) || 0;
                    const minutes = parseInt(document.getElementById('task-minutes').value) || 0;
                    const seconds = parseInt(document.getElementById('task-seconds').value) || 0;
                    
                    // 验证时间有效性
                    if (hours  {
                    if (document.hidden) {
                        // 页面不可见时记录当前时间
                        if (this.timerInterval) {
                            this.backgroundStartTime = Date.now();
                        }
                    } else {
                        // 页面可见时计算后台经过的时间
                        if (this.timerInterval && this.backgroundStartTime) {
                            const elapsedTime = Math.floor((Date.now() - this.backgroundStartTime) / 1000);
                            const task = this.tasks.find(task => task.id === this.currentTaskId);
                            
                            if (task) {
                                task.remainingTime = Math.max(0, task.remainingTime - elapsedTime);
                                this.saveTasks();
                                this.updateTimerDisplay();
                                this.renderTasks();
                                
                                // 如果时间到了，停止计时器
                                if (task.remainingTime  {
                hideConfirmModal();
                onConfirm();
                playSound('click');
            });
            
            newConfirmCancel.addEventListener('click', () => {
                hideConfirmModal();
                playSound('cancel');
            });
        }

        // 隐藏确认对话框
        function hideConfirmModal() {
            const modal = document.getElementById('confirm-modal');
            modal.classList.add('opacity-0', 'pointer-events-none');
            modal.querySelector('div').classList.remove('scale-100');
            modal.querySelector('div').classList.add('scale-95');
        }

        // 显示帮助对话框
        function showHelpModal() {
            const modal = document.getElementById('help-modal');
            modal.classList.remove('opacity-0', 'pointer-events-none');
            modal.querySelector('div').classList.remove('scale-95');
            modal.querySelector('div').classList.add('scale-100');
            playSound('click');
        }

        // 隐藏帮助对话框
        function hideHelpModal() {
            const modal = document.getElementById('help-modal');
            modal.classList.add('opacity-0', 'pointer-events-none');
            modal.querySelector('div').classList.remove('scale-100');
            modal.querySelector('div').classList.add('scale-95');
            playSound('click');
        }

           // 初始化标签切换
        function initTabs() {
            const tasksTab = document.getElementById('tasks-tab');
            const todosTab = document.getElementById('todos-tab');
            const tasksPanel = document.getElementById('tasks-panel');
            const todosPanel = document.getElementById('todos-panel');
            
            // 确保元素存在
            if (!tasksTab || !todosTab || !tasksPanel || !todosPanel) {
                console.warn('Tab elements not found');
                return;
            }
            
            // 移除可能存在的重复事件监听器
            const newTasksTab = tasksTab.cloneNode(true);
            tasksTab.parentNode.replaceChild(newTasksTab, tasksTab);
            
            const newTodosTab = todosTab.cloneNode(true);
            todosTab.parentNode.replaceChild(newTodosTab, todosTab);
            
            // 任务标签切换函数
            function switchToTasks(e) {
                e.preventDefault();
                
                // 激活任务标签
                newTasksTab.classList.add('text-primary', 'border-b-2', 'border-primary');
                newTasksTab.classList.remove('text-gray-500', 'dark:text-gray-400');
                
                // 取消待办标签
                newTodosTab.classList.remove('text-primary', 'border-b-2', 'border-primary');
                newTodosTab.classList.add('text-gray-500', 'dark:text-gray-400');
                
                // 显示任务面板，隐藏待办面板
                tasksPanel.classList.remove('hidden');
                todosPanel.classList.add('hidden');
                
                playSound('click');
            }
            
            // 待办标签切换函数
            function switchToTodos(e) {
                e.preventDefault();
                
                // 激活待办标签
                newTodosTab.classList.add('text-primary', 'border-b-2', 'border-primary');
                newTodosTab.classList.remove('text-gray-500', 'dark:text-gray-400');
                
                // 取消任务标签
                newTasksTab.classList.remove('text-primary', 'border-b-2', 'border-primary');
                newTasksTab.classList.add('text-gray-500', 'dark:text-gray-400');
                
                // 显示待办面板，隐藏任务面板
                todosPanel.classList.remove('hidden');
                tasksPanel.classList.add('hidden');
                
                // 聚焦到待办输入框
                const todoInput = document.getElementById('todo-input');
                if (todoInput) {
                    todoInput.focus();
                }
                
                playSound('click');
            }
            
            // 为标签添加事件监听器（支持鼠标和触摸）
            newTasksTab.addEventListener('click', switchToTasks);
            newTasksTab.addEventListener('touchstart', switchToTasks);
            
            newTodosTab.addEventListener('click', switchToTodos);
            newTodosTab.addEventListener('touchstart', switchToTodos);
        }
        


        // 初始化背景
        function initBackground() {
            const bgImageData = localStorage.getItem('bgImageData');
            const bgContainer = document.getElementById('background-container');
            const bgImage = document.getElementById('background-image');
            
            // 默认背景图片URL
            const defaultBgUrl = 'https://oss.itbaima.cn/hub/928/image-202509276f4i3vi5a.png';
            
            if (bgImageData) {
                bgImage.src = bgImageData;
                // 添加图片加载失败的处理
                bgImage.onerror = function() {
                    console.log('背景图片加载失败，使用默认背景');
                    bgImage.src = defaultBgUrl;
                    // 从localStorage中移除无效的背景图片数据
                    localStorage.removeItem('bgImageData');
                };
                bgContainer.style.display = 'block';
            } else {
                // 默认背景
                bgImage.src = defaultBgUrl;
                bgContainer.style.display = 'block';
            }
            
            // 上传背景图片
            document.getElementById('bg-image-upload').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file && file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        localStorage.setItem('bgImageData', event.target.result);
                        bgImage.src = event.target.result;
                        // 移除可能存在的错误处理
                        bgImage.onerror = null;
                        playSound('click');
                    };
                    reader.readAsDataURL(file);
                }
            });
            
            // 重置背景
            document.getElementById('reset-bg-btn').addEventListener('click', () => {
                localStorage.removeItem('bgImageData');
                bgImage.src = defaultBgUrl;
                // 移除可能存在的错误处理
                bgImage.onerror = null;
                playSound('click');
            });
        }

          // 初始化主题
        function initTheme() {
            // 检查用户偏好
            const isDarkMode = localStorage.getItem('darkMode') === 'true' || 
                              (localStorage.getItem('darkMode') === null && 
                               window.matchMedia('(prefers-color-scheme: dark)').matches);
            
            console.log('Initializing theme. Dark mode preference:', isDarkMode);
            
            // 根据偏好设置dark类
            if (isDarkMode) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
            
            // 更新主题切换按钮的图标状态
            updateThemeButtonIcons(isDarkMode);
            
            // 主题切换按钮
            const themeToggle = document.getElementById('theme-toggle');
            if (themeToggle) {
                // 清理所有可能的事件监听器
                const newThemeToggle = themeToggle.cloneNode(true);
                themeToggle.parentNode.replaceChild(newThemeToggle, themeToggle);
                
                // 添加新的事件监听器
                newThemeToggle.addEventListener('click', toggleTheme);
                newThemeToggle.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    toggleTheme();
                });
            } else {
                console.warn('Theme toggle button not found');
            }
        }

 // 主题切换处理函数
        function toggleTheme(e) {
            if (e) e.preventDefault();
            
            // 切换dark类
            const isDark = document.documentElement.classList.toggle('dark');
            localStorage.setItem('darkMode', isDark);
            
            // 强制更新按钮图标
            updateThemeButtonIcons(isDark);
            
            playSound('click');
            
            // 调试信息
            console.log('Theme toggled. Dark mode:', isDark);
        }
        
        // 更新主题按钮图标
        function updateThemeButtonIcons(isDark) {
            const themeToggle = document.getElementById('theme-toggle');
            if (themeToggle) {
                const moonIcon = themeToggle.querySelector('.fa-moon-o');
                const sunIcon = themeToggle.querySelector('.fa-sun-o');
                
                if (isDark) {
                    // 显示太阳图标（暗色模式）
                    if (moonIcon) moonIcon.classList.add('hidden');
                    if (sunIcon) sunIcon.classList.remove('hidden');
                } else {
                    // 显示月亮图标（亮色模式）
                    if (moonIcon) moonIcon.classList.remove('hidden');
                    if (sunIcon) sunIcon.classList.add('hidden');
                }
            }
        }


        // 初始化音效设置
        function initSoundSettings() {
            const soundToggle = document.getElementById('sound-toggle');
            const soundEnabled = localStorage.getItem('soundEnabled') !== 'false';
            
            soundToggle.checked = soundEnabled;
            
            soundToggle.addEventListener('change', () => {
                localStorage.setItem('soundEnabled', soundToggle.checked);
                playSound('click');
            });
        }
 // 初始化菜单
        function initMenu() {
            const menuBtn = document.getElementById('menu-btn');
            const menuPanel = document.getElementById('menu-panel');
            
            // 确保菜单按钮存在
            if (!menuBtn || !menuPanel) {
                console.warn('Menu button or panel not found');
                return;
            }
            
            // 移除可能存在的重复事件监听器
            menuBtn.removeEventListener('click', toggleMenuHandler);
            menuBtn.removeEventListener('touchstart', toggleMenuHandler);
            
            // 菜单切换函数
            function toggleMenuHandler(e) {
                e.preventDefault();
                e.stopPropagation();
                
                const isOpen = menuPanel.classList.contains('translate-x-0');
                
                if (isOpen) {
                    menuPanel.classList.remove('translate-x-0');
                    menuPanel.classList.add('translate-x-full');
                } else {
                    menuPanel.classList.remove('translate-x-full');
                    menuPanel.classList.add('translate-x-0');
                }
                
                playSound('click');
            }
            
            // 同时支持鼠标点击和触摸
            menuBtn.addEventListener('click', toggleMenuHandler);
            menuBtn.addEventListener('touchstart', toggleMenuHandler);
            
            // 点击外部关闭菜单
            function closeMenu(e) {
                // 检查菜单是否打开
                if (menuPanel.classList.contains('translate-x-0')) {
                    // 检查点击目标是否在菜单外部
                    if (!menuPanel.contains(e.target) && e.target !== menuBtn && !menuBtn.contains(e.target)) {
                        menuPanel.classList.remove('translate-x-0');
                        menuPanel.classList.add('translate-x-full');
                    }
                }
            }
            
            // 同时监听鼠标和触摸事件
            document.removeEventListener('click', closeMenu);
            document.removeEventListener('touchstart', closeMenu);
            document.addEventListener('click', closeMenu);
            document.addEventListener('touchstart', closeMenu, { passive: true });
        }
           

         // 初始化数据清理功能
        function initDataCleaning(taskManager, todoManager) {
            // 清除计时任务数据
            addTouchSupport(document.getElementById('clear-tasks-btn'), () => {
                const confirmTitle = document.getElementById('confirm-title');
                const confirmMessage = document.getElementById('confirm-message');
                
                confirmTitle.textContent = '清除计时任务';
                confirmMessage.textContent = '您确定要清除所有计时任务吗？此操作不可撤销。';
                
                showConfirmModal(() => {
                    taskManager.clearAllTasks();
                });
            });
            
            // 清除待办事项数据
            addTouchSupport(document.getElementById('clear-todos-btn'), () => {
                const confirmTitle = document.getElementById('confirm-title');
                const confirmMessage = document.getElementById('confirm-message');
                
                confirmTitle.textContent = '清除待办事项';
                confirmMessage.textContent = '您确定要清除所有待办事项吗？此操作不可撤销。';
                
                showConfirmModal(() => {
                    todoManager.clearAllTodos();
                });
            });
            
            // 清除背景缓存
            addTouchSupport(document.getElementById('clear-bg-cache-btn'), () => {
                const confirmTitle = document.getElementById('confirm-title');
                const confirmMessage = document.getElementById('confirm-message');
                
                confirmTitle.textContent = '清除背景缓存';
                confirmMessage.textContent = '您确定要清除背景图片缓存吗？将恢复为默认背景。';
                
                showConfirmModal(() => {
                    localStorage.removeItem('bgImageData');
                    // 重新初始化背景
                    initBackground();
                    playSound('click');
                });
            });
            
          // 清除设置数据
            addTouchSupport(document.getElementById('clear-settings-btn'), () => {
                const confirmTitle = document.getElementById('confirm-title');
                const confirmMessage = document.getElementById('confirm-message');
                
                confirmTitle.textContent = '清除设置数据';
                confirmMessage.textContent = '您确定要清除所有设置数据吗？包括主题、音效等设置将恢复为默认值。';
                
                showConfirmModal(() => {
                    localStorage.removeItem('darkMode');
                    localStorage.removeItem('soundEnabled');
                    localStorage.removeItem('bgImageData');
                    
                    // 重新初始化设置
                    setTimeout(() => {
                        initTheme();
                        initSoundSettings();
                        initBackground();
                    }, 0);
                    
                    // 关闭菜单
                    document.getElementById('menu-panel').classList.remove('translate-x-0');
                    document.getElementById('menu-panel').classList.add('translate-x-full');
                });
            });
            
             // 清除所有数据
            addTouchSupport(document.getElementById('clear-all-btn'), () => {
                const confirmTitle = document.getElementById('confirm-title');
                const confirmMessage = document.getElementById('confirm-message');
                
                confirmTitle.textContent = '清除所有数据';
                confirmMessage.textContent = '⚠️ 警告：您确定要清除所有数据吗？这将包括所有任务、待办事项和设置，且不可撤销！';
                
                showConfirmModal(() => {
                    // 清除所有本地存储
                    localStorage.clear();
                    
                    // 重新初始化应用
                    setTimeout(() => {
                        const taskManager = new TaskManager();
                        const todoManager = new TodoManager();
                        initTheme();
                        initSoundSettings();
                        initBackground();
                    }, 0);
                    
                    // 关闭菜单
                    document.getElementById('menu-panel').classList.remove('translate-x-0');
                    document.getElementById('menu-panel').classList.add('translate-x-full');
                });
            });
        }

        // 初始化帮助按钮
        function initHelpButton() {
            addTouchSupport(document.getElementById('help-btn'), showHelpModal);
            addTouchSupport(document.getElementById('close-help'), hideHelpModal);
        }

        // 初始化主页按钮
        function initHomeButton() {
            addTouchSupport(document.getElementById('Home'), () => {
                window.location.href = '/';
            });
        }

        // 请求通知权限
        function requestNotificationPermission() {
            if (Notification && Notification.permission !== 'granted' && Notification.permission !== 'denied') {
                Notification.requestPermission();
            }
        }

         // 初始化应用
        document.addEventListener('DOMContentLoaded', () => {
            initTheme();
            initBackground();
            initSoundSettings();
            initMenu();
            initHelpButton();
            initTabs();
            requestNotificationPermission();
            initHomeButton() 
            const taskManager = new TaskManager();
            const todoManager = new TodoManager();
            initDataCleaning(taskManager, todoManager);
            
            // 为所有按钮添加触摸支持
            const buttons = document.querySelectorAll('button');
            buttons.forEach(button => {
                button.classList.add('touch-device');
            });
        });
    


]]></content>
  </entry>
</search>
