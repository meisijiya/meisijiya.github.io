<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>老江湖来咯</title>
    <url>/2025/09/16/%E8%80%81%E6%B1%9F%E6%B9%96%E6%9D%A5%E5%92%AF/</url>
    <content><![CDATA[老江湖来咯，哈哈哈哈哈哈哈哈哈哈
]]></content>
      <categories>
        <category>碎碎念</category>
      </categories>
      <tags>
        <tag>开心</tag>
      </tags>
  </entry>
  <entry>
    <title>01-总览</title>
    <url>/2025/10/12/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/01-%E6%80%BB%E8%A7%88/</url>
    <content><![CDATA[黑马点评的收获概览极大的提高基础编程能力
Java8新特性
stream流的用法
函数式编程


深化mybatis plus
mp的高级用法，sql与api穿插解决问题
mp框架的一些小问题（比如，list查id的时候，是乱序的），能够如何去优化


模型转换概念（pojo、entity、vo、dto、requires）
线程池的实际使用
java阻塞队列初识

深度学习redis所有数据结构用法，深度理解缓存概念
8种数据结构，每种都匹配了实际的开发需求功能
对于缓存的知识讲解全面，cache aside等业界常用缓存方案
深度练习springboot中的redis的api

对具体业务理解能力的提高提高编程效率，更加高效的使用工具类，编写工具类
使用hutool工具包
结合泛型高级应用与函数式编程，手搓适合自己的工具类

面试能力的提升
能够掌握分布式锁、缓存击穿、缓存穿透、缓存雪崩等面试必考点
redisson源码解读，掌握redis的高级用法，看门狗机制，muti-lock机制等面试加分亮点

进阶技能拓展
redis秒杀场景教学
原子性的深度理解与应用
多种秒杀方案讲解，针对单体和微服务并发情况展开。


学会lua脚本的基本编写，了解lua脚本的使用场景。lua脚本就是做原子性的业务，也可以做在nginx服务器的脚本去调redis。
学会nginx轻量服务器的搭建以及各种使用场景
多级缓存的的搭建，本地缓存caffine的使用
feed流的两种模式

希望我能够做到
提升业务熟练度⬆
提升写sql的熟练度⬆

如何转化到自己的简历上
更换内容
技术点嵌套
缓存解决方案
秒杀-分布式锁
多级缓存



]]></content>
      <categories>
        <category>黑马点评</category>
      </categories>
  </entry>
  <entry>
    <title>新增代码复制按钮功能</title>
    <url>/2025/09/21/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE/%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81%E5%A4%8D%E5%88%B6%E6%8C%89%E9%92%AE%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[
参考文章Add Copy Button to Code Blocks in Hexo | Hexo
照着大佬来就好了！祝大家幸福美满。
]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>博客功能</tag>
      </tags>
  </entry>
  <entry>
    <title>改善黑暗模式中的代码显示</title>
    <url>/2025/09/21/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE/%E6%94%B9%E5%96%84%E9%BB%91%E6%9A%97%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[
参考文章：Sync Code Block Theme with Dark Mode in Hexo Chic | Hexo
没什么好说的，照着来就行。祝大家生活愉快，心想事成。
]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>博客功能</tag>
      </tags>
  </entry>
  <entry>
    <title>新增评论功能</title>
    <url>/2025/09/17/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE/%E6%96%B0%E5%A2%9E%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[使用giscus增加博客评论功能利用 GitHub Discussions 实现的评论系统

开源。🌏
无跟踪，无广告，永久免费。📡 🚫
无需数据库。所有数据均储存在 GitHub Discussions 中。:octocat:
支持自定义主题！🌗
支持多种语言。🌐
高可配置性。🔧
自动从 GitHub 拉取新评论与编辑。🔃
可自建服务！🤳

不同主题不同配置方法
以下是大佬的文章：
hexo 博客添加评论系统 | Jachin’s Blog
附上适合本主题的大佬链接Hexo and Chic themes add Giscus comment system | Hexo
]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title>记录搭建博客流程😗</title>
    <url>/2025/09/16/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE/%E8%AE%B0%E5%BD%95%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%B5%81%E7%A8%8B%F0%9F%98%97/</url>
    <content><![CDATA[说明记录一下博客搭建流程，为了能够以后更好的复现。
框架及工具
前端框架：hexo
后台管理系统插件：hexo pro
静态网站托管：github page
免费的 CDN 加速站点：cloudflare

准备需要准备 node 环境和 git
可以使用到 node 的版本管理工具****nvm 来下载 node。
# 访问 nvm 的 GitHub 仓库页面：https://github.com/nvm-sh/nvm# 可以在 Releases 页面（https://github.com/coreybutler/nvm-windows/releases）找到 nvm-setup.zip 安装文件并下载。# 解压并运行安装程序，按照提示进行安装。# nvm -v可以检查是否安装成功#NVM换源将如下代码加入settings.txt文件中。node_mirror: https://npmmirror.com/mirrors/nodenpm_mirror: https://npmmirror.com/mirrors/npm#NVM命令nvm version                # 查看NVM版本，是否安装成功nvm list available         # 查看可安装的node版本nvm list                   # 查看已安装的node版本nvm install 版本号          # 安装nodenvm uninstall 版本号        # 卸载nodenvm use 版本号              # 切换使用node版本nvm current                # 当前使用node版本nvm node_mirror [url]      # 切换node镜像[https://npm.taobao.org/mirrors/node/]nvm npm_mirror [url]       # 切换npm镜像[https://npm.taobao.org/mirrors/npm/]nvm alias default version  # 设置默认版本 #其他npm install -g yarn           # 全局安装yarnnpm install -g gitbook-cli   # 全局安装gitbook

通过 nvm 下载前需要把已经安装的 node 卸载
可以通过 Geek 卸载Geek Uninstaller - Download
通过 nvm 来下载：
1.打开终端（Windows 上是命令提示符或 PowerShell）
2.nvm list available 这个可以列出可以安装的 node 所有的版本
3.选择您想要安装的版本，例如安装 Node.js 版本 16.18.0 ，输入以下命令：nvm install 16.18.0
4.然后可以使用 nvm list 查看自己下载的版本
5.nvm use 16.18.0 安装完成后，可以使用命令切换到已安装的版本
6.再次 node -v 就可以看到安装的版本了
开始初始化 hexo 项目先安装 Hexo文档 | Hexo
npm install -g hexo-cli
创建文件夹，并进入到该文件夹的命令提示符（cmd）
输入hexo init 项目就会初始化
出现Start blogging with Hexo!表示成功
紧接着执行npm install
初始化后，您的项目文件夹将如下所示：
.├── _config.yml   #hexo的主配置文件├── package.json    #项目的依赖管理文件├── scaffolds   #模板文件夹├── source  #资源文件夹|   ├── _drafts #存放草稿文章|   └── _posts  #存放已经发布的文章└── themes  #主题文件夹

本地部署指令：hexo server 或 hexo s

访问 🔗，即可看到刚刚部署的网页了。
安装 hexo pro 插件wuzheng228&#x2F;hexo-pro
接下来安装 hexo pro 插件
# 1. 安装 Hexo Pro 插件npm install --save hexo-pro# 2. 启动 Hexo 服务器hexo server# 3. 访问后台管理页面http://localhost:4000/pro/

界面如下：

接下来我们就可以在这个系统里轻松地上传内容、更改配置、部署。
更改 hexo 配置更改_config.yml 的配置内容的操作自行根据官网文档来改。这边不多赘述。
配置 | Hexo
配置 github pagesGitHub Pages 文档 - GitHub 文档
首先默认大家有 GitHub 账户。
创建仓库（官网非常详细，我就粘下来啦）
在任何页面的右上角，选择 ，然后单击“新建存储库”。
**输入 **username.github.io 作为存储库名称。 将 username 替换为你的 GitHub 用户名。 例如，如果用户名为 octocat，则存储库名称应为 octocat.github.io。
选择仓库可见性。 有关详细信息，请参阅“关于仓库”。（默认 public）
选择“使用 README 初始化此存储库”。****（可选）
单击“创建存储库”。

部署代码连接 GitHub 的两种方式第一种使用 HTTPS 连接复制 GitHub 链接

第二种使用 SSH 连接如果选择 SSH 则需要通过 SSH 连接到 GitHub - GitHub 文档

执行以下命令生成 ssh 公钥，此公钥用于你的计算机连接 Github
ssh-keygen -t rsa -C &quot;你的邮箱&quot;

如下：

之后打开 C 盘下用户文件夹下的.ssh 的文件夹，会看到 id_rsa.pub
用记事本打开上述图片中的公钥（id_rsa.pub），复制里面的内容，然后开始在 github 中配置 ssh 密钥。

将 SSH KEY 配置到 GitHub 进入 github，点击右上角头像 选择settings，进入设置页后选择 SSH and GPG keys，名字随便起，公钥填到 Key 那一栏。

测试连接，输入以下命令
ssh -T git@github.com


出现连接到账户的信息，说明已经大功告成。


配置连接方式注意：通过Hexo Pro部署目前只能通过HTTPS的链接。
接下来只需要修改_config.yml 中最后一行的 deploy 的属性
deploy:  type: git   repo: #粘贴刚才所复制的HTTPS链接  branch: main #注意是main，不是master  message: &#x27;Site updated: &#123;&#123; now(&quot;YYYY-MM-DD HH:mm:ss&quot;) &#125;&#125;&#x27;

注意： yml 格式的文件，对应低一级的字段要在上级字段前至少空两格
现在我们在部署这栏中填写我们的仓库地址

仓库地址格式: username&#x2F;repository
紧接着点击执行部署即可。
然后就可以访问啦。😁
使用ssh部署，只能通过命令行也是先把仓库链接填上
deploy:  type: git  repo: git@github.com:meisijiya/meisijiya.github.io.git  branch: main  message: &#x27;Site updated: &#123;&#123; now(&quot;YYYY-MM-DD HH:mm:ss&quot;) &#125;&#125;&#x27;

部署的命令如下：

hexo clean：删除之前生成的文件，若未生成过静态文件，可忽略此命令。
hexo generate：生成静态文章，可以用 hexo g 缩写
hexo deploy：部署文章，可以用 hexo d 缩写

以下内容备用（一般执行完上面的步骤就可以了）
在存储库名称下，单击 “设置”。 如果看不到“设置”选项卡，请选择“”下拉菜单，然后单击“设置”。

在边栏的“代码和自动化”部分中，单击“ Pages”。

在“生成和部署”的“源”下，选择“从分支进行部署”。

在“生成和部署”的“分支”下，使用分支下拉菜单并选择发布源。8、9 的操作如下：


（可选）打开存储库的README.md 文件。 README.md 文件是你将为站点编写内容的位置。 您可以编辑文件或暂时保留默认内容。

访问 username.github.io 以查看新网站。 请注意，对站点的更改在推送到 GitHub 后，最长可能需要 10 分钟才会发布。


更改标题和说明（粘自官网）默认情况下，站点的标题为 username.github.io。 可通过编辑存储库中的 _config.yml 文件来更改标题。 您还可以为您的网站添加说明。

单击存储库的“代码”选项卡。
在文件列表中，单击 _config.yml 以打开该文件。
单击 编辑文件。
_config.yml 文件已包含指定站点主题的行。 添加一个新行，其中 title: 后跟所需的标题。 添加一个新行，其中 description: 后跟所需的描述。 例如：theme: jekyll-theme-minimaltitle: Octocat&#x27;s homepagedescription: Bookmark this to keep an eye on my project updates!
编辑完文件后，单击“提交更改”。

购买域名并更换域名域名购买参考如下：全网最全的域名解析和网站备案-CSDN 博客
替换域名
每次 deploy 的时候这里都会被重置为空
解决方法是在你博客项目下的****public 文件夹中创建一个名为 CNAME 的文件,注意，该文件无后缀。
用文本编辑器打开并填入你的域名（注意，不需要加入 https:&#x2F;&#x2F;，只需要域名）
这样就不用每部署一次就来填写一次自己的域名了。
此时访问你的域名，就会直接跳转到你的 github page 项目中。
使用 cloudflare 做 cdn 加速当然也有别的选择如，Vercel、Netlify、Railway、Render、Fleek、Zeabur
**这里我选择 cloudflare  **https://dash.cloudflare.com/
在账户主页 那一栏，点击 加入域

添加域名，然后点继续，接着选择免费计划即可。
接下来添加 DNS 记录
点击添加记录
名称一栏填 @，地址填下面出现的四个 ip 地址


使域名指向 github 的 IPv4 地址，这四个 IP（185.199.108.153、185.199.109.153、185.199.110.153、185.199.111.153）是 GitHub Pages 官方指定的用于内容分发的 IP，配置后域名会指向 GitHub 的服务器，从而能访问部署在 GitHub Pages 上的内容。
**保持后等待即可，因为 **DNS 解析依赖 “缓存” 和 “全球节点同步”，这两个机制决定了配置变更不会立即生效。
进阶–使用 Chic 主题Themes | Hexo
选择喜欢的主题，点击进入开发者产品的 readme 来一步一步配置即可。
我选择 Chic 这个主题，因为简单哈哈哈，当然也简洁美。🥰
hexo-theme-Chic&#x2F;README-CN.md at master · Siricee&#x2F;hexo-theme-Chic
操作步骤
cd your-blog/themes #进入到themes文件夹中git clone https://github.com/Siricee/hexo-theme-Chic.git Chic #打开cmd，然后输入该指令克隆即可// Modify theme setting in _config.yml to Chic.###需要我们在主配置文件_config.yml中，修改theme的值为Chic

然后我们可以看到&#x2F;theme&#x2F;Chic 这个文件夹中有_config.yml 配置文件，修改值来改变样式即可
添加 Tag、Category 页面
Hexo 初始化没有 tag、category 页面，需要自行添加，本主题请按以下步骤进行:
执行命令
hexo new page taghexo new page category

进入页面目录
cd source/tag

增加 layout 字段
// source\tag\index.md---title: Taglayout: tag---

category 页面同理，layout 字段键值为 category。
剩下的内容再更新吧，谢谢观看]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title>新增本地搜索</title>
    <url>/2025/09/21/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE/%E6%96%B0%E5%A2%9E%E6%9C%AC%E5%9C%B0%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[
参考原文Custom Search Integration for Hexo Chic | Hexo
tip：改了改，感觉我的有点屎山（不太会前端，得恶补一下js）
1.基于hexo-generator-searchdb实现的本地搜索npm install hexo-generator-searchdb #安装插件依赖

2.配置根目录的_config.ymlsearch:  path: search.xml   field: all  content: true   format: striptags 


path - 生成的数据库文件的路径。支持.json和.xml格式。如果未提供文件扩展名，默认将使用JSON格式。 
field - 你想要搜索的范围，你可以选择： post（默认）- 仅涵盖你博客的所有文章。 page - 仅涵盖你博客的所有页面。 all - 涵盖你博客的所有文章和页面。 
content - 是否包含每篇文章的完整内容。如果为false，生成的结果仅包含标题和其他元信息，不包含正文。默认值为true。
format - 页面内容的形式，选项有： striptags（默认）- 原始html字符串被压缩，并移除所有标签。 html - 原始html字符串被压缩。 raw - 每个文章或页面的markdown文本。

3.新建 search.css建议路径: themes/hexo-theme-Chic/source/css/search.css
/* 搜索框容器 */.search-container &#123;  position: relative;  display: inline-block;  vertical-align: middle;  margin-right: 10px;&#125;.search-container a &#123;  padding-right: 6px;  cursor: pointer;  font-size: 1.1em;&#125;.nav-search-input &#123;  display: none;  padding: 6px 10px;  border: 1px solid #ccc;  border-radius: 4px;  width: 260px;  transition: all 0.3s ease;  vertical-align: middle;&#125;.nav-search-input.active &#123;  display: inline-block;&#125;.nav-search-result &#123;  position: absolute;  top: 100%;  left: 0;  background: white;  border: 1px solid #ccc;  border-radius: 6px;  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);  margin-top: 6px;  padding: 0.4em;  min-width: 260px;  max-height: 360px;  overflow-y: auto;  display: none;  z-index: 999;&#125;/* 搜索卡片 */.search-card &#123;  padding: 4px 6px;  margin-bottom: 3px;  border-bottom: 1px solid #eee;  transition: background 0.2s;&#125;.search-card:last-child &#123;  border-bottom: none;  margin-bottom: 0;&#125;.search-card:hover &#123;  background: #f9f9f9;&#125;.search-card-title &#123;  display: block;  font-weight: bold;  color: #1a0dab;  font-size: 1em;  line-height: 1.2em;  text-decoration: none;  margin: 0;  padding: 0;  text-align: left;&#125;.search-card-title:hover &#123;  text-decoration: underline;&#125;.search-card-snippet &#123;  font-size: 0.88em;  color: #444;  margin-top: 2px;  line-height: 1.3em;  display: -webkit-box;  -webkit-line-clamp: 2;  -webkit-box-orient: vertical;  overflow: hidden;&#125;/* 🌙 暗色主题适配 */.dark-theme .nav-search-input &#123;  background-color: #1e1e1e;  color: #eee;  border: 1px solid #555;&#125;.dark-theme .nav-search-result &#123;  background-color: #2a2a2a;  color: #eee;  border: 1px solid #555;&#125;.dark-theme .search-card &#123;  border-bottom: 1px solid #444;&#125;.dark-theme .search-card:hover &#123;  background: #333;&#125;.dark-theme .search-card-title &#123;  color: #4ea1ff;&#125;.dark-theme .search-card-snippet &#123;  color: #ccc;&#125;/* 移动端适配 *//* iPadmini适配 */@media (min-width: 481px) and (max-width: 767px) &#123;  .search-container a &#123;    display: none;  &#125;&#125;@media (max-width: 768px) &#123;  .nav-search-input &#123;    width: 90%;    display: block;    margin: 10px auto;  &#125;  /* 暗色主题下的移动端结果容器 */  .dark-theme .nav-search-result &#123;    background-color: #2a2a2a;  &#125;&#125;/* 全局定位的移动端搜索结果 */@media (max-width: 768px) &#123;  .nav-search-result &#123;    position: fixed;           /* 相对于视窗定位 */    top: 20%;                  /* 距离顶部20% */    left: 5%;    right: 5%;    z-index: 9999;             /* 更高的层级 */    max-height: 60vh;          /* 更大的最大高度 */    margin: 0;    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);  &#125;&#125;

4.修改主题配置打开theme/Chic/_config.yml ，在 stylesheets 下增加一行 search.css 确保加载样式文件：
stylesheets:  - /css/style.css  - /css/search.css

5.修改 header.ejs&lt;header&gt;  &lt;nav class=&quot;navbar&quot;&gt;    &lt;div class=&quot;container&quot;&gt;      &lt;div class=&quot;navbar-header header-logo&quot;&gt;        &lt;a href=&quot;&lt;%- config.root %&gt;&quot;&gt;&lt;%= theme.navname %&gt;&lt;/a&gt;      &lt;/div&gt;      &lt;div class=&quot;menu navbar-right&quot;&gt;        &lt;!-- 在电脑端的导航链接区域添加搜索功能 --&gt;        &lt;div class=&quot;search-container&quot;&gt;          &lt;a href=&quot;javascript:;&quot; onclick=&quot;toggleSearchInput()&quot;&gt;🔍&lt;/a&gt;          &lt;input            type=&quot;text&quot;            id=&quot;nav-search-input-desktop&quot;            class=&quot;nav-search-input&quot;            placeholder=&quot;想知道我什么秘密呢，搜搜看吧&quot;            oninput=&quot;navSearch(this)&quot;          /&gt;          &lt;div id=&quot;nav-search-result-desktop&quot; class=&quot;nav-search-result&quot;&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;% for (var i in theme.nav)&#123; %&gt;        &lt;a class=&quot;menu-item&quot; href=&quot;&lt;%- url_for(theme.nav[i]) %&gt;&quot;&gt;&lt;%= i %&gt;&lt;/a&gt;        &lt;% &#125; %&gt;        &lt;input id=&quot;switch_default&quot; type=&quot;checkbox&quot; class=&quot;switch_default&quot; /&gt;        &lt;label for=&quot;switch_default&quot; class=&quot;toggleBtn&quot;&gt;&lt;/label&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/nav&gt;  &lt;%# mobile %&gt;  &lt;nav class=&quot;navbar-mobile&quot; id=&quot;nav-mobile&quot;&gt;    &lt;div class=&quot;container&quot;&gt;      &lt;div class=&quot;navbar-header&quot;&gt;        &lt;div&gt;          &lt;a href=&quot;&lt;%- config.root %&gt;&quot;&gt;&lt;%= theme.navname %&gt;&lt;/a          &gt;&lt;a id=&quot;mobile-toggle-theme&quot;&gt;·&amp;nbsp;Light&lt;/a&gt;        &lt;/div&gt;        &lt;div class=&quot;menu-toggle&quot; onclick=&quot;mobileBtn()&quot;&gt;          &lt;svg            class=&quot;menu-icon&quot;            xmlns=&quot;http://www.w3.org/2000/svg&quot;            width=&quot;32&quot;            height=&quot;32&quot;            viewBox=&quot;0 0 24 24&quot;          &gt;            &lt;path              fill=&quot;currentColor&quot;              d=&quot;M4.5 17.27q-.213 0-.356-.145T4 16.768t.144-.356t.356-.143h15q.213 0 .356.144q.144.144.144.357t-.144.356t-.356.143zm0-4.77q-.213 0-.356-.144T4 11.999t.144-.356t.356-.143h15q.213 0 .356.144t.144.357t-.144.356t-.356.143zm0-4.77q-.213 0-.356-.143Q4 7.443 4 7.23t.144-.356t.356-.143h15q.213 0 .356.144T20 7.23t-.144.356t-.356.144z&quot;            /&gt;          &lt;/svg&gt;          &lt;svg            class=&quot;close-icon&quot;            xmlns=&quot;http://www.w3.org/2000/svg&quot;            width=&quot;32&quot;            height=&quot;32&quot;            viewBox=&quot;0 0 24 24&quot;          &gt;            &lt;!-- Icon from Material Symbols Light by Google - https://github.com/google/material-design-icons/blob/master/LICENSE --&gt;            &lt;path              fill=&quot;currentColor&quot;              d=&quot;m12 12.708l-5.246 5.246q-.14.14-.344.15t-.364-.15t-.16-.354t.16-.354L11.292 12L6.046 6.754q-.14-.14-.15-.344t.15-.364t.354-.16t.354.16L12 11.292l5.246-5.246q.14-.14.345-.15q.203-.01.363.15t.16.354t-.16.354L12.708 12l5.246 5.246q.14.14.15.345q.01.203-.15.363t-.354.16t-.354-.16z&quot;            /&gt;          &lt;/svg&gt;        &lt;/div&gt;      &lt;/div&gt;      &lt;div class=&quot;menu&quot; id=&quot;mobile-menu&quot;&gt;        &lt;% for (var i in theme.nav)&#123; %&gt;        &lt;a class=&quot;menu-item&quot; href=&quot;&lt;%- url_for(theme.nav[i]) %&gt;&quot;&gt;&lt;%= i %&gt;&lt;/a&gt;        &lt;% &#125; %&gt;        &lt;!-- 手机模式搜索框 --&gt;        &lt;div class=&quot;search-container mobile-container&quot;&gt;          &lt;a class=&quot;menu-item&quot; href=&quot;javascript:;&quot; onclick=&quot;toggleSearchInput()&quot;            &gt;🔍&lt;/a          &gt;          &lt;input            type=&quot;text&quot;            id=&quot;nav-search-input-mobile&quot;            class=&quot;nav-search-input&quot;            placeholder=&quot;想知道我什么秘密呢，搜搜看吧&quot;            oninput=&quot;navSearch(this)&quot;          /&gt;          &lt;div id=&quot;nav-search-result-mobile&quot; class=&quot;nav-search-result&quot;&gt;&lt;/div&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/nav&gt;&lt;/header&gt;&lt;script&gt;  var mobileBtn = function f() &#123;    var toggleMenu = document.getElementsByClassName(&quot;menu-toggle&quot;)[0];    var mobileMenu = document.getElementById(&quot;mobile-menu&quot;);    if (toggleMenu.classList.contains(&quot;active&quot;)) &#123;      toggleMenu.classList.remove(&quot;active&quot;);      mobileMenu.classList.remove(&quot;active&quot;);    &#125; else &#123;      toggleMenu.classList.add(&quot;active&quot;);      mobileMenu.classList.add(&quot;active&quot;);    &#125;  &#125;;  function toggleSearchInput() &#123;    const inputs = document.querySelectorAll(&quot;.nav-search-input&quot;);    const results = document.querySelectorAll(&quot;.nav-search-result&quot;);    inputs.forEach((input) =&gt; &#123;      input.classList.toggle(&quot;active&quot;);      if (input.classList.contains(&quot;active&quot;)) input.focus();    &#125;);    results.forEach((r) =&gt; (r.style.display = &quot;none&quot;));  &#125;  // 点击外部区域隐藏搜索框和结果容器的函数  function handleClickOutsideSearch(event) &#123;    const searchContainers = document.querySelectorAll(&quot;.search-container&quot;);    searchContainers.forEach((container) =&gt; &#123;      const searchInput = container.querySelector(&quot;.nav-search-input&quot;);      const searchIcon = container.querySelector(&quot;a&quot;);      // 如果点击的元素不是搜索输入框或搜索图标，则隐藏搜索框和结果容器      if (        !searchInput.contains(event.target) &amp;&amp;        !searchIcon.contains(event.target)      ) &#123;        searchInput.classList.remove(&quot;active&quot;);        searchInput.value = &quot;&quot;        // 根据输入框ID确定对应的结果容器        let resultContainer;        if (searchInput.id === &quot;nav-search-input-mobile&quot;) &#123;          // 移动端结果容器          resultContainer = document.querySelector(            &quot;.navbar-mobile .nav-search-result&quot;          );        &#125; else &#123;          // 桌面端结果容器          resultContainer = document.getElementById(            &quot;nav-search-result-desktop&quot;          );        &#125;        if (resultContainer) &#123;          resultContainer.style.display = &quot;none&quot;;          resultContainer.innerHTML = &quot;&quot;; // 清空结果容器内容        &#125;      &#125;    &#125;);  &#125;  // 添加全局点击事件监听器  document.addEventListener(&quot;click&quot;, function (event) &#123;    handleClickOutsideSearch(event);  &#125;);  // 新增：搜索功能实现  let searchData = []; // 全局变量存储搜索数据  // 页面加载完成后获取搜索数据  document.addEventListener(&quot;DOMContentLoaded&quot;, function () &#123;    fetch(&quot;&lt;%- config.root %&gt;search.xml&quot;)      .then((res) =&gt; res.text())      .then((xmlText) =&gt; &#123;        const parser = new DOMParser();        const xml = parser.parseFromString(xmlText, &quot;text/xml&quot;);        const entries = xml.getElementsByTagName(&quot;entry&quot;);        for (let entry of entries) &#123;          searchData.push(&#123;            title: entry.getElementsByTagName(&quot;title&quot;)[0]?.textContent || &quot;&quot;,            content:              entry.getElementsByTagName(&quot;content&quot;)[0]?.textContent || &quot;&quot;,            url: entry.getElementsByTagName(&quot;url&quot;)[0]?.textContent || &quot;&quot;,          &#125;);        &#125;      &#125;)      .catch((err) =&gt; &#123;        console.error(&quot;Failed to load search data:&quot;, err);      &#125;);  &#125;);  // 新增：导航搜索方法  function navSearch(inputElement) &#123;    const keyword = inputElement.value.trim().toLowerCase();    // 查找对应的搜索结果容器    let resultContainer;    if (inputElement.id === &quot;nav-search-input-desktop&quot;) &#123;      // 桌面端      resultContainer = document.getElementById(&quot;nav-search-result-desktop&quot;);    &#125; else if (inputElement.id === &quot;nav-search-input-mobile&quot;) &#123;      // 移动端      resultContainer =        inputElement.parentNode.querySelector(&quot;.nav-search-result&quot;);    &#125;    if (!resultContainer) return;    resultContainer.innerHTML = &quot;&quot;;    if (!keyword) &#123;      resultContainer.style.display = &quot;none&quot;;      return;    &#125;    // 显示结果容器    resultContainer.style.display = &quot;block&quot;;    // 过滤搜索数据    const results = searchData.filter(      (data) =&gt;        (data.title &amp;&amp; data.title.toLowerCase().includes(keyword)) ||        (data.content &amp;&amp; data.content.toLowerCase().includes(keyword))    );    if (results.length === 0) &#123;      resultContainer.innerHTML =        &#x27;&lt;p class=&quot;no-result&quot;&gt;没有结果哟，换个关键词试试吧&lt;/p&gt;&#x27;;      return;    &#125;    // 限制显示结果数量    const maxResults = 10;    const limitedResults = results.slice(0, maxResults);    // 构建结果HTML    const html = limitedResults      .map((item) =&gt; &#123;        // 提取包含关键字的内容片段        let contentSnippet = &quot;&quot;;        if (item.content) &#123;          // 找到包含关键字的内容片段          const contentLower = item.content.toLowerCase();          const keywordIndex = contentLower.indexOf(keyword);          // 提取关键字前后的内容          const start = Math.max(0, keywordIndex - 3 * keyword.length);          const end = Math.min(            item.content.length,            keywordIndex + 3 * keyword.length          );          contentSnippet = item.content.substring(start, end);        // 高亮关键字      const keywordRegex = new RegExp(`($&#123;keyword.replace(/[.*+?^$&#123;&#125;()|[\]\\]/g, &#x27;\\$&amp;&#x27;)&#125;)`, &#x27;gi&#x27;);      contentSnippet = contentSnippet.replace(        keywordRegex,        &quot;&lt;mark&gt;$1&lt;/mark&gt;&quot;      );        &#125;        return `&lt;div class=&quot;search-result-item&quot;&gt;  &lt;a href=&quot;$&#123;item.url&#125;&quot;&gt;    &lt;div&gt;标题：$&#123;item.title&#125;&lt;/div&gt;    &lt;div&gt;内容：$&#123;contentSnippet&#125;&lt;/div&gt;  &lt;/a&gt;&lt;/div&gt;`;      &#125;)      .join(&quot;&quot;);    resultContainer.innerHTML = html;  &#125;&lt;/script&gt;&lt;style&gt;  /* 手机端使用flexbox布局搜索容器 */  .mobile-container &#123;    display: flex;    align-items: center;    flex-direction: row;    margin-bottom: 10px;    margin-left: 10px;    flex-grow: 1;    max-width: calc(100% - 40px);  &#125;  .search-result-item &#123;  border: 1px solid #ddd; /* 边框 */  margin: 4px 0; /* 外层间距 */  padding: 0; /* 无内边距 */  background: #fff; /* 背景色 */&#125;.search-result-item a &#123;  display: block;  text-decoration: none;  color: inherit;&#125;.search-result-item div &#123;  padding: 3px 8px; /* 紧凑的内边距 */  margin: 0; /* 无外边距 */  line-height: 1.3; /* 紧凑的行高 */  word-wrap: break-word; /* 允许长单词换行 */  white-space: normal; /* 允许正常换行 */&#125;.search-result-item div:first-child &#123;  border-bottom: 1px solid #eee; /* 标题和内容之间的分隔线 */&#125;&lt;/style&gt;

6.实现效果
点击图标展示搜索框
实时匹配文章标题&#x2F;内容
结果以卡片形式展示
黑色模式样式自动选择
点击空白地方隐藏结果 + 清空文本
移动端页面适配

7. 新生成并运行 Hexo需要通过hexo g生成本地数据库
hexo cleanhexo ghexo s

]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>博客功能</tag>
      </tags>
  </entry>
  <entry>
    <title>改良代码块，过长则滚动展示</title>
    <url>/2025/09/21/%E6%94%B9%E8%89%AF%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%8C%E8%BF%87%E9%95%BF%E5%88%99%E6%BB%9A%E5%8A%A8%E5%B1%95%E7%A4%BA/</url>
    <content><![CDATA[在/themes/Chic/source/css/style.styl文件中添加如下
// 代码块滚动功能：限制高度并显示滚动条.highlight  // 核心：限制最大高度，超出部分滚动  max-height: 400px !important  overflow-y: auto !important  // 垂直滚动  overflow-x: auto !important  // 水平滚动（防止代码过长溢出）  white-space: pre !important  // 保留代码格式，不自动换行  height: auto !important      // 避免固定高度覆盖滚动逻辑  // 优化代码块内边距和视觉效果（可选，根据主题调整）  padding: 15px !important  border-radius: 6px !important// 暗色模式适配（如果主题支持暗色模式）.dark-theme  .highlight    background-color: #1e1e1e !important  // 暗色背景    border: 1px solid #333 !important     // 暗色边框// 响应式适配：移动端降低最大高度@media (max-width: 768px)  .highlight    max-height: 300px !important  // 手机端显示更少内容，避免占满屏幕

搭配改善在黑暗模式中的代码背景显示以及滚动条视觉优化的代码/themes/Chic/source/css/custom.css
pre,code,pre code,.highlight &#123;    background: inherit !important;    color: inherit !important;    box-shadow: none !important;    border: none !important;  &#125;body.dark-theme pre,body.dark-theme code,body.dark-theme .highlight &#123;    background: #0d1117 !important;  /* 暗色背景 */    color: #c9d1d9 !important;       /* 暗色文字 */    box-shadow: none !important;    border: none !important;&#125;body.dark-theme pre::-webkit-scrollbar-track,body.dark-theme code::-webkit-scrollbar-track &#123;    background: #0d1117 !important;  /* 修复滚动条白边 */&#125;
]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>博客功能</tag>
      </tags>
  </entry>
  <entry>
    <title>添加网站统计功能</title>
    <url>/2025/09/24/%E6%B7%BB%E5%8A%A0%E7%BD%91%E7%AB%99%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[
使用umami来统计网站数据

打开https://us.umami.is/
注册

用户信息随便填
填好网站名字、域名
数据保存到美国就行
然后将提供的js代码复制到自己的代码中

我把js代码复制到\themes\Chic\layout\layout.ejs中
&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&lt;%= config.language %&gt;&quot;&gt;&lt;head&gt;    &lt;%- partial(&#x27;_partial/head&#x27;,&#123;cache: true&#125;) %&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;        // this function is used to check current theme before page loaded.        (() =&gt; &#123;            const pagebody = document.getElementsByTagName(&#x27;body&#x27;)[0]            function setTheme(status) &#123;                if (status === &#x27;dark&#x27;) &#123;                    window.sessionStorage.theme = &#x27;dark&#x27;                    pagebody.classList.add(&#x27;dark-theme&#x27;);                &#125; else if (status === &#x27;light&#x27;) &#123;                    window.sessionStorage.theme = &#x27;light&#x27;                    pagebody.classList.remove(&#x27;dark-theme&#x27;);                &#125;            &#125;;            setTheme(window.sessionStorage.theme)        &#125;)();    &lt;/script&gt;    &lt;div class=&quot;wrapper&quot;&gt;        &lt;%- partial(&#x27;_partial/header&#x27;,&#123;cache: true&#125;) %&gt;            &lt;div class=&quot;main&quot;&gt;                &lt;%- body %&gt;            &lt;/div&gt;            &lt;%- partial(&#x27;_partial/footer&#x27;,&#123;cache: true&#125;) %&gt;    &lt;/div&gt;&lt;/body&gt;&lt;!-- umami 填入自己的 --&gt;&lt;script defer src=&quot;https://cloud.umami.is/script.js&quot; data-website-id=&quot;填入自己的&quot;&gt;&lt;/script&gt;&lt;/html&gt;

接着，在打开官网，找到自己的网站，点击edit。

然后复制这个链接

为了实现 umami 统计页面的反向代理而不改变 URL
我们可以创建一个Hexo页面来实现反向代理。
在\source\tongji\index.md中添加

然后在\themes\Chic_config.yml中添加这个页面的链接
# navigatior itemsnav:  归档: /archives  分类: /category  标签: /tag  时间线: /timeLine  网站统计: /tongji #新增  关于: /about

然后就大功告成。
]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>博客功能</tag>
        <tag>umami</tag>
      </tags>
  </entry>
  <entry>
    <title>idea的git菜单详解</title>
    <url>/2025/09/20/Git/00-idea%E6%93%8D%E4%BD%9Cgit/</url>
    <content><![CDATA[
常见指令
IDEA中的git菜单选项详解
以下是对该 Git 相关菜单中各选项的详细解释（以常见 IDE 如 IntelliJ IDEA 的 Git 集成为例）：
1. 提交 (I)…（Ctrl+K）
功能：将本地工作区的修改提交到本地 Git 仓库。
操作：点击后弹出 “提交” 窗口，可选择要提交的文件、填写提交信息（如功能更新、问题修复的描述），最终在本地仓库生成一条新的提交记录（但不影响远程仓库）。

2. 推送…（Ctrl+Shift+K）
功能：将本地仓库的提交推送到远程仓库（如 GitHub、GitLab 等）。
场景：本地多次commit后，通过 “推送” 一次性把这些提交同步到远程，远程仓库会完整保留本地的多条提交记录（每条提交的哈希、信息、时间都会记录）。

3. 更新项目 (U)…（Ctrl+T）
功能：拉取远程仓库的最新更新，并自动合并到本地当前分支（相当于 “拉取 + 合并” 的组合操作）。
作用：确保本地代码与远程仓库的最新状态同步，常用于多人协作时更新他人的提交。

4. 拉取…
功能：从远程仓库拉取最新提交到本地仓库，但不自动合并到当前工作分支。
特点：仅更新本地的 “远程分支引用”，如需合并到当前工作分支，需后续手动执行 “合并” 操作（或用 “更新项目”）。

5. 提取
功能：类似git fetch，从远程仓库获取提交对象、分支信息等，但完全不影响本地工作分支（更偏向 “底层数据同步”，一般用于精细控制或调试，普通开发更常用 “拉取” 或 “更新项目”）。

6. 合并…
功能：将指定分支的提交合并到当前分支。
场景：比如在feature分支开发后，要把master分支的最新代码合并进来，或把feature分支合并到master准备发布。合并时会自动处理（或提示解决）冲突。

7. 变基…
功能：执行git rebase操作，将当前分支的提交 “变基” 到目标分支的最新提交上，使提交历史更线性整洁。
对比 “合并”：合并会产生 “合并提交”，而变基会重写提交历史（把当前分支的提交 “接” 在目标分支最新提交之后），更适合多人协作时保持分支历史清晰。
git多次提交到本地仓库,然后一次性提交到远程仓库,远程仓库会记录到多次提交要消除历史提交，只保留合并后的单一提交记录，可以使用变基

8. 分支 (B)…（Ctrl+Shift+）
功能：分支的综合管理，包括查看所有分支、切换分支、删除分支等。
操作：点击后可浏览本地 &#x2F; 远程分支列表，快速切换工作分支（如从master切到feature/login）。

9. 新建分支…
功能：基于当前分支或指定提交，创建一个新的分支。
场景：开发新功能时，从master分支新建feature/xxx分支，实现 “分支隔离开发”。

10. 新建标记…
功能：创建 Git标签（Tag），用于标记重要版本（如发布版本v1.0.0）。
作用：标签是 “不可变的提交引用”，方便后续快速定位到某个版本（如回退到发布版本、生成版本包）。

11. 重置 HEAD…
功能：重置HEAD指针的位置（HEAD是当前分支的 “当前提交” 引用），用于撤销提交。
选项：
--soft：保留修改到 “暂存区”（可重新提交）；
--mixed（默认）：保留修改到 “工作区”（未暂存，需重新添加）；
--hard：直接丢弃修改（慎用，会丢失未提交的变更）。



12. 显示 Git 日志
功能：查看当前分支的提交历史，包括每个提交的哈希值、作者、时间、提交信息等。
作用：用于追溯代码变更记录（如谁在什么时候改了哪部分代码）。

13. 补丁文件
功能：生成 &#x2F; 应用 ** 补丁（Patch）** 文件，将提交的变更导出为文本文件，或从补丁文件导入变更。
场景：无直接远程连接时，通过补丁分享代码变更（如给第三方提交代码时，先导出补丁再发送）。

14. 未提交的更改 (U)
功能：查看工作区中尚未提交的修改（包括新增、修改、删除的文件）。
作用：提交前确认变更内容，避免误提交无关文件。

15. 选定目录
功能：对指定目录执行 Git 操作（如仅提交该目录下的修改、查看该目录的版本历史）。
场景：大型项目中，聚焦某个模块的变更管理。

16. GitHub
功能：与GitHub 平台集成的操作（如登录 GitHub 账号、创建远程仓库、将本地仓库关联到 GitHub 等）。
作用：简化与 GitHub 的交互（如一键 “推送到 GitHub”）。

17. 管理远程…
功能：配置远程仓库的信息（如添加、删除、修改远程仓库的 URL）。
示例：本地仓库关联远程时，可通过这里设置origin的地址为https://github.com/xxx/repo.git。

18. 克隆…
功能：从远程仓库克隆一个完整的仓库到本地（包括所有分支、提交历史）。
场景：首次获取他人 &#x2F; 团队的项目时使用。

19. VCS 操作弹出窗口…（Alt+）
功能：打开综合 VCS 操作面板，聚合更多 Git（或其他版本控制）的精细操作，方便快速访问。

这些选项覆盖了 Git“本地提交、远程同步、分支管理、版本追溯” 等核心流程，帮助开发者在 IDE 中高效完成版本控制。
Git 提交历史右键菜单
以下是对该 Git 提交历史右键菜单各选项的详细解释（基于 IDE 如 IntelliJ IDEA 的 Git 集成）：
1. 复制修订号（Ctrl+Alt+Shift+C）
作用：复制当前提交的哈希值（Git 提交的唯一标识，形如 a1b2c3...）。
场景：需在命令行引用该提交（如 git show &lt;哈希&gt;）、分享特定提交时，快速获取标识。

2. 创建补丁…
作用：将当前提交的代码变更导出为「补丁文件（.patch）」。
场景：无直接 Git 远程连接时，通过补丁文件传递代码变更（他人可执行 git apply &lt;补丁文件&gt; 应用变更）。

3. 优选（对应 git cherry-pick）
作用：将当前提交（不属于当前分支）复制到当前分支，生成新提交。
场景：把其他分支的 “单个有用提交”（如feature分支的某个修复）合并到当前分支，无需拉取整个分支。

4. 签出修订
作用：将工作区 &#x2F; 暂存区切换到当前提交的代码状态（即 “检出” 该提交）。
场景：查看历史版本代码，或基于旧提交新建分支（如 git checkout &lt;哈希&gt; -b new-branch）。

5. 在修订中显示仓库
作用：以当前提交为视角，展示仓库整体的文件结构与内容。
场景：查看该提交时仓库的完整状态（哪些文件被改 &#x2F; 增 &#x2F; 删）。

6. 与本地比较
作用：对比当前提交的代码与本地工作区的代码差异。
场景：确认本地变更与历史提交是否冲突，或查看本地对历史版本的修改。

7. 将当前分支重置到此处…
作用：把当前分支的HEAD 指针移动到当前提交，并可选择重置模式（–soft&#x2F;–mixed&#x2F;–hard
）：

--soft：仅移动HEAD，变更保留在暂存区；
--mixed（默认）：移动HEAD，暂存区重置，变更保留在工作区；
--hard：移动HEAD，暂存区 &#x2F; 工作区均重置（丢弃本地未提交变更，慎用）。


场景：回退分支到历史提交，按需保留 &#x2F; 丢弃后续变更。


8. 还原提交（对应 git revert）
作用：创建新提交，抵消当前提交的变更（不删除历史提交，而是 “反向修正”）。
场景：已推送到远程的提交需回退时，避免改写历史（不影响协作）。

9. 撤销提交…（对应 git reset 交互）
作用：回退当前分支到该提交之前，并交互选择如何处理后续变更（类似 “重置分支” 的友好界面）。

10. 编辑提交消息…（F2）
作用：修改当前提交的提交信息（commit message）。
场景：提交后发现消息写错，若未推送到远程可直接修改；已推送则需强制推送（慎用于协作分支）。

11. Fixup…（对应 git rebase -i 的 fixup）
作用：将当前提交合并到前一个提交，并丢弃当前提交的消息。
场景：修复前一个提交的小问题，无需保留 “修复提交” 的独立记录，让历史更整洁。

12. 压缩到…
作用：将当前提交合并到指定提交，可选择是否保留提交消息（比Fixup更灵活的合并）。

13. 删除提交
作用：从提交历史中移除当前提交（通常通过「交互式变基」实现）。
注意：若提交已推送到远程，删除后需强制推送，可能影响协作。

14. 从这里进行交互式变基…（对应 git rebase -i）
作用：启动交互式变基，可对 “当前提交之后的所有提交” 进行编辑（合并、拆分、改消息等）。
场景：整理提交历史（如把多个小提交合并为一个有意义的大提交），让分支历史更线性。

15. 推送此前所有提交…
作用：将当前提交及之前所有本地未推送的提交推送到远程仓库。
场景：同步本地积累的多次提交到远程。

16. 新建分支…
作用：基于当前提交创建新分支。
场景：从历史版本开始开发新功能，或保存当前提交的状态到独立分支。

17. 新建标记…（对应 git tag）
作用：为当前提交创建Git 标签（如v1.0.0），标记重要版本。
场景：标记发布版本、里程碑，方便后续快速定位。

18. 转到子提交（向左箭头）
作用：在提交历史的 “父子关系” 中，切换到当前提交的子提交（即基于当前提交后续创建的提交）。
场景：浏览提交历史的 “后续发展”。

19. 转到父提交（向右箭头）
作用：切换到当前提交的父提交（即当前提交基于哪个提交创建）。
场景：回溯提交历史的 “来源”。

20. 在 GitHub 上打开
作用：若项目托管在 GitHub，在浏览器中打开当前提交的 GitHub 网页详情。
场景：快速查看该提交在 GitHub 上的变更、讨论等信息。

这些选项覆盖了 Git“提交管理、历史编辑、分支 &#x2F; 标签操作” 等核心场景，帮助在 IDE 中高效操作版本控制。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>git详解</title>
    <url>/2025/10/11/Git/git/</url>
    <content><![CDATA[初始化设置Git的用户名和邮箱是每个仓库初始化后的必要配置（因为 Git 是分布式版本控制系统，所以需要填写用户名和邮箱作为一个标识。）
#配置全局用户名和邮箱git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;your.email@example.com&quot;

配置好的 Git 的用户名和邮箱存储在 C:\Users\账户名 目录下的 .gitconfig 文件中
可通过git config --list查看。
当然，如果配置了全局用户名和邮箱（–global参数），下面内容是单独给仓库配置局部用户名和邮箱，因此可以选填，按需选择。

# 设置用户信息git config user.name &quot;Your Name&quot;git config user.email &quot;your.email@example.com&quot;

最后可以设置凭证助手，帮助自动管理代码仓库的用户名和密码（或令牌），避免每次操作都需要手动输入。
git config --global credential.helper manager

本地仓库初始化idea中创建项目可以通过创建面板中勾选创建git仓库即可。
也可以进入到新建项目中的  顶层菜单栏–VCS–创建Git仓库。
或者通过命令方法创建(初始化)本地git仓库
# 进入项目目录cd your-project-directory#初始化git仓库git init

或克隆远程仓库
# 克隆远程仓库到本地git clone &lt;repository-url&gt;

验证仓库创建
# 查看仓库状态git status

关联远程仓库创建本地Git仓库后，会出现顶层菜单栏中的Git选项。点击Git选项后选择管理远程添加远程仓库url实现idea中管理远程仓库。
当然现在还关联不了，显示
git@gitee.com: Permission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists.

因此我们需要选定连接方式来同远程仓库进行连接。目前以下两种方式最受欢迎。

HTTPS：需要个人访问令牌。即使没有配置个人访问令牌，也是可以 git clone 的，但是 git push 的时候需要输入用户名和个人访问令牌。
SSH：需要密钥对。如果没有配置密钥对，既不能 git clone，也不能 git push。

SSH执行如下命令，生成 SSH 密钥对。
#-c的作用是给产生的密钥对加一个注释，推荐注释信息跟本台机器相关ssh-keygen -t rsa -C &quot;本机标识&quot;

生成的 SSH 密钥对存储在 C:\Users\账户名\.ssh 目录下

id_rsa  私钥
id_rsa.pub 公钥

复制公钥里的内容，可通过clip &lt; \x7e/.ssh/id_rsa.pub命令去复制。
将公钥拷贝到GitHub或Gitee上。一般在设置–安全设置–SSH公钥。
测试是否能连接上。
#GitHubssh -T git@github.com#Giteessh -T git@gitee.com

连接上会有一段问候语。
这时再点击顶层菜单栏中的Git选项–管理远程，添加远程仓库url。
此时点击 idea中的  工具窗口–Git–左边栏–虚线↙️，此时能获取远程仓库信息。
HTTPS使用HTTPS能够克隆远程仓库到本地，但是 每次fetch和push代码都需要输入账号和密码。
一样的先将远程仓库url填入到Git–管理远程
若在 IDEA 中推送代码时无需再次验证，是因为之前的凭证已经被 “缓存” 了（可能是 IDE 保存了你的登录状态，或系统 &#x2F; Git 工具已经存储了你的账号 + 密码 &#x2F; 令牌）

[!tip]
HTTPS 的本质：需要身份验证HTTPS 协议本身要求提供用户名 + 密码（或平台的 “个人访问令牌”，如 GitHub&#x2F;Gitee 的令牌） 来完成身份验证（比如git push时，需要证明你有权限操作远程仓库）。
免重复验证的核心：凭证缓存为了避免每次操作都输入账号密码，Git 支持 “凭证缓存” 机制 —— 把你的身份凭证（密码 &#x2F; 令牌）保存起来，后续自动复用：

系统级缓存：比如 Windows 的「凭据管理器」、macOS 的「钥匙串」，会存储 Git 的账号凭证；
Git 工具级缓存：可通过命令（如git config --global credential.helper store）配置本地缓存，把凭证存在项目或全局的配置文件中；
IDE 集成缓存：像 IntelliJ IDEA 这类开发工具，会和 Git 的凭证系统联动，甚至自身也会管理 Gitee&#x2F;GitHub 的登录状态（比如你在 IDE 中通过 “添加账户” 功能登录过平台，IDE 会保存这些凭证供后续 Git 操作使用）。

通过git config –list查看是否有credential.helper&#x3D;managercredential.helper=manager 表示 Git 配置了「凭证管理器」（通常是 git-credential-manager，简称 GCM）作为凭证缓存工具。
它的作用是：自动保存你通过 HTTPS 连接 Git 仓库时输入的账号、密码或令牌，并在后续操作中自动复用这些凭证，避免重复输入。
在 Windows 系统中，这个管理器通常会将凭证存储在「系统凭据管理器」中（可通过 控制面板 → 用户账户 → 凭据管理器 查看 &#x2F; 管理已缓存的 Git 凭证）；在 macOS 或 Linux 上则可能与系统钥匙串集成。

连接上后依然会有一段问候语。
此时点击 idea中的  工具窗口–Git–左边栏–虚线↙️，此时能获取远程仓库信息。
Git相关基本概念基本概念
origin：默认远程仓库。
HEAD：指向当前分支的指针。
HEAD^：上一个版本。
HEAD~4：上 4 个版本。

特殊文件
.git：Git 仓库的元数据和对象数据库。
.gitignore：忽略文件（不需要提交到仓库的文件）。
.gitattributes：指定文件属性（如换行符）。
.gitkeep：使空目录能被提交。
.gitmodules：记录子模块的信息。
.gitconfig：记录 Git 的配置信息。

Git 的四个区域
工作区（Working Directory）：你在电脑里能看到的目录。
暂存区（Stage&#x2F;Index）：一般存放在 .git 目录下的 index 文件，因此暂存区有时也叫 “索引”。
本地仓库（Repository）：工作区有隐藏目录 .git，它是 Git 的版本库（不算工作区）。
远程仓库（Remote）：托管在远程服务器上的仓库。

Git 的三种状态
已修改（Modified）：修改了文件，但未保存到暂存区。
已暂存（Staged）：把修改后的文件放到暂存区。
已提交（Committed）：把暂存区的文件提交到本地仓库。

Git指令概念
操作指令对应的中文翻译
Remote：远程仓库（托管在服务器上的 Git 仓库，如 GitHub&#x2F;Gitee 上的仓库）
fetch&#x2F;clone：获取 &#x2F; 克隆（fetch：拉取远程仓库的提交数据到本地仓库；clone：完整复制远程仓库到本地，包含所有历史记录）
Repository：本地仓库（存储版本历史的核心数据库，对应项目中的 .git 目录区域）
push：推送（将本地仓库的提交推送到远程仓库）
Index：暂存区（也叫 “索引”，是提交前的临时区域，用于准备下次提交的内容）
add：添加（将工作区的文件修改 “添加” 到暂存区，为提交做准备）
commit：提交（将暂存区的内容 “提交” 到本地仓库，生成新的版本记录）
checkout：检出&#x2F;签出（可用于切换分支，或从仓库 &#x2F; 暂存区恢复文件到工作区）
pull：拉取（相当于 fetch + merge，从远程仓库拉取数据并合并到当前分支）
workspace：工作区（本地编辑代码的目录，是能直接看到文件的 “工作目录” 区域）


添加和提交
添加一个文件到仓库
git add &lt;file&gt;

添加所有文件到仓库
git add .

提交所有暂存区的文件到仓库
git commit -m &quot;message&quot;

提交所有已修改的文件到仓库
git commit -am &quot;message&quot;


分支
查看所有本地分支（当前分支前有*；-v看远程分支，-a 看所有分支）
git branch

创建一个新分支
git branch &lt;branch-name&gt;

切换到指定分支，并更新工作区
git checkout &lt;branch-name&gt;

创建一个新分支，并切换到该分支
git checkout -b &lt;branch-name&gt;

删除一个已合并的分支
git branch -d &lt;branch-name&gt;

删除一个分支（不管是否合并）
git branch -D &lt;branch-name&gt;

给当前提交打标签（通常用于版本发布）
git tag &lt;tag-name&gt;


合并分支
合并分支（--no-ff 禁用 Fast forward 模式，保留分支历史；-ff用 Fast forward 模式，历史成直线）
git merge --no-ff -m &quot;message&quot; &lt;branch-namegit merge --ff -m &quot;message&quot; &lt;branch-name&gt;
合并 &amp; squash 所有提交到一个提交
git merge --squash &lt;branch-name&gt;


文件操作与版本回退
移动一个文件到新位置
git mv &lt;file&gt; &lt;new-file&gt;

从工作区和暂存区删除文件，并暂存删除操作
git rm &lt;file&gt;

只从暂存区删除文件（工作区文件不变）
git rm --cached &lt;file&gt;

恢复文件到之前的版本
git checkout &lt;file&gt; &lt;commit-id&gt;

创建新提交撤销指定提交（抵消后者所有变化并应用到当前分支）
git revert &lt;commit-id&gt;

重置分支HEAD 到指定提交（--hard重置工作区 + 暂存区；--soft重置暂存区；--mixed 重置工作区）
git reset --mixed &lt;commit-id&gt;

撤销暂存文件，放回工作区（git add 的反向操作）
git restore --staged &lt;file&gt;


Rebase 变基Rebase 可把本地未 push 的分叉提交历史整理成直线（多人协作时，不要对已推送到远程的分支执行 Rebase）：
git checkout &lt;dev&gt;git rebase &lt;main&gt;

撤销（Stash）
储藏工作现场（-u包含未跟踪文件；-a 包含未跟踪 + 忽略文件；&quot;message&quot; 为存储说明）
git stash -u &quot;message&quot;git stash -a &quot;message&quot;
查看所有 stash
git stash list

恢复最近一次 stash（并删除该 stash）
git stash pop

恢复指定 stash（如 stash@&#123;2&#125; 是第 3 个 stash）
git stash pop stash@&#123;2&#125;

重新应用最近一次 stash（不删除 stash）
git stash apply

删除指定 stash
git stash drop stash@&#123;2&#125;

删除所有 stash
git stash clear


查看
列出未提交的新文件 &#x2F; 修改文件
git status

查看提交历史（--oneline简化显示）
git log --oneline

查看未暂存文件的更新内容
git diff

查看两个提交之间的差异
git diff &lt;commit-id&gt; &lt;commit-id&gt;


远程仓库
添加远程仓库
git remote add &lt;remote-name&gt; &lt;remote-url&gt;

查看远程仓库（含地址等详情）
git remote -v

删除远程仓库
git remote rm &lt;remote-name&gt;


远程仓库进阶操作
重命名远程仓库
git remote rename &lt;old-name&gt; &lt;new-name&gt;

从远程仓库拉取代码
git pull &lt;remote-name&gt; &lt;branch-name&gt;

fetch 默认拉取仓库（如origin）当前分支代码并合并到本地分支
git pull

拉取并 Rebase 远程最新代码（保证提交历史线性）
git pull --rebase

推送代码到远程仓库
git push &lt;remote-name&gt; &lt;branch-name&gt;

获取所有远程分支
git fetch &lt;remote-name&gt;

查看远程分支
git branch -r

fetch 某一个特定的远程分支
git fetch &lt;remote-name&gt; &lt;branch-name&gt;


IDEA实操Git合并和变基合并将分支 A 合并 到分支 B（git merge）
目标：把分支 A 的所有更改整合到分支 B，并保留合并记录。
IDEA 图形化操作：
右下角点击当前分支 → 切换到分支 B。
顶部菜单 Git → Merge Changes，在弹出窗口选择分支 A，点击 Merge。
若有冲突，IDEA 会提示 “Resolve Conflicts”，点击进入合并工具：
左侧为分支 B 的内容，右侧为分支 A 的内容，中间为合并结果。
点击冲突行两侧的箭头选择保留内容，或直接编辑中间区域。
完成后点击 Apply，再点击 Commit 完成合并。



变基将分支 A 变基 到分支 B（git rebase）
目标：把分支 A 的提交 “重新基于” 分支 B 的最新提交，形成线性历史（仅推荐个人本地分支使用）。
IDEA 图形化操作：
右下角切换到分支 A。
顶部菜单 Git → Rebase，在弹出窗口选择 “目标分支 B”，点击 Rebase（变基）。
若有冲突，IDEA 会提示 “Resolve conflicts”，处理方式同合并冲突。
解决后点击 Continue Rebase，直到所有提交应用完成。

对比


操作
核心步骤差异
最终历史特点
适用场景



合并（Merge）
切换到目标分支 → 合并源分支 → 可能生成合并提交
保留分支分叉，可见合并点
公共分支（如 main）、需保留合并记录


变基（Rebase）
切换到源分支 → 基于目标分支变基 → 解决冲突后继续
历史线性，无合并提交
个人本地分支（未推送到远程）


注意：变基会改写历史，绝对不要对已推送到远程并被他人使用的分支执行变基，否则会导致团队代码冲突。
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>命令行基础指令总结</title>
    <url>/2025/10/11/Linux/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[
命令行基础指令总结1. ls：列出目录（文件夹）中的文件
作用：查看当前 &#x2F; 指定目录下的文件 &#x2F; 目录列表。
常用选项：
-l：以每行一个的详细格式列出（l 代表 long）。
-a：列出所有文件（包括以 . 开头的隐藏文件，a 代表 all）。
-S：按文件大小排序列出（S 代表 Size）。
-t：按修改时间排序列出（t 代表 time modified）。
-r：倒序列出文件（r 代表 reverse）。


选项叠加示例：ls -ltr → 每行显示一个文件，按修改日期倒序排列。

2. mkdir：新建目录（文件夹）
作用：创建新的目录（如 mkdir new_folder 可创建名为 new_folder 的目录）。

3. cd：切换目录（文件夹）
作用：改变当前工作目录。
常用用法：
cd ~：跳转到当前用户的home 目录。
cd ../..：跳转到当前目录的上两级父目录（../ 表示 “上一级目录”，叠加表示多级跳转）。



4. rm：删除文件或目录
作用：移除文件或目录。
常用选项：
-i：删除前提示确认（输入 y 确认删除，n 取消）。
-r：递归删除目录（包括目录内所有文件，r 可理解为 recursive，即 “递归”）。
-f：强制删除（不提示，直接执行，f 代表 force）。


选项叠加示例：rm -rf [目录名] → 直接强制删除指定目录（含其内部所有内容，谨慎使用）。

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>老婆21岁生日快乐</title>
    <url>/2025/10/12/%E8%80%81%E5%A9%8621%E5%B2%81%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90/</url>
    <content><![CDATA[老婆生日快乐

臭老婆今天是你的生日，我没搞什么特别复杂的花样，就想跟你说：往后的日子，还想继续跟你一起 “臭气相投”
我的臭老婆，愿你新的一岁，能少点烦恼，多点开心；愿你想要的都能慢慢实现，而我能一直在你身边，陪你吃遍想吃的，玩遍想玩的，把每一个生日都过成我们专属的小美好。
生日快乐呀，我最最可爱的臭老婆！

]]></content>
      <categories>
        <category>房间门</category>
      </categories>
      <tags>
        <tag>开心</tag>
        <tag>老婆生日</tag>
      </tags>
  </entry>
  <entry>
    <title>0.1-Hutool工具类归纳</title>
    <url>/2025/10/12/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/0.2-Hutool%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%BD%92%E7%BA%B3/</url>
    <content><![CDATA[黑马点评项目中常用 Hutool 工具类及方法归纳Hutool 是一款轻量级 Java 工具类库，封装了开发中高频需求的通用功能，能大幅减少重复代码。在黑马点评（电商 &#x2F; 本地生活类项目）中，以下工具类及方法使用频率极高，按业务场景分类整理如下：
一、字符串处理工具：StrUtil核心场景：用户输入校验（判空）、手机号 &#x2F; 用户名脱敏、验证码生成、字符串拼接等。



常用方法
项目业务场景示例
方法作用说明



StrUtil.isBlank(CharSequence str)
校验用户输入的 “昵称”“地址” 是否为空
判断字符串是否为 null&#x2F; 空串 &#x2F; 空白符（比 StringUtils.isEmpty 更全面）


StrUtil.isNotBlank(CharSequence str)
校验 “手机号”“验证码” 是否非空（非空才执行后续逻辑）
与 isBlank 相反，非空时返回 true


StrUtil.hide(CharSequence str, int startInclude, int endExclude)
用户列表中手机号脱敏（如 138****1234）
隐藏字符串指定区间内容，用 * 替换


StrUtil.randomString(int length)
生成 6 位短信验证码（数字 + 字母混合）
生成指定长度的随机字符串（默认大小写字母 + 数字）


StrUtil.format(String template, Object... args)
拼接订单日志（如 “订单 {1} 支付金额 {2} 元”）
格式化字符串（替代 String.format，性能更优）


StrUtil.subAfter(CharSequence str, CharSequence separator, boolean isLast)
从 URL 中提取参数（如从 “&#x2F;order&#x2F;123” 提取 “123”）
截取分隔符之后的字符串，支持是否取最后一个分隔符


二、日期时间工具：DateUtil核心场景：订单时间格式化、优惠券有效期判断、日志时间记录、时间差计算（如订单超时）。



常用方法
项目业务场景示例
方法作用说明



DateUtil.format(Date date, String format)
订单列表展示时间（如 “2024-05-20 14:30:00”）
自定义日期格式（常用格式：yyyy-MM-dd HH:mm:ss）


DateUtil.now()
记录操作日志的当前时间（如 “20240520143000”）
获取当前时间字符串，默认格式 yyyyMMddHHmmss


DateUtil.parse(String dateStr, String format)
解析前端传递的优惠券生效时间（如 “2024-06-01”）
将字符串按指定格式转为 Date 对象


DateUtil.between(Date start, Date end, ChronoUnit unit)
计算订单超时时间（如 “订单创建后 30 分钟未支付则超时”）
计算两个时间的差值，指定单位（MINUTES&#x2F;HOURS&#x2F;DAYS）


DateUtil.offset(Date date, DateField field, int offset)
生成优惠券有效期（如 “领取后 7 天有效”）
对指定日期进行偏移（如 DateField.DAY_OF_YEAR, 7 表示加 7 天）


DateUtil.isExpired(Date date)
判断优惠券是否过期（对比当前时间）
判断指定日期是否已过期（早于当前时间）


三、集合工具：CollUtil核心场景：购物车商品列表处理、优惠券规则筛选、用户标签集合操作、分页数据处理。



常用方法
项目业务场景示例
方法作用说明



CollUtil.isEmpty(Collection&lt;?&gt; coll)
校验购物车是否为空（空则提示 “购物车无商品”）
判断集合是否为 null 或空集合


CollUtil.newArrayList(T... elements)
快速创建商品列表集合（避免 new ArrayList&lt;&gt;() 重复写）
可变参数创建 List，简化代码


CollUtil.filter(Collection&lt;?&gt; coll, Predicate&lt;?&gt; predicate)
筛选用户可用的优惠券（过滤已过期、未满足门槛的券）
按条件过滤集合元素，返回符合条件的新集合


CollUtil.getFirst(Collection&lt;?&gt; coll)
获取用户最新领取的优惠券（集合按时间排序后取第一个）
获取集合第一个元素（避免下标越界）


CollUtil.groupBy(Collection&lt;?&gt; coll, Function&lt;?, ?&gt; keyFunction)
按 “优惠券类型” 分组展示（如满减券、折扣券）
按指定 key 对集合分组，返回 Map&lt;key, List&lt;元素&gt;&gt;


四、HTTP 请求工具：HttpUtil核心场景：调用第三方接口（如短信服务、地图服务、支付回调）、获取远程资源（如商品图片）。



常用方法
项目业务场景示例
方法作用说明



HttpUtil.get(String url, Map&lt;String, Object&gt; paramMap)
调用地图 API 获取用户所在城市（传递经纬度参数）
发送 GET 请求，自动拼接参数，返回响应字符串


HttpUtil.post(String url, Map&lt;String, Object&gt; paramMap)
调用短信服务接口发送验证码（传递手机号、模板参数）
发送 POST 请求（表单格式 application/x-www-form-urlencoded）


HttpUtil.postJson(String url, String jsonStr)
调用支付接口提交订单（传递 JSON 格式的订单数据）
发送 JSON 格式的 POST 请求（Content-Type: application&#x2F;json）


HttpUtil.downloadFile(String url, File destFile)
下载商品详情页的远程图片到本地服务器
直接下载远程文件到指定路径，无需手动处理流


五、加密工具：SecureUtil核心场景：用户密码加密存储、接口签名校验（如防止请求篡改）、数据脱敏加密。



常用方法
项目业务场景示例
方法作用说明



SecureUtil.md5(String str)
对用户密码进行 MD5 加密（加盐后存储，如 md5(password + salt)）
生成 32 位小写 MD5 哈希值（不可逆加密，用于密码存储）


SecureUtil.bcrypt(String password)
更安全的密码加密（替代 MD5，自动生成盐值）
BCrypt 加密（带随机盐值，每次加密结果不同，验证时自动匹配盐值）


SecureUtil.hmacMd5(String key, String content)
接口请求签名（如 API 调用时用密钥生成签名，防止篡改）
HMAC-MD5 加密（带密钥，需双方持有相同密钥验证）


SecureUtil.des(String data, String key, String iv)
对敏感数据（如用户身份证号）进行 DES 加密存储
DES 对称加密（需密钥和向量 IV，可逆，用于敏感数据保护）


六、Bean 转换工具：BeanUtil核心场景：DTO 与 Entity 转换（如前端传递的UserLoginDTO转数据库User实体）、Map 与 Bean 转换（如第三方接口响应转本地对象）。



常用方法
项目业务场景示例
方法作用说明



BeanUtil.copyProperties(Object source, Object target)
将OrderDTO的属性复制到Order实体（忽略 null 值）
浅拷贝 Bean 属性，默认忽略 null 值（避免覆盖目标对象已有值）


BeanUtil.toBean(Map&lt;String, Object&gt; map, Class&lt;T&gt; clazz)
将第三方接口返回的 Map 转成PaymentResult对象
Map 键值对转 Bean（键需与 Bean 属性名一致）


BeanUtil.toMap(Object bean)
将User实体转成 Map，用于构建 Redis 缓存的 Hash 结构
Bean 转 Map（属性名作为 key，属性值作为 value）


BeanUtil.copyProperties(Object source, Object target, String... ignoreProperties)
复制订单数据时忽略 “createTime”（由数据库自动生成）
拷贝时排除指定属性，灵活控制字段映射


七、JSON 处理工具类:JSONUtil.轻量级且高效的 JSON 处理工具类，旨在简化 Java 中 JSON 数据的序列化、反序列化及各类操作，



常用方法
项目业务场景示例
方法作用说明



JSONUtil.toJsonStr(Object obj)
将用户实体（User）转 JSON 响应给前端
对象（Bean&#x2F;Map&#x2F;List&#x2F; 集合等）转 JSON 字符串


JSONUtil.toBean(String json, Class&lt;T&gt; clazz)
解析前端传递的 JSON 格式用户信息为UserDTO对象
JSON 字符串转指定类型 Java 对象


JSONUtil.parseObj(String jsonStr)
解析第三方接口返回的 JSON 为JSONObject，获取特定字段
把 JSON 字符串解析为JSONObject，支持键值操作


JSONUtil.createObj()&#x2F;JSONUtil.createArray()
动态构建 JSON（如构造带状态码和数据的接口响应 JSON）
链式创建 JSON 对象 &#x2F; 数组，灵活组装数据结构


JSONUtil.toJsonPrettyStr(Object obj)
生成格式化的 JSON 日志（如接口请求 &#x2F; 响应日志），便于调试
生成带缩进、换行的美化版 JSON 字符串


JSONUtil.parseFromXml(String xmlStr)
将 XML 格式的配置文件内容转为 JSON 处理（如旧系统配置迁移）
XML 字符串转 JSON，简化异构数据交互


JSONUtil.toXmlStr(JSONObject jsonObj)
将 JSON 格式的业务数据转 XML，适配旧系统接口
JSON 转 XML 字符串，支持格式兼容场景


八、其他高频工具类


工具类
核心场景
常用方法示例



IoUtil
流操作（如读取配置文件、处理文件上传流）
IoUtil.read(inputStream, CharsetUtil.UTF_8)（读取流为字符串）


FileUtil
文件操作（如创建商品图片目录、删除过期文件）
FileUtil.mkdir(filePath)（创建目录）、FileUtil.delete(file)（删除文件）


ValidatorUtil
参数校验（如手机号、邮箱格式校验）
ValidatorUtil.isMobile(mobile)（校验手机号）、ValidatorUtil.isEmail(email)（校验邮箱）


NumberUtil
数字处理（如金额计算、保留小数）
NumberUtil.add(a, b)（精确加法）、NumberUtil.round(number, 2)（保留 2 位小数）


ResourceUtil
读取 classpath 资源（如配置文件、模板文件）
ResourceUtil.readUtf8Str(&quot;config.properties&quot;)（读取配置文件）


九、使用原则总结
优先复用：Hutool 工具类已覆盖 90% 以上的通用场景，避免重复造轮子（如字符串判空直接用StrUtil.isBlank，而非自己写if (str == null || str.trim().equals(&quot;&quot;))）；
注意参数：部分工具类方法需指定编码（如IoUtil用CharsetUtil.UTF_8）、格式（如DateUtil用yyyy-MM-dd HH:mm:ss），避免默认值不匹配；
结合业务：工具类需与项目场景结合（如密码加密用SecureUtil.bcrypt而非 MD5，安全性更高），而非盲目使用。

]]></content>
      <categories>
        <category>黑马点评</category>
      </categories>
      <tags>
        <tag>Hutool</tag>
      </tags>
  </entry>
  <entry>
    <title>02-短信登录-基于session</title>
    <url>/2025/10/12/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/02-%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95-%E5%9F%BA%E4%BA%8Esession/</url>
    <content><![CDATA[前置：基于Session实现登录HttpSession 对象HttpSession_百度百科 Servlet Session 跟踪 | 菜鸟教程
Servlet提供了HttpSession接口，该接口中提供了一种跨多个页面请求或访问网站时识别用户以及存储有关用户信息的方式。Servlet 容器使用这个接口来创建一个 HTTP 客户端和 HTTP 服务器之间的 session 会话。会话持续一个指定的时间段，跨多个连接或页面请求。
@RestController结合了 @Controller 和 @ResponseBody。被被标记的类中，每个方法的返回值都会以JSON或XML的形式直接写入HTTP响应体中（@ResponseBody）。@Controller处理客户端发起的请求，并负责返回适当的视图（View）作为响应，搭配上@ResponseBody，使得以方法的返回值作为响应的主题内容，而不是解析为视图。
Spring中处理HTTP请求映射的注解@RestController@RequestMapping(&quot;/users&quot;)public class UserController&#123; @PostMapping(&quot;/create&quot;)/@GetMapping(&quot;list&quot;)public XXX  xxx&#123;        ...    &#125;&#125;

@RequestMapping
将web请求映射到具体方法上，标注在方法上。也可标注在类上，标注在类上时，表示类中所有响应请求的方法都是以该路径为父路径。
@PostMapping
组合注解。是@RequestMapping(method=RequestMethod.POST)的缩写。它用于处理HTTP POST请求的方法，只能标注在方法上。使用@PostMapping注解的方法将仅响应POST请求。
@GetMapping
组合注解。是@RequestMapping(method = RequestMethod.GET)的缩写。它用于处理HTTP GET请求的方法，也只能标注在方法上。使用@GetMapping注解的方法将仅响应GET请求。
SpringMVC接收前端传递的参数的注解一、核心注解总览（核心区别）


注解
参数来源
核心场景



@RequestParam
URL 查询串 &#x2F; 表单键值对
接收零散的键值对参数（如?name=xxx&amp;age=18）


@RequestBody
请求体（Request Body）
接收完整结构化数据（如 JSON&#x2F;XML）


@PathVariable
URI 路径占位符
接收 URL 路径中的参数（如/user/&#123;id&#125;）


二、各注解详细解析1. @RequestParam（键值对参数接收）核心作用接收 URL 查询串（?key=value）或表单（默认application/x-www-form-urlencoded）中的零散键值对参数。
请求格式http://xxx.com/xxx?key1=value1&amp;key2=value2（查询串）
或 表单提交（默认格式）
核心属性


属性名
作用



name/value
绑定前端参数名（必须与 URL &#x2F; 表单的参数名一致，name和value是别名关系）


required
是否必填：true（默认）→ 不传参数报错；false→ 不传参数不报错


defaultValue
可选参数的默认值（当参数未传或为空时生效，自动类型转换）


使用示例// 接收 ?name=张三&amp;age=18，age可选（默认20）@RequestMapping(&quot;/test&quot;)public String test(@RequestParam(&quot;name&quot;) String username,                    @RequestParam(value = &quot;age&quot;, required = false, defaultValue = &quot;20&quot;) Integer age) &#123;    return &quot;name:&quot; + username + &quot;, age:&quot; + age;&#125;

2. @RequestBody（请求体结构化数据接收）核心作用接收请求体中的完整结构化数据（如 JSON&#x2F;XML），将其直接转为 Java 对象或 Map。
前提条件
前端 Content-Type 必须设为 application/json（或application/xml）；
后端参数转化配置统一（避免 JSON 和普通表单混用）。

接收方式


接收类型
适用场景



自定义实体类
数据结构固定（如 User、Order 类）


Map&lt;String, Object&gt;
数据结构不固定（灵活接收键值对）


使用示例// 接收JSON请求体：&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:18&#125;@RequestMapping(value = &quot;/addUser&quot;, method = RequestMethod.POST)public String addUser(@RequestBody User user) &#123; // User类需有name、age字段及get/set    return &quot;新增用户：&quot; + user.getName();&#125;// 用Map接收（灵活场景）@RequestMapping(&quot;/addData&quot;)public String addData(@RequestBody Map&lt;String, Object&gt; data) &#123;    return &quot;数据：&quot; + data.get(&quot;key1&quot;) + &quot;,&quot; + data.get(&quot;key2&quot;);&#125;

3. @PathVariable（URI 路径参数接收）核心作用将 URL 路径中的占位符（&#123;参数名&#125;）映射到方法参数，用于 RESTful 风格接口。
请求格式http://xxx.com/xxx/&#123;param1&#125;/&#123;param2&#125;（如/user/123，123是id的占位值）
也支持混合查询串：/user/&#123;id&#125;?name=张三（id用 @PathVariable，name用 @RequestParam）
核心属性


属性名
作用



name/value
绑定路径占位符名称（与 URL 中&#123;&#125;内的名称一致，name和value是别名）


required
是否必填：true（默认）→ 路径无该占位符报错；false→ 可选


关键使用要点
建议用基本类型 &#x2F; 包装类接收参数（如int、Long）；
若显式指定name/value，必须与 URL 占位符名称一致（如@PathVariable(&quot;id&quot;) Long userId，URL 需是/user/&#123;id&#125;）；
未指定name/value时，默认绑定同名参数（如 URL/user/&#123;id&#125;，参数@PathVariable Long id）。

使用示例// 接收 /user/123 → id=123@RequestMapping(&quot;/user/&#123;id&#125;&quot;)public String getUser(@PathVariable(&quot;id&quot;) Long userId) &#123;    return &quot;用户ID：&quot; + userId;&#125;// 混合查询串：/user/123?name=张三@RequestMapping(&quot;/user/&#123;id&#125;&quot;)public String getUser(@PathVariable Long id, @RequestParam String name) &#123;    return &quot;ID：&quot; + id + &quot;，姓名：&quot; + name;&#125;

三、不同请求方式（GET&#x2F;POST）的注解适配规则1. GET 请求
可用注解：@RequestParam（查查询串）、@PathVariable（查路径占位符）；
禁用注解：@RequestBody（GET 请求无请求体，无法获取数据）。

2. POST 请求根据前端传递数据的格式，选择不同注解：



前端数据格式
推荐注解
说明



URL 查询串（?key=value）
@RequestParam
同 GET 的查询串接收方式


表单默认格式（application/x-www-form-urlencoded）
@RequestParam
接收表单中的键值对参数


JSON&#x2F;XML（application/json）
@RequestBody
接收请求体中的完整结构化数据


文件上传（multipart/form-data）
@RequestPart
专门接收文件（非文件字段仍用@RequestParam）


⚠️ 注意：application/x-www-form-urlencoded 格式**不推荐用@RequestBody**（会接收原始字符串，解析繁琐且不符合设计初衷）。
四、关键注意事项
注解数量限制：一个方法中可使用**多个@RequestParam（接收多个键值对），但只能使用一个@RequestBody**（请求体只有一个，多了会报错）；
Content-Type 影响：
前端默认Content-Type是application/x-www-form-urlencoded → 用@RequestParam；
前端传 JSON（application/json）→ 必须用@RequestBody，用@RequestParam会取不到值且报错；


@PathVariable的参数名一致性：显式指定name/value时，必须与 URL 占位符名称完全匹配，否则无法映射。

Mybatis-plus优秀的 ORM 框架，致力于简化和提高 Java 应用程序对数据库访问的效率。
@Transactional只能应用到接口方法、类、还有public方法上。一般在@service标记的类上添加，可以将整个service类纳入Spring事务管理，采用统一的事务管理方式。
常用属性总结：

propagation：控制事务传播行为（如是否复用父事务），默认REQUIRED；
isolation：设置事务隔离级别（解决并发问题），默认用数据库默认值；
rollbackFor&#x2F;noRollbackFor：指定需要 &#x2F; 不需要回滚的异常类型；
readOnly：标记只读事务（优化查询性能），默认false；
timeout：设置事务超时时间（防止长事务，单位秒），默认无限制。

BaseMapper、IService和ServiceImpl在典型的三层架构中：

Controller 层：接收请求、返回结果
Service 层：业务逻辑编排
DAO 层 (Mapper)：直接操作数据库

MyBatis-Plus 提供了 BaseMapper 简化了 DAO 层的 CRUD，而在 Service 层，通常需要编写一堆相似的增删改查逻辑。为此，MyBatis-Plus 提供了 IService 接口 + ServiceImpl 实现类，将通用逻辑抽象出来。
IService&lt;T&gt;   ←——  通用 Service 接口（定义通用方法）   ↑ServiceImpl&lt;M extends BaseMapper&lt;T&gt;, T&gt;   ←——  通用 Service 实现类   ↑自定义 Service 实现类（继承 ServiceImpl）

常见问题
必须继承 ServiceImpl 吗？


不是必须。你也可以只用 BaseMapper，在 Controller 里直接调用。但这样会让业务层缺失，代码耦合度较高，推荐通过 ServiceImpl 来隔离业务逻辑与持久化。


如果要写自定义方法怎么办？


直接在 Service 接口和实现类中新增即可


与 Mapper 的关系？


Mapper：最贴近数据库，负责 SQL 层
ServiceImpl：封装 Mapper，并为业务提供统一接口

最佳实践：
接口分离：定义 Service 接口，避免直接在 Controller 注入 ServiceImpl
扩展业务逻辑：在继承的 ServiceImpl 上增加自己的方法，不要随意修改通用方法
批量操作：使用 saveBatch、updateBatchById 提升性能
LambdaQueryWrapper：结合 ServiceImpl 的查询方法，写法更简洁安全

BaseMapper主要作用是定义 DAO 层的数据库操作方法，例如数据的增删改查等。
通过智能的SQL生成机制，只要继承并指定对应的实体类，即可直接使用这些通用方法，无需手动编写 SQL 语句，从而减少了代码量和重复劳动。
// 定义一个继承 BaseMapper 的自定义 Mapper 接口public interface XXXMapper extends BaseMapper&lt;xxx&gt; &#123;    // 无需手写SQL，Mybatis-Plus 根据命名规范自动生成SQL&#125;

IService将常见的业务操作抽象化，包括保存、删除、更新、查询等。通过继承 IService 接口，并指定对应的实体类，即可直接使用这些通用方法，无需手动编写业务逻辑代码，使得代码更加简洁和易于维护。
封装的方法分为七类：save、remove、update、get、list、count、page（分页查询）
// 定义一个继承 IService 的自定义 Service 接口public interface XXXService extends IService&lt;xxx&gt; &#123;    // 定义常用的业务逻辑方法&#125;

ServiceImpl是 IService 接口的默认实现。是针对业务逻辑层的实现，并调用 BaseMapper 来操作数据库。还额外赋予了一些更加高级的查询操作，如 lambdaQuery、page 等
//源码public class ServiceImpl&lt;M extends BaseMapper&lt;T&gt;, T&gt; implements IService&lt;T&gt; &#123;    @Autowired    protected M baseMapper;        //...方法&#125;

常见方法如下：

新增


save(T entity)
saveBatch(Collection entityList)
saveOrUpdate(T entity)


删除


removeById(Serializable id)
removeByIds(Collection&lt;? extends Serializable&gt; idList)
remove(Wrapper queryWrapper)


修改


updateById(T entity)
update(T entity, Wrapper updateWrapper)
updateBatchById(Collection entityList)


查询


getById(Serializable id)
listByIds(Collection&lt;? extends Serializable&gt; idList)
list(Wrapper queryWrapper)
page(Page page, Wrapper queryWrapper)
getOne(Wrapper queryWrapper)


统计与判断


count()
exists(Wrapper queryWrapper)

ServiceImpl 对事务管理提供了支持。通过 @Transactional 注解，能够轻松地实现事务的控制。
实践代码：
// 在业务逻辑实现中继承 ServiceImpl，轻松构建业务方法@Service@Transactionalpublic class XXXServiceImpl extends ServiceImpl&lt;M, T&gt; implements XXXService &#123;    ...&#125;

传入的参数为 M 和 T：

M：Mapper 接口类型
T：对应实体类的类型

Wrapper
不直接关联 Mapper 接口，需手动传递给 Mapper 方法执行查询。
需调用 Mapper 方法（如 selectList(wrapper)）
分两步：先构建条件，再调用 Mapper
运用于复杂逻辑（如条件复用、动态判断）

QueryWrapper查询构造器，通过链式调用，灵活直观地进行复杂SQL查询，而无需手动编写SQL语句。不直接关联 Mapper 接口，需手动传递给 Mapper 方法执行查询。
操作流程：

创建QueryWrapper实例QueryWrapper&lt;实体类（代表数据库中的一张表）&gt; wrapper = new QueryWrapper&lt;&gt;()
添加查询条件（方法），支持链式调用
eq：等于  ne：不等于
gt：大于  ge：大于等于
lt：小于  le：小于等于
(not)like(left/right)：模糊匹配 (not)between 区间
(not)in：(不)在某个集合中
and   or
nested - 嵌套条件
orderby 排序
select
last在 SQL 末尾追加自定义片段  apply添加动态SQL片段


执行查询构造好的QueryWrapper，通过传递给Mybatis-Plus的Mapper接口方法来执行查询。返回值  x = xxxMapper.xxx方法(wrapper)

QueryWrapper与其他Wrapper的区别
QueryWrapper：专注于构建 SELECT 查询的条件。

UpdateWrapper：用于构建 UPDATE 语句，支持条件和 SET 子句。（set）

LambdaQueryWrapper：QueryWrapper 的 Lambda 版本，使用 Lambda 表达式指定字段。
// 效果同QueryWrapper示例，但用Lambda引用字段LambdaQueryWrapper&lt;User&gt; lambdaQuery = new LambdaQueryWrapper&lt;&gt;();lambdaQuery.gt(User::getAge, 18)  // 用Lambda表达式引用字段，编译期检查           .like(User::getUsername, &quot;张&quot;);List&lt;User&gt; userList = userMapper.selectList(lambdaQuery);

LambdaUpdateWrapper：UpdateWrapper 的 Lambda 版本。
// 效果同UpdateWrapper示例，用Lambda引用字段LambdaUpdateWrapper&lt;User&gt; lambdaUpdate = new LambdaUpdateWrapper&lt;&gt;();lambdaUpdate.set(User::getAge, 20)            .set(User::getStatus, 1)            .eq(User::getId, 1)            .eq(User::getUsername, &quot;张三&quot;);userMapper.update(null, lambdaUpdate);

ChainWrapper
内置 Mapper，创建时绑定
自带执行方法（如 list()、update()）
链式调用，一步完成条件 + 执行
简单查询 &#x2F; 更新，追求代码简洁

QueryChainWrapperquery() 方法是 BaseMapper 接口提供的一个默认方法

快速创建 QueryChainWrapper 实例（自动绑定当前 Mapper）；
支持直接链式调用查询条件方法（eq、like 等）和执行方法（list、one 等）；
让代码更简洁，减少手动创建包装器的模板代码。

// 简化方式：通过 mapper.query() 获取 QueryChainWrapperList&lt;User&gt; users = userMapper.query()  // 直接获取链式查询包装器    .eq(&quot;status&quot;, 1)    .list();

query() 方法与 Service 层的结合
在 Service 实现类中（通常继承 ServiceImpl&lt;M extends BaseMapper&lt;T&gt;, T&gt;），调用 BaseMapper 提供的 query() 方法，获取 QueryChainWrapper&lt;User&gt; 实例，进一步简化代码。
User user=query().eq(&quot;phone&quot;,phone).one();

若不用链式查询，等价代码如下
QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();queryWrapper.eq(&quot;phone&quot;, phone);User user = userMapper.selectOne(queryWrapper); // 手动调用 Mapper 方法

QueryChainWrapper：

作用：用于构建查询条件（WHERE、ORDER BY 等），并直接执行查询操作（如查询列表、单条数据、数量等）。

核心方法：

条件方法：eq()（等于）、like()（模糊查询）、orderBy()（排序）等（与 QueryWrapper 一致）。
执行方法：list()（查询列表）、one()（查询单条）、count()（查询数量）等。


// 常规方法，链式查询：查询name为&quot;张三&quot;且age≥18的用户列表
List&lt;User&gt; users = new QueryChainWrapper&lt;&gt;(userMapper)
    .eq(&quot;name&quot;, &quot;张三&quot;)
    .ge(&quot;age&quot;, 18)
    .orderByDesc(&quot;create_time&quot;)
    .list(); // 直接执行查询
#### UpdateChainWrapper- **作用**：用于构建更新条件（`SET` 字段值 + `WHERE` 条件），并直接执行更新操作。- 核心方法：  - 字段方法：`set()`（设置更新字段）、`setSql()`（直接写 SQL 片段）等。  - 条件方法：`eq()`、`in()` 等（与 `UpdateWrapper` 一致）。  - 执行方法：`update()`（执行更新）。- ```java  // 链式更新：将name为&quot;张三&quot;的用户age改为20  boolean success = new UpdateChainWrapper&lt;&gt;(userMapper)      .set(&quot;age&quot;, 20)      .eq(&quot;name&quot;, &quot;张三&quot;)      .update(); // 直接执行更新



ThreadLocal在 Tomcat 处理 HTTP 请求的流程中，每个用户请求都会由 Tomcat 线程池中的「独立线程」处理（线程从池内取出 → 处理请求 → 用完回收）。由于不同用户的请求由不同线程执行，且线程会经过 Controller、Service、DAO 等多层组件调用，此时需要一种机制，让 “当前请求的专属数据” 能在线程内的各组件间共享，同时又不与其他线程的请求数据冲突 —— 这正是 ThreadLocal 的核心价值。
ThreadLocal的作用与适配性：
ThreadLocal 的原理是 为每个线程维护一份「独立的变量副本」：
当 Tomcat 的工作线程开始处理请求时，会把「当前请求的上下文数据」（比如用户身份信息、事务管理器、自定义的请求作用域数据等）存入 ThreadLocal；
之后，在该线程执行过程中（从 Controller 接收参数，到 Service 处理业务，再到 DAO 操作数据库），所有组件都能从 ThreadLocal 中获取 “当前请求专属” 的数据，且不会与其他线程（其他用户的请求）的数据产生冲突。
总结：
因为 “每个用户请求对应独立线程” 的特性，ThreadLocal 能让每个线程只操作自己的那份数据，既保证了 “同一请求内多组件共享数据”，又天然实现了 “线程隔离”，完美适配 Web 应用中 “请求 - 线程 - 多组件协作” 的场景。
拦截器HandlerInterceptorSpring MVC 的 HandlerInterceptor 是贯彻 AOP 思想、用于拦截 Spring MVC 请求的核心组件，仅作用于 Spring MVC 处理的请求，生命周期由 Spring 管理，可在请求到 Controller 前、Controller 执行后、视图渲染完成后三个阶段插入自定义逻辑，实现权限验证、日志记录、资源清理等横切需求。
其核心有 3 个方法：

preHandle（正序执行）：请求前置处理，返回true则继续请求，false则中断，常用于登录校验；
postHandle（逆序执行）：Controller 执行后、视图渲染前处理，可修改ModelAndView，如加全局数据；
afterCompletion（逆序执行）：请求全流程结束后执行（无论成败），用于资源清理，如关连接、清ThreadLocal。

拦截器通过HandlerExecutionChain封装成链，执行规则为 “preHandle 正序、后两个方法逆序”；与 Servlet Filter 相比，它对 Spring MVC 请求控制更精细，配置依赖WebMvcConfigurer，还可通过Ordered&#x2F;@Order排序、MappedInterceptor动态匹配路径，优化时需避免耗时操作、控制作用范围。
要使拦截器生效，需要配置拦截器需要在实现了WebMvcConfigurer的配置类（@Configuration），编写addInterceptors(InterceptroRegistry registry)方法，使用注册器registry通过addInterceptor方法来配置拦截路径。
import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;// 拦截器配置类（@Configuration 标记为Spring配置类）@Configurationpublic class MvcInterceptorConfig implements WebMvcConfigurer &#123;    /**     * 注册拦截器，并配置拦截/排除路径     */    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        // 1. 注册自定义的LoginInterceptor        registry.addInterceptor(new LoginInterceptor())                // 2. 配置「需要拦截」的路径（Ant风格，/** 表示所有请求）                .addPathPatterns(&quot;/**&quot;)                 // 3. 配置「不需要拦截」的路径（排除登录、静态资源等）                .excludePathPatterns(                        &quot;/login&quot;,          // 登录接口（未登录时需访问，不拦截）                        &quot;/register&quot;,       // 注册接口（同理不拦截）                        &quot;/static/**&quot;,      // 静态资源（CSS、JS、图片等，不拦截）                        &quot;/error&quot;           // 错误页面（如404、500，不拦截）                );    &#125;&#125;

若需注册多个拦截器（如 “登录拦截器”+“日志拦截器”），可在 addInterceptors 中多次调用
使用Hutool工具类进行对象属性拷贝Hutool 提供了 BeanUtil 和 CollUtil 工具类，可简洁实现实体类对象及 List 集合的属性拷贝（相同属性值复制），无需手动编写 set&#x2F;get 代码。
以下是具体实现方式：

实体类对象拷贝（单个对象）
使用 BeanUtil.copyProperties 方法，自动复制两个对象间名称和类型相同的属性。

List 集合拷贝（批量对象）
通过 BeanUtil.copyProperties 结合流处理，批量拷贝集合中所有对象的属性。


拷贝规则：

仅复制名称和类型均相同的属性（类型需兼容，如 int 与 Integer 可互转）。
目标对象中独有的属性（如 UserDTO 的 extra）会被忽略，源对象中独有的属性也不会影响目标对象。

注意事项：

若属性名不同，可通过 BeanUtil.copyProperties 的重载方法自定义映射规则（如 CopyOptions）。

隐藏用户信息前后端数据交互的标准最佳实践：
通过DTO对象类进行前后端传递数据。entity类负责跟数据库交换数据。

Entity 类（与数据库交互，含敏感字段）
DTO 类（前后端传输，隐藏敏感信息）

代码实现发送验证码IUserService声明，UserServiceImpl实现
@Overridepublic Result sendCode(String phone, HttpSession session) &#123;    // 1.校验手机号    if (RegexUtils.isPhoneInvalid(phone)) &#123;        // 2.如果不符合，返回错误信息        return Result.fail(&quot;手机号格式错误！&quot;);    &#125;    // 3.符合，生成验证码    String code = RandomUtil.randomNumbers(6);    // 4.保存验证码到 session    session.setAttribute(&quot;code&quot;,code);    // 5.发送验证码    log.debug(&quot;发送短信验证码成功，验证码：&#123;&#125;&quot;, code);    // 返回ok    return Result.ok();&#125;

登录 @Override   public Result login(LoginFormDTO loginForm, HttpSession session) &#123;       // 1.校验手机号       String phone = loginForm.getPhone();       if (RegexUtils.isPhoneInvalid(phone)) &#123;           // 2.如果不符合，返回错误信息           return Result.fail(&quot;手机号格式错误！&quot;);       &#125;       // 3.校验验证码       Object cacheCode = session.getAttribute(&quot;code&quot;);       String code = loginForm.getCode();       if(cacheCode == null || !cacheCode.toString().equals(code))&#123;           //3.不一致，报错           return Result.fail(&quot;验证码错误&quot;);       &#125;       // 4.验证码一致，查询用户       User user=query().eq(&quot;phone&quot;,phone).one();       if(user == null)&#123;           // 5.用户不存在，创建           user =  createUserWithPhone(phone);       &#125;       //6.保护用户信息到session       session.setAttribute(&quot;user&quot;,user);       //7.返回ok       return Result.ok();   &#125;   private User createUserWithPhone(String phone) &#123;       User user = new User();       user.setPhone(phone);       return user;&#125;

登录校验拦截器拦截器代码，在utils包下创建
public class LoginInterceptor implements HandlerInterceptor &#123;    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;    &#125;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        //1.获取session        HttpSession session = request.getSession();        //2.获取session中的用户        Object user = session.getAttribute(&quot;user&quot;);        //3.判断用户是否存在        if(user != null) &#123;            //4.不存在就拦截，返回401状态码            response.setStatus(401);            return false;        &#125;        //5.存在,保存用户信息到ThreadLocal        UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class);        UserHolder.saveUser(userDTO);        //6.放行        return true;    &#125;&#125;

添加拦截器，配置类
public class MvcConfig implements WebMvcConfigurer &#123;    @Resource    private StringRedisTemplate stringRedisTemplate;    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        // 登录拦截器        registry.addInterceptor(new LoginInterceptor())                .excludePathPatterns(                        &quot;/shop/**&quot;,                        &quot;/voucher/**&quot;,                        &quot;/shop-type/**&quot;,                        &quot;/upload/**&quot;,                        &quot;/blog/hot&quot;,                        &quot;/user/code&quot;,                        &quot;/user/login&quot;                ).order(1);    &#125;&#125;

]]></content>
      <categories>
        <category>黑马点评</category>
      </categories>
  </entry>
  <entry>
    <title>04-商户查询缓存</title>
    <url>/2025/10/12/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/04-%E5%95%86%E6%88%B7%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[缓存的目的
缓存的作用：一方面能降低后端（如数据库、服务器等）的负载；另一方面可提高读写效率，减少系统的响应时间。
缓存的成本：会产生数据一致性方面的代价，还需要付出代码维护成本以及运维成本。

我们要怎么做
例如：Mybatis提供的IService接口类中的getById方法只是简单的return getBaseMapper().selectById(id)，等于直接走数据库。要添加缓存功能，我们就要在实现类UserServiceImpl中添加Redis缓存
缓存更新策略
Redis 缓存更新的核心目的：解决内存宝贵问题，避免缓存数据过多，主要靠三大机制 ——
内存淘汰：内存达max-memory时，Redis 自动按策略删 “不重要” 数据；
超时剔除：数据到 TTL 后，Redis 自动删过期数据；
主动更新：手动删缓存，核心用来解决 “缓存与数据库不一致”。


数据库缓存不一致的核心解法：优先选 Cache Aside Pattern（人工编码方案），其他方案（系统自动处理、异步同步）因灵活性 &#x2F; 适用场景限制，非首选。
Cache Aside Pattern 的标准操作（关键！）：
不更缓存，只删缓存：避免无效写操作，查询时再重新加载新数据到缓存；
先更数据库，再删缓存：规避并发下 “旧数据覆盖新数据” 的风险；
保证原子性：单体系统用事务，分布式系统用 TCC 等分布式事务方案，确保 “更库 + 删缓存” 要么都成、要么都败。



最终标准流程：更新数据库 → 删除对应缓存（查询时自动加载新数据到缓存），这是平衡一致性、性能的最优实践。
缓存穿透一、缓存穿透的定义
客户端请求的数据在缓存（Redis）和数据库中都不存在，导致缓存永远无法命中，所有请求直接冲击数据库，易造成数据库压力过载。
二、两种核心解决方案对比



方案类型
原理
优点
缺点



缓存空对象
数据库查询无结果时，在 Redis 中缓存一个空值（并设置短期 TTL），后续请求由 Redis 拦截。
实现简单，开发 &#x2F; 维护成本低
1. 占用 Redis 额外内存（存大量空值）；2. 数据库新增数据时，Redis 空值过期前会导致短期数据不一致。


布隆过滤器
用二进制数组 + 多哈希函数，预先标记 “数据库中存在的数据”。请求先经布隆过滤器判断：- 若 “不存在”，直接拒绝；- 若 “可能存在”，再查 Redis &#x2F; 数据库。
内存占用少，无空值冗余
1. 实现复杂（需维护布隆过滤器结构）；2. 存在误判可能（哈希冲突导致 “不存在的数据被误判为存在”）。


三、方案选择建议

若业务数据空值场景少、对实现复杂度敏感，选「缓存空对象」；
若业务空值请求极多、对内存占用敏感，选「布隆过滤器」（需接受一定误判风险）。

核心目标：拦截 “无效请求”，避免其持续冲击数据库。
缓存雪崩一、缓存雪崩的定义
在同一时段内，大量缓存 Key 同时失效，或Redis 服务宕机，导致大量请求直接穿透缓存层，冲击数据库，造成数据库压力骤增甚至崩溃。
二、核心解决方案



方案类型
原理与作用



给 Key 的 TTL 添加随机值
为不同 Key 的过期时间引入随机波动，避免大量 Key “集体过期”，分散缓存失效的时间点，减少集中请求数据库的风险。


利用 Redis 集群提高可用性
通过 Redis 主从、哨兵、Cluster 等集群模式，避免单点 Redis 宕机导致整个缓存层失效，提升缓存服务的稳定性。


缓存业务添加降级限流策略
当缓存层（Redis）异常时，对请求进行降级（如返回默认值、跳过缓存直接走降级逻辑）或限流（限制并发请求数），减少对数据库的冲击。


业务添加多级缓存
引入 “本地缓存（如 Guava Cache）+ Redis” 等多级缓存架构，即使 Redis 层异常，本地缓存仍可拦截部分请求，进一步隔离数据库。


核心目标：通过分散缓存失效时间、提升缓存服务可靠性、流量控制、多级缓存隔离，避免数据库被 “突发的大量请求” 压垮。
缓存击穿一、问题定义
当一个被高并发访问、且缓存重建逻辑复杂的 Key 突然失效时，大量请求会瞬间穿透缓存，直接冲击数据库，导致数据库压力骤增。
二、两种核心解决方案



方案类型
原理
优点
缺点



互斥锁
缓存未命中时，通过互斥锁保证 “同一时间只有一个线程” 去查询数据库、重建缓存；其他线程获取锁失败后，等待重试。
① 保证数据一致性（只有一个线程操作数据库 &#x2F; 缓存）；② 实现简单；③ 无额外内存消耗。
① 线程需等待（串行执行），性能受影响；② 存在死锁风险。


逻辑过期
不依赖 Redis 的 TTL，而是在缓存 Value 中嵌入 “逻辑过期时间”。当检测到逻辑过期时：- 获锁线程异步开新线程重建缓存（重置逻辑过期时间），当前线程直接返回旧数据；- 其他线程获锁失败，直接返回旧数据。
线程无需等待，高并发下响应性能好。
① 无法保证强一致性（重建期间返回旧数据）；② 需额外存储逻辑过期时间，有内存消耗；③ 实现逻辑更复杂。


三、方案选择建议

若业务对数据一致性要求高、能接受一定性能损耗，选「互斥锁」；
若业务对响应性能要求极高、可接受短期数据不一致，选「逻辑过期」。

核心目标：避免高并发下 “大量线程同时查库” 的风险，平衡一致性与性能。
Java线程池Executor&#x2F;ExecutorService在 Java 并发编程中，Executor和ExecutorService是线程池框架的核心接口，它们简化了线程的创建、管理和任务执行流程，避免了频繁创建线程带来的性能开销。
一、基本概念1. Executor（顶层接口）Executor是 Java 并发框架中最基础的接口，定义了任务执行的基本规范。它的核心思想是将 “任务提交” 与 “任务执行” 解耦 —— 用户只需提交任务，无需关心任务如何被线程执行、使用哪个线程执行、何时执行等细节。
定义：
public interface Executor &#123;    void execute(Runnable command);&#125;

Executor接口仅包含一个方法execute(Runnable)，用于提交一个Runnable任务并执行。
2. ExecutorService（子接口）ExecutorService是Executor的子接口，它在Executor的基础上扩展了更多功能，尤其是对线程池生命周期的管理和带返回值的任务支持。
ExecutorService不仅能执行任务，还能：

管理线程池的关闭（如优雅关闭、强制关闭）；
提交带返回值的任务（Callable）；
批量执行任务并获取结果；
等待任务执行完成。

二、常用方法1. Executor 的核心方法Executor接口仅定义了一个方法：

void execute(Runnable command)
作用：提交一个Runnable任务到线程池执行。
特点：无返回值，无法获取任务执行结果；若任务执行中抛出异常，异常会被线程池内部消化（不会主动抛出）。


2. ExecutorService 的常用方法ExecutorService扩展了Executor，提供了更丰富的方法，主要分为任务提交、线程池关闭、任务结果获取三类：
（1）任务提交相关
Future&lt;?&gt; submit(Runnable task)
作用：提交一个Runnable任务，返回一个Future对象。
特点：Future的get()方法会在任务完成后返回null，可通过isDone()判断任务是否完成。

&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result)
作用：提交Runnable任务，指定一个结果对象；任务完成后，Future.get()会返回该结果对象。

&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)
作用：提交一个Callable&lt;T&gt;任务（带返回值的任务），返回Future&lt;T&gt;对象。
特点：Callable的call()方法有返回值且可抛出异常，通过Future.get()可获取返回值或捕获异常。


（2）线程池关闭相关线程池创建后默认是运行状态，需主动关闭以释放资源：

void shutdown()
作用：优雅关闭线程池。
行为：不再接收新任务，但会等待已提交的任务（包括正在执行和队列中等待的）全部执行完成后关闭。

List&lt;Runnable&gt; shutdownNow()
作用：强制关闭线程池。
行为：立即尝试停止所有正在执行的任务，暂停处理队列中等待的任务，并返回未执行的任务列表。

boolean isShutdown()
作用：判断线程池是否已调用shutdown()或shutdownNow()（即是否进入关闭流程）。

boolean isTerminated()
作用：判断线程池是否已完全终止（所有任务执行完毕，资源已释放）。

boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException
作用：阻塞当前线程，等待线程池终止（最多等待指定时间）。
返回值：若线程池在超时前完全终止，返回true；否则返回false。


（3）批量任务执行相关
List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException
作用：提交多个Callable任务，等待所有任务完成后，返回包含所有任务结果的Future列表。

List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException
作用：同上，但最多等待指定时间，超时未完成的任务会被取消。

T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException, ExecutionException
作用：提交多个Callable任务，只要有一个任务成功完成，就返回该任务的结果，其他未完成的任务会被取消。


三、总结
Executor是最基础的接口，仅定义了execute()方法，用于提交无返回值的任务。
ExecutorService是Executor的扩展，增加了任务生命周期管理、带返回值任务支持等功能，是实际开发中使用的主要接口（常用实现类如ThreadPoolExecutor）。

使用时，通常通过Executors工具类创建ExecutorService实例（如Executors.newFixedThreadPool(5)），再通过其方法提交任务和管理线程池。
函数式编程Java 从 JDK 8 开始引入函数式编程特性，其设计理念是在保持面向对象核心的基础上，融入函数式编程的思想（如函数作为参数传递、强调不可变性等），主要通过 Lambda 表达式、函数式接口、Stream API 等特性实现。
一、基本概念1. 函数式接口（Functional Interface）函数式接口是 Java 函数式编程的基础，它是只包含一个抽象方法的接口（可以包含默认方法和静态方法）。
作用：为 Lambda 表达式 提供类型约束，Lambda 表达式本质上是函数式接口的匿名实现。
JDK 中用 @FunctionalInterface 注解标记函数式接口（非强制，但会在编译时校验接口是否符合规范）。
示例：
// 自定义函数式接口@FunctionalInterfaceinterface Calculator &#123;    int calculate(int a, int b); // 唯一抽象方法        // 允许包含默认方法    default void printResult(int result) &#123;        System.out.println(&quot;结果：&quot; + result);    &#125;&#125;

JDK 内置了大量常用函数式接口（如 java.util.function 包下的 Function、Predicate 等），避免重复定义。
2. Lambda 表达式Lambda 表达式是简洁表示匿名函数的语法，可以理解为 “可传递的代码块”，用于简化函数式接口的实现。
语法：(参数列表) -&gt; &#123; 方法体 &#125;

若参数列表只有一个参数，可省略括号（如 x -&gt; x*2）；
若方法体只有一行代码，可省略大括号和 return（如 (a,b) -&gt; a + b）。

示例：用 Lambda 实现函数式接口
// 用 Lambda 表达式实现 Calculator 接口Calculator add = (a, b) -&gt; a + b;add.printResult(add.calculate(2, 3)); // 输出：结果：5Calculator multiply = (a, b) -&gt; a * b;multiply.printResult(multiply.calculate(2, 3)); // 输出：结果：6

Lambda 表达式的类型由上下文推断（即它所赋值的函数式接口类型），因此必须与函数式接口的抽象方法签名匹配。
3. 方法引用（Method Reference）方法引用是 Lambda 表达式的简化形式，当 Lambda 表达式只是调用一个已存在的方法时，可直接引用该方法，使代码更简洁。
语法：类名::方法名 或 对象::方法名，分为 4 种类型：



类型
示例
说明



静态方法引用
Integer::parseInt
引用类的静态方法


实例方法引用（对象）
str::toUpperCase
引用特定对象的实例方法


实例方法引用（类）
String::length
引用类的任意对象的实例方法


构造方法引用
ArrayList::new
引用类的构造方法


示例：
import java.util.Arrays;import java.util.List;public class Main &#123;    public static void main(String[] args) &#123;        List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);                // 用 Lambda 表达式遍历        list.forEach(s -&gt; System.out.println(s));                // 用方法引用简化（引用 System.out 的 println 方法）        list.forEach(System.out::println);    &#125;&#125;

4. 不可变性（Immutability）函数式编程强调 “数据不可变”，即数据创建后不被修改，任何修改都会生成新的数据副本。
Java 中可通过以下方式实现不可变性：

使用 final 修饰变量（基本类型值不可变，引用类型引用不可变）；
使用不可变集合（如 Collections.unmodifiableList() 或 Guava 的不可变集合）；
Stream API 操作不会修改原集合，而是返回新的流。

二、常用组件与方法1. 常用函数式接口（java.util.function 包）JDK 内置了一系列函数式接口，覆盖常见场景，避免重复定义：



接口
抽象方法
功能描述
示例



Predicate&lt;T&gt;
boolean test(T t)
接收 T 类型参数，返回布尔值（判断）
t -&gt; t &gt; 10（判断是否大于 10）


Function&lt;T,R&gt;
R apply(T t)
接收 T 类型参数，返回 R 类型结果（转换）
s -&gt; s.length()（字符串转长度）


Consumer&lt;T&gt;
void accept(T t)
接收 T 类型参数，无返回值（消费）
s -&gt; System.out.println(s)


Supplier&lt;T&gt;
T get()
无参数，返回 T 类型结果（提供）
() -&gt; new ArrayList&lt;&gt;()


UnaryOperator&lt;T&gt;
T apply(T t)
接收 T 类型参数，返回 T 类型结果（一元运算）
x -&gt; x * 2（乘以 2）


BinaryOperator&lt;T&gt;
T apply(T a, T b)
接收两个 T 类型参数，返回 T 类型结果（二元运算）
(a,b) -&gt; a + b（求和）


2. Stream API（核心工具）Stream 是 Java 函数式编程的核心工具，用于对集合进行高效的函数式操作（如过滤、转换、聚合等）。它不是数据结构，而是对数据的 “计算管道”，具有惰性求值（中间操作仅记录，终端操作才执行）和一次性消费（流只能被处理一次）的特点。
Stream 操作流程：
数据源（集合/数组）→ 中间操作（过滤/转换）→ 终端操作（聚合/收集）

（1）中间操作（返回新的 Stream，可链式调用）
filter(Predicate&lt;T&gt; p)：过滤符合条件的元素
List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5);numbers.stream()       .filter(n -&gt; n % 2 == 0) // 筛选偶数       .forEach(System.out::println); // 输出：2 4

map(Function&lt;T,R&gt; f)：将元素转换为另一种类型
List&lt;String&gt; words = Arrays.asList(&quot;a&quot;, &quot;bb&quot;, &quot;ccc&quot;);words.stream()     .map(String::length) // 转换为字符串长度     .forEach(System.out::println); // 输出：1 2 3

flatMap(Function&lt;T,Stream&lt;R&gt;&gt; f)：将元素转换为流后 “扁平化”（合并多个流）
List&lt;List&lt;Integer&gt;&gt; lists = Arrays.asList(    Arrays.asList(1, 2),     Arrays.asList(3, 4));lists.stream()     .flatMap(List::stream) // 转换为单个流 [1,2,3,4]     .forEach(System.out::println);

sorted() &#x2F; sorted(Comparator&lt;T&gt; c)：排序
numbers.stream()       .sorted((a, b) -&gt; b - a) // 降序排序       .forEach(System.out::println); // 输出：5 4 3 2 1

（2）终端操作（触发计算，返回非 Stream 结果）
forEach(Consumer&lt;T&gt; c)：遍历元素
numbers.stream().forEach(n -&gt; System.out.print(n + &quot; &quot;)); // 输出：1 2 3 4 5

collect(Collector&lt;T,A,R&gt; c)：将流收集为集合（如 List、Set、Map）
import java.util.stream.Collectors;// 收集为 ListList&lt;Integer&gt; evenList = numbers.stream()                                .filter(n -&gt; n % 2 == 0)                                .collect(Collectors.toList()); // 结果：[2,4]

reduce(BinaryOperator&lt;T&gt; op)：将元素聚合为单个值（如求和、求积）
// 求和（初始值为0，累加每个元素）int sum = numbers.stream()                 .reduce(0, Integer::sum); // 结果：15

count()：统计元素数量
long evenCount = numbers.stream()                        .filter(n -&gt; n % 2 == 0)                        .count(); // 结果：2

anyMatch(Predicate&lt;T&gt; p) &#x2F; allMatch(Predicate&lt;T&gt; p)：判断是否存在 &#x2F; 全部符合条件的元素
boolean hasEven = numbers.stream().anyMatch(n -&gt; n % 2 == 0); // trueboolean allEven = numbers.stream().allMatch(n -&gt; n % 2 == 0); // false

3. Optional 类Optional&lt;T&gt; 是一个容器类，用于优雅处理空指针问题，避免显式的 null 判断，是函数式编程中处理可能缺失值的常用工具。
常用方法：

Optional.of(T value)：创建包含非 null 值的 Optional（值为 null 则抛异常）；
Optional.ofNullable(T value)：创建可能包含 null 值的 Optional；
isPresent()：判断是否有值；
ifPresent(Consumer&lt;T&gt; c)：若有值则执行消费函数；
orElse(T other)：若为空则返回默认值；
map(Function&lt;T,R&gt; f)：转换 Optional 中的值。

示例：
import java.util.Optional;public class Main &#123;    public static void main(String[] args) &#123;        String str = &quot;hello&quot;;        Optional&lt;String&gt; optional = Optional.ofNullable(str);                // 若有值则转为大写并打印        optional.map(String::toUpperCase)                .ifPresent(System.out::println); // 输出：HELLO                // 若为空则返回默认值        String result = Optional.ofNullable(null)                                .orElse(&quot;default&quot;); // 结果：&quot;default&quot;    &#125;&#125;

三、总结Java 函数式编程的核心是通过 Lambda 表达式和函数式接口将函数作为参数传递，并结合 Stream API 实现对集合的声明式处理。其优势在于：

代码更简洁（减少匿名类模板代码）；
逻辑更清晰（专注 “做什么” 而非 “怎么做”）；
易于并行处理（Stream 可通过 parallelStream() 实现并行操作）。

实际开发中，函数式编程通常与面向对象编程结合使用，例如用 Stream 处理集合数据，用 Optional 避免空指针，用方法引用简化代码，从而提高开发效率和代码可读性。
代码实操1.根据id查询商户并实现缓存ShopServiceImpl类
@Servicepublic class ShopServiceImpl extends ServiceImpl&lt;ShopMapper, Shop&gt; implements IShopService &#123;    @Resource    private StringRedisTemplate stringRedisTemplate;    @Override    public Result queryById(Long id) &#123;        String Key=CACHE_SHOP_KEY+id;        // 1.从redis查询商铺缓存        String shopJson=stringRedisTemplate.opsForValue().get(Key);        //2.判断是否存在        if(StrUtil.isNotBlank(shopJson))&#123;            // 3.存在直接返回            Shop shop= JSONUtil.toBean(shopJson, Shop.class);            return Result.ok(shop);        &#125;        // 4.不存在，根据id查询数据库        Shop shop = getById( id);        // 5.数据库不存在，返回错误        if(shop==null)&#123;            return Result.fail(&quot;店铺不存在&quot;);        &#125;        //6.存在，写入redis        stringRedisTemplate.opsForValue().set(Key,JSONUtil.toJsonStr(shop));        return Result.ok(shop);    &#125;&#125;

2.给商铺类型实现缓存ShopTypeServiceImpl类
@Servicepublic class ShopTypeServiceImpl extends ServiceImpl&lt;ShopTypeMapper, ShopType&gt; implements IShopTypeService &#123;    @Resource    private StringRedisTemplate stringRedisTemplate;    @Override    public Result queryTypeList() &#123;        String key = &quot;cache:shop_type_list&quot;;        // 1. 先尝试从Redis中获取        String json = stringRedisTemplate.opsForValue().get(key);        if (json != null) &#123;            // Redis中存在数据，直接返回            List&lt;ShopType&gt; typeList = JSONUtil.toList(json, ShopType.class);            return Result.ok(typeList);        &#125;        // 2. Redis中不存在，查询数据库        List&lt;ShopType&gt; typeList = query().orderByAsc(&quot;sort&quot;).list();        // 3. 将数据保存在Redis中        if (!typeList.isEmpty()) &#123;            String jsonStr = JSONUtil.toJsonStr(typeList);            stringRedisTemplate.opsForValue().set(key, jsonStr);            // 可以设置过期时间，例如30分钟             stringRedisTemplate.opsForValue().set(key, jsonStr, 30, TimeUnit.MINUTES);        &#125;        // 4. 将数据返回给前端        return Result.ok(typeList);    &#125;&#125;

3.实现商铺和缓存与数据库双写一致
据id查询店铺时，如果缓存未命中，则查询数据库，将数据库结果写入缓存，并设置超时时间

根据id修改店铺时，先修改数据库，再删除缓存


修改ShopServiceImpl的queryById方法，设置redis缓存时添加过期时间
//设置redis缓存时添加过期时间stringRedisTemplate.opsForValue().set(Key,JSONUtil.toJsonStr(shop),CACHE_SHOP_TTL, TimeUnit.MINUTES);

Controller层的updateShop接口中调用service中的update方法采用删除策略，来解决双写问题，当我们修改了数据之后，然后把缓存中的数据进行删除，查询时发现缓存中没有数据，则会从mysql中加载最新的数据，从而避免数据库和缓存不一致的问题
@Overridepublic Result update(Shop shop) &#123;    Long id=shop.getId();    if(id==null)&#123;        return Result.fail(&quot;店铺id不能为空&quot;);    &#125;    //1.更新数据库    updateById(shop);    //2.删除缓存 stringRedisTemplate.delete(CACHE_SHOP_KEY+id);        return Result.ok();    &#125;&#125;

4.编码解决商品查询的缓存穿透问题改良ShopServiceImpI中的queryById方法

添加判断命中是否空值；
添加若不存在shop信息，则将空值写入Redis。

@Override public Result queryById(Long id) &#123;     String Key=CACHE_SHOP_KEY+id;     // 1.从redis查询商铺缓存     String shopJson=stringRedisTemplate.opsForValue().get(Key);     //2.判断是否存在     if(StrUtil.isNotBlank(shopJson))&#123;         // 3.存在直接返回         Shop shop= JSONUtil.toBean(shopJson, Shop.class);         return Result.ok(shop);     &#125;     /*  内容：添加判断命中的是否空值         时间： 2025/9/24 00:18 */      if(shopJson!=null)&#123;          //返回一个错误信息          return Result.fail(&quot;店铺不存在&quot;);      &#125;     // 4.不存在，根据id查询数据库     Shop shop = getById( id);     // 5.数据库不存在，返回错误     if(shop==null)&#123;         /*  内容：将空值写入Redis             时间： 2025/9/24 00:20 */          stringRedisTemplate.opsForValue().set(Key,&quot;&quot;,CACHE_NULL_TTL,TimeUnit.MINUTES);         return Result.fail(&quot;店铺不存在&quot;);     &#125;     //6.存在，写入redis     //设置redis缓存时添加过期时间     stringRedisTemplate.opsForValue().set(Key,JSONUtil.toJsonStr(shop),CACHE_SHOP_TTL, TimeUnit.MINUTES);     return Result.ok(shop); &#125;

5.缓存雪崩问题及解决
添加随机数生成器：
在文件中导入了java.util.Random类用于生成随机数

为正常缓存添加随机过期时间：
将原来的固定过期时间CACHE_SHOP_TTL修改CACHE_SHOP_TTL + random.nextInt(10)，这样每个店铺缓存的过期时间会在原有基础上随机增加0-9分钟，避免大量缓存在同一时间过期

为空值缓存也添加随机过期时间：
将原来用于解决缓存穿透的空值缓存过期时CACHE_NULL_TT，修改为CACHE_NULL_TTL + random.nextInt(5)，这样空值缓存也会有随机的过期时间，进一步分散过期时间点


6.缓存击穿问题及解决6.1利用互斥锁解决缓存击穿问题利用Redis中的setnx命令来实现互斥锁。释放锁通过del命令来 删除
在SpringDataRedis中是setIfAbsent
private boolean tryLock(String key)&#123;        Boolean flag=stringRedisTemplate.opsForValue().setIfAbsent(key, &quot;1&quot;, 10, TimeUnit.SECONDS);        return BooleanUtil.isTrue(flag);    &#125;private void unLock(String key)&#123;        stringRedisTemplate.delete(key);    &#125;

定义queryWithMutex方法
public Shop queryWithMutex(Long id) &#123;        String Key=CACHE_SHOP_KEY+id;        // 1.从redis查询商铺缓存        String shopJson=stringRedisTemplate.opsForValue().get(Key);        //2.判断缓存是否命中        //isNotBlank用于判断字符串是否‌不为空且不全是空白字符‌的方法        if(StrUtil.isNotBlank(shopJson))&#123;            // 3.存在直接返回            return JSONUtil.toBean(shopJson, Shop.class);        &#125;        //判断命中的值是否是空值        if (shopJson != null) &#123;            //是空值，则返回一个错误信息            return null;        &#125;        //4.未命中则尝试获取互斥锁        String lockKey=LOCK_SHOP_KEY+id;        Shop shop = null;        try &#123;            boolean isLock=tryLock(lockKey);            //判断是否成功获取            if(!isLock)&#123;                //失败，则休眠重试                Thread.sleep(50);                return queryWithMutex(id);            &#125;            //5.成功，根据id查询数据库            shop=getById(id);            if(shop==null)&#123;                //不存在，将空值写入Redis                stringRedisTemplate.opsForValue().set(Key,&quot;&quot;,CACHE_NULL_TTL,TimeUnit.MINUTES);                //返回错误信息                return null;            &#125;        //6.写入Redis        //设置redis缓存时添加过期时间，增加随机值防止缓存雪崩        Random random = new Random();        long randomTTL = CACHE_SHOP_TTL + random.nextInt(10);        stringRedisTemplate.opsForValue().set(Key,JSONUtil.toJsonStr(shop),randomTTL, TimeUnit.MINUTES);        &#125; catch (InterruptedException e) &#123;            throw new RuntimeException(e);        &#125;finally &#123;            //7.释放锁            unLock(lockKey);        &#125;        //8.返回        return shop;    &#125;

6.2利用逻辑过期解决缓存击穿问题用到了线程池
//缓存预热    @Override    public void saveShop2Redis(Long id, Long expireSeconds) &#123;        //1.查询店铺数据        Shop shop = getById(id);        //2.封装逻辑过期时间        RedisData redisData = new RedisData();        redisData.setData(shop);        redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSeconds));        //3.写入Redis        stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY+id,JSONUtil.toJsonStr(redisData));    &#125;    //线程池    private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);    //逻辑过期解决缓存击穿    public Shop queryWithLogicalExpire( Long id ) &#123;        String key = CACHE_SHOP_KEY + id;        // 1.从redis查询商铺缓存        String json = stringRedisTemplate.opsForValue().get(key);        // 2.判断是否存在        if (StrUtil.isBlank(json)) &#123;            // 3.不存在，直接返回            return null;        &#125;        // 4.命中，需要先把json反序列化为对象        RedisData redisData = JSONUtil.toBean(json, RedisData.class);        Shop shop = JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class);        LocalDateTime expireTime = redisData.getExpireTime();        // 5.判断是否过期        if(expireTime.isAfter(LocalDateTime.now())) &#123;            // 5.1.未过期，直接返回店铺信息            return shop;        &#125;        // 5.2.已过期，需要缓存重建        // 6.缓存重建        // 6.1.获取互斥锁        String lockKey = LOCK_SHOP_KEY + id;        boolean isLock = tryLock(lockKey);        // 6.2.判断是否获取锁成功        if (isLock)&#123;            CACHE_REBUILD_EXECUTOR.submit( ()-&gt;&#123;                try&#123;                    //重建缓存                    this.saveShop2Redis(id,20L);                &#125;catch (Exception e)&#123;                    throw new RuntimeException(e);                &#125;finally &#123;                    unLock(lockKey);                &#125;            &#125;);        &#125;        // 6.4.返回过期的商铺信息        return shop;    &#125;

封装Redis工具类一、代码基于StringRedisTemplate封装一个缓存工具类，满足下列需求：

方法1：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置TTL过期时间

方法2：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置逻辑过期时间，用于处理缓存击穿问题

方法3：根据指定的key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题

方法4：根据指定的key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题


含有逻辑时间的类
@Datapublic class RedisData &#123;    private LocalDateTime expireTime;    private Object data;&#125;

将逻辑进行封装
@Slf4j@Componentpublic class CacheClient &#123;private final StringRedisTemplate stringRedisTemplate;private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);public CacheClient(StringRedisTemplate stringRedisTemplate) &#123;    this.stringRedisTemplate = stringRedisTemplate;&#125;//方法1：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置TTL过期时间public void set(String key, Object value, Long time, TimeUnit unit) &#123;    stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);&#125;//方法2：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置逻辑过期时间，用于处理缓存击穿问题public void setWithLogicalExpire(String key, Object value, Long time, TimeUnit unit) &#123;    // 设置逻辑过期    RedisData redisData = new RedisData();    redisData.setData(value);    redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));    // 写入Redis    stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));&#125;//方法3：根据指定的key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题public &lt;R,ID&gt; R queryWithPassThrough(        String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)&#123;    String key = keyPrefix + id;    // 1.从redis查询商铺缓存    String json = stringRedisTemplate.opsForValue().get(key);    // 2.判断是否存在    if (StrUtil.isNotBlank(json)) &#123;        // 3.存在，直接返回        return JSONUtil.toBean(json, type);    &#125;    // 判断命中的是否是空值    if (json != null) &#123;        // 返回一个错误信息        return null;    &#125;    // 4.不存在，根据id查询数据库    R r = dbFallback.apply(id);    // 5.不存在，返回错误    if (r == null) &#123;        // 将空值写入redis        stringRedisTemplate.opsForValue().set(key, &quot;&quot;, CACHE_NULL_TTL, TimeUnit.MINUTES);        // 返回错误信息        return null;    &#125;    // 6.存在，写入redis    this.set(key, r, time, unit);    return r;&#125;//方法4：根据指定的key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题public &lt;R, ID&gt; R queryWithLogicalExpire(        String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit) &#123;    String key = keyPrefix + id;    // 1.从redis查询商铺缓存    String json = stringRedisTemplate.opsForValue().get(key);    // 2.判断是否存在    if (StrUtil.isBlank(json)) &#123;        // 3.存在，直接返回        return null;    &#125;    // 4.命中，需要先把json反序列化为对象    RedisData redisData = JSONUtil.toBean(json, RedisData.class);    R r = JSONUtil.toBean((JSONObject) redisData.getData(), type);    LocalDateTime expireTime = redisData.getExpireTime();    // 5.判断是否过期    if(expireTime.isAfter(LocalDateTime.now())) &#123;        // 5.1.未过期，直接返回店铺信息        return r;    &#125;    // 5.2.已过期，需要缓存重建    // 6.缓存重建    // 6.1.获取互斥锁    String lockKey = LOCK_SHOP_KEY + id;    boolean isLock = tryLock(lockKey);    // 6.2.判断是否获取锁成功    if (isLock)&#123;        // 6.3.成功，开启独立线程，实现缓存重建        CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;            try &#123;                // 查询数据库                R newR = dbFallback.apply(id);                // 重建缓存                this.setWithLogicalExpire(key, newR, time, unit);            &#125; catch (Exception e) &#123;                throw new RuntimeException(e);            &#125;finally &#123;                // 释放锁                unlock(lockKey);            &#125;        &#125;);    &#125;    // 6.4.返回过期的商铺信息    return r;&#125;//互斥锁方案public &lt;R, ID&gt; R queryWithMutex(        String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit) &#123;    String key = keyPrefix + id;    // 1.从redis查询商铺缓存    String shopJson = stringRedisTemplate.opsForValue().get(key);    // 2.判断是否存在    if (StrUtil.isNotBlank(shopJson)) &#123;        // 3.存在，直接返回        return JSONUtil.toBean(shopJson, type);    &#125;    // 判断命中的是否是空值    if (shopJson != null) &#123;        // 返回一个错误信息        return null;    &#125;    // 4.实现缓存重建    // 4.1.获取互斥锁    String lockKey = LOCK_SHOP_KEY + id;    R r = null;    try &#123;        boolean isLock = tryLock(lockKey);        // 4.2.判断是否获取成功        if (!isLock) &#123;            // 4.3.获取锁失败，休眠并重试            Thread.sleep(50);            return queryWithMutex(keyPrefix, id, type, dbFallback, time, unit);        &#125;        // 4.4.获取锁成功，根据id查询数据库        r = dbFallback.apply(id);        // 5.不存在，返回错误        if (r == null) &#123;            // 将空值写入redis            stringRedisTemplate.opsForValue().set(key, &quot;&quot;, CACHE_NULL_TTL, TimeUnit.MINUTES);            // 返回错误信息            return null;        &#125;        // 6.存在，写入redis        this.set(key, r, time, unit);    &#125; catch (InterruptedException e) &#123;        throw new RuntimeException(e);    &#125;finally &#123;        // 7.释放锁        unlock(lockKey);    &#125;    // 8.返回    return r;&#125;private boolean tryLock(String key) &#123;    Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, &quot;1&quot;, 10, TimeUnit.SECONDS);    return BooleanUtil.isTrue(flag);&#125;private void unlock(String key) &#123;    stringRedisTemplate.delete(key);&#125;&#125;

在ShopServiceImpl 中
@Resourceprivate CacheClient cacheClient; @Override    public Result queryById(Long id) &#123;        // 解决缓存穿透        Shop shop = cacheClient                .queryWithPassThrough(CACHE_SHOP_KEY, id, Shop.class, this::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);        // 互斥锁解决缓存击穿        // Shop shop = cacheClient        //         .queryWithMutex(CACHE_SHOP_KEY, id, Shop.class, this::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);        // 逻辑过期解决缓存击穿        // Shop shop = cacheClient        //         .queryWithLogicalExpire(CACHE_SHOP_KEY, id, Shop.class, this::getById, 20L, TimeUnit.SECONDS);        if (shop == null) &#123;            return Result.fail(&quot;店铺不存在！&quot;);        &#125;        // 7.返回        return Result.ok(shop);    &#125;

二、代码讲解这段代码主要实现了一个基于 Redis 的缓存工具类CacheClient，并在ShopServiceImpl中展示了其用法。该工具类封装了多种缓存策略，用于解决缓存常见问题（缓存穿透、缓存击穿等），下面详细解释其内容：
一、核心类与依赖说明
RedisData 类：用于存储带逻辑过期时间的数据，包含两个字段
expireTime：逻辑过期时间（LocalDateTime 类型）
data：实际存储的业务数据（Object 类型）


CacheClient 类：缓存工具类，核心功能类
依赖StringRedisTemplate：Spring 提供的 Redis 操作模板，用于执行 Redis 命令
内置线程池CACHE_REBUILD_EXECUTOR：固定 10 个线程，用于缓存击穿时的异步缓存重建
注解@Slf4j：提供日志功能；@Component：标记为 Spring 组件，可被自动注入



二、CacheClient 核心方法解析1. 基础存储方法：set（解决基本缓存存储）public void set(String key, Object value, Long time, TimeUnit unit)


功能：将任意 Java 对象序列化为 JSON，存储到 Redis 的 string 类型 key 中，并设置 TTL（物理过期时间）
参数：
key：Redis 的 key
value：要存储的 Java 对象
time：过期时间数值
unit：过期时间单位（如分钟、秒）


实现逻辑：
使用JSONUtil.toJsonStr(value)将对象序列化为 JSON 字符串
调用stringRedisTemplate.opsForValue().set()方法存储，同时指定过期时间



2. 逻辑过期存储方法：setWithLogicalExpire（为解决缓存击穿做准备）public void setWithLogicalExpire(String key, Object value, Long time, TimeUnit unit)


功能：将对象存储到 Redis，并设置逻辑过期时间（而非 Redis 的物理过期），用于解决缓存击穿问题
与 set 方法的区别：
不设置 Redis 的 TTL（key 永不过期）
过期时间存储在RedisData对象中（逻辑层面的过期）


实现逻辑：
创建RedisData对象，封装业务数据value和过期时间（当前时间 + 指定时间）
将RedisData对象序列化为 JSON，存储到 Redis



3. 缓存穿透解决方案：queryWithPassThroughpublic &lt;R,ID&gt; R queryWithPassThrough(    String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)


缓存穿透：指查询不存在的数据时，请求绕过缓存直接冲击数据库（因缓存中无该数据）
解决思路：缓存空值（若数据库中也不存在该数据，往 Redis 存一个空值，避免后续请求直接查库）
参数说明：
keyPrefix：key 的前缀（如 “shop:”）
id：业务 ID（如店铺 ID）
type：返回数据的类型（如 Shop.class）
dbFallback：数据库查询函数（当缓存未命中时调用，如this::getById）
time和unit：缓存过期时间


执行流程：
拼接 Redis 的 key（keyPrefix + id），查询 Redis
若缓存存在（非空）：反序列化为对象并返回
若缓存存在但为空（””）：说明数据库中也无此数据，返回 null（避免查库）
若缓存不存在：调用dbFallback查数据库
若数据库也无数据：往 Redis 存空值（设置短期过期），返回 null
若数据库有数据：将数据存入 Redis（设置过期时间），返回数据





4. 缓存击穿解决方案 1：queryWithLogicalExpirepublic &lt;R, ID&gt; R queryWithLogicalExpire(...)


缓存击穿：指热点 key 过期瞬间，大量请求同时访问该 key，导致请求全部冲击数据库
逻辑过期解决思路：
热点 key 永不过期（Redis 的 TTL 不设置），但在RedisData中设置逻辑过期时间
当逻辑过期时，仅让一个线程重建缓存，其他线程返回旧数据


执行流程：
查 Redis，若缓存不存在直接返回 null
若缓存存在：反序列化为RedisData，解析出业务数据和逻辑过期时间
若未过期：直接返回业务数据
若已过期：
尝试获取互斥锁（tryLock）
若获取锁成功：通过线程池异步执行缓存重建（查数据库→更新 Redis 的逻辑过期时间）
无论是否获取锁，均返回旧数据（保证用户体验，避免阻塞）





5. 缓存击穿解决方案 2：queryWithMutex（互斥锁方案）public &lt;R, ID&gt; R queryWithMutex(...)


互斥锁解决思路：热点 key 过期时，通过互斥锁保证同一时间只有一个线程能查数据库，其他线程等待重试
执行流程：
查 Redis，若缓存存在直接返回
若缓存不存在（或为空值）：
尝试获取互斥锁（tryLock）
若获取失败：休眠 50ms 后重试（循环调用本方法）
若获取成功：查数据库→更新缓存→释放锁→返回数据




与逻辑过期的区别：
互斥锁会阻塞等待，数据实时性高，但可能影响性能
逻辑过期不阻塞，返回旧数据，性能好但存在短期数据不一致



6. 互斥锁工具方法
tryLock(String key)：用 Redis 的setIfAbsent实现互斥锁（原子操作），设置 10 秒过期（避免死锁）
unlock(String key)：删除锁释放资源

三、ShopServiceImpl 中的使用@Overridepublic Result queryById(Long id) &#123;    // 选择一种缓存策略（三选一）    Shop shop = cacheClient.queryWithPassThrough(        CACHE_SHOP_KEY, id, Shop.class, this::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);        if (shop == null) &#123;        return Result.fail(&quot;店铺不存在！&quot;);    &#125;    return Result.ok(shop);&#125;


说明：业务层通过调用CacheClient的方法实现缓存查询，无需关心缓存细节
参数解释：
CACHE_SHOP_KEY：缓存 key 前缀（如 “shop:”）
this::getById：数据库查询方法（当缓存未命中时调用 MyBatis 的 getById 方法）
CACHE_SHOP_TTL：缓存过期时间（如 30 分钟）



四、总结该代码通过封装CacheClient工具类，实现了缓存的常见功能及问题解决方案：

基础缓存存储（带 TTL）
逻辑过期存储（为缓存击穿做准备）
缓存穿透解决（缓存空值）
缓存击穿解决（逻辑过期 + 异步重建 &#x2F; 互斥锁）

通过这种封装，业务层可以灵活切换缓存策略，降低了缓存逻辑与业务逻辑的耦合度，提高了代码的可维护性。
]]></content>
      <categories>
        <category>黑马点评</category>
      </categories>
  </entry>
  <entry>
    <title>03-短信登录-基于Redis方案</title>
    <url>/2025/10/12/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/03-%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95-%E5%9F%BA%E4%BA%8ERedis%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[基于Redis方案发送短信验证码时，因 Redis 数据结构多样，验证码简单故选用 string 类型，且不能用 code 而要用手机号作为 key，以保证唯一性和方便获取。保存用户信息时，对比 string 和哈希两种数据类型，推荐用哈希结构；保存用户信息的 key，建议用随机 token 而非手机号，要将 token 返回前端并保存，前端通过 session storage 存储，axos 拦截器将其放入请求头实现每次请求携带，以此实现登录校验。
Redis基础Redis是典型的key-value数据库，key一般是字符串，而value包含很多不同的数据类型：

Redis为了方便我们学习，将操作不同数据类型的命令也做了分组，在官网（ https://redis.io/commands ）可以查看到不同的命令：
Redis的Java客户端-SpringDataRedisSpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，官网地址：https://spring.io/projects/spring-data-redis

提供了对不同Redis客户端的整合（Lettuce和Jedis）
提供了RedisTemplate统一API来操作Redis
支持Redis的发布订阅模型
支持Redis哨兵和Redis集群
支持基于Lettuce的响应式编程
支持基于JDK.JSON.字符串.Spring对象的数据序列化及反序列化
支持基于Redis的JDKCollection实现

SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：



API
返回值类型
说明



redisTemplate.opsForValue()
ValueOperation
操作String类型数据


redisTemplate.opsForHash()
HashOperation
操作Hash类型数据


redisTemplate.opsForList()
ListOperation
操作List类型数据


redisTemplate.opsForSet()
SetOperations
操作Set类型数据


redisTemplate.opsForZSet()
ZSetOperation
操作SortedSet类型数据


redisTemplate

通用的命令


快速入门SpringBoot已经提供了对SpringDataRedis的支持，使用非常简单：
1.导入pom坐标&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.5.7&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;    &lt;/parent&gt;    &lt;groupId&gt;com.heima&lt;/groupId&gt;    &lt;artifactId&gt;redis-demo&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;redis-demo&lt;/name&gt;    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;    &lt;properties&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;!--redis依赖--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--common-pool--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;            &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--Jackson依赖--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;                &lt;configuration&gt;                    &lt;excludes&gt;                        &lt;exclude&gt;                            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;                            &lt;artifactId&gt;lombok&lt;/artifactId&gt;                             &lt;/exclude&gt;                    &lt;/excludes&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;

2 .配置文件spring:  redis:    host: 192.168.150.101    port: 6379    password: 123321    lettuce:      pool:        max-active: 8  #最大连接        max-idle: 8   #最大空闲连接        min-idle: 0   #最小空闲连接        max-wait: 100ms #连接等待时间

3.注入RedisTemplate@Autowiredprivate RedisTemplate&lt;String, Object&gt; redisTemplate;

4.序列化方案默认 JDK 序列化的问题RedisTemplate 默认使用 JDK 序列化，将对象转为字节数组存储，存在明显缺陷：

可读性差：存储结果为乱码格式，无法直接识别内容。
内存占用大：序列化结果包含大量冗余信息，消耗更多 Redis 内存。

两种解决方案两种序列化实践方案对比



对比维度
方案一：自定义 RedisTemplate（JSON 自动序列化）
方案二：使用 StringRedisTemplate（手动 JSON 序列化）



核心组件
RedisTemplate&lt;String, Object&gt; + GenericJackson2JsonRedisSerializer
StringRedisTemplate（默认 String 序列化） + ObjectMapper


序列化方式
自动（框架完成对象与 JSON 的转换）
手动（开发者通过ObjectMapper 控制序列化 &#x2F; 反序列化）


额外内存开销
有（JSON 中包含类的class 信息，用于反序列化）
无（仅存储纯 JSON 数据，无冗余类信息）


代码复杂度
低（配置一次即可全局使用）
中（每次操作需手动写序列化 &#x2F; 反序列化代码）


适用场景
快速开发、对象类型固定、对内存开销不敏感的场景
高并发、对内存占用要求严格、需精细控制序列化的场景


自定义 RedisTemplate（自动 JSON 序列化）通过配置类修改 RedisTemplate 的默认序列化器，使用 JSON 格式自动处理对象转换。
@Configurationpublic class RedisConfig &#123;    @Bean    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) &#123;        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();        // 配置连接工厂        template.setConnectionFactory(connectionFactory);        // JSON 序列化工具        GenericJackson2JsonRedisSerializer jsonSerializer = new GenericJackson2JsonRedisSerializer();        // Key/HashKey 用 String 序列化（保证可读性）        template.setKeySerializer(RedisSerializer.string());        template.setHashKeySerializer(RedisSerializer.string());        // Value/HashValue 用 JSON 序列化（自动转换对象）        template.setValueSerializer(jsonSerializer);        template.setHashValueSerializer(jsonSerializer);        return template;    &#125;&#125;

特点

优势：无需手动处理 JSON 转换，开发效率高，支持对象与 JSON 的自动映射。
劣势：JSON 数据中会携带 @class 字段（如 &#123;&quot;@class&quot;:&quot;com.example.User&quot;,&quot;name&quot;:&quot;虎哥&quot;,&quot;age&quot;:21&#125;），占用额外内存。

使用 StringRedisTemplate（手动 JSON 序列化）StringRedisTemplate 是 RedisTemplate 的子类，默认 Key 和 Value 均使用 String 序列化，需开发者手动通过 ObjectMapper 完成对象与 JSON 的转换。
@SpringBootTestclass StringRedisTemplateTests &#123;    @Autowired    private StringRedisTemplate stringRedisTemplate;    // 手动 JSON 工具    private static final ObjectMapper MAPPER = new ObjectMapper();    @Test    void testSaveUser() throws JsonProcessingException &#123;        // 1. 创建对象        User user = new User(&quot;虎哥&quot;, 21);        // 2. 手动序列化（对象 → JSON 字符串）        String json = MAPPER.writeValueAsString(user);        // 3. 写入 Redis        stringRedisTemplate.opsForValue().set(&quot;user:200&quot;, json);        // 4. 读取 Redis        String jsonUser = stringRedisTemplate.opsForValue().get(&quot;user:200&quot;);        // 5. 手动反序列化（JSON 字符串 → 对象）        User user1 = MAPPER.readValue(jsonUser, User.class);        System.out.println(&quot;user1 = &quot; + user1);    &#125;&#125;

特点

优势：JSON 数据无冗余 class 信息，内存占用极小，序列化过程完全可控。
劣势：每次操作需重复编写序列化 &#x2F; 反序列化代码，代码量略多。

总结RedisTemplate的两种序列化实践方案：

方案一：

自定义RedisTemplate
修改RedisTemplate的序列化器为GenericJackson2JsonRedisSerializer


方案二：

使用StringRedisTemplate
写入Redis时，手动把对象序列化为JSON
读取Redis时，手动把读取到的JSON反序列化为对象



5.Redis Hash操作@SpringBootTestclass RedisHashTests &#123;    @Autowired    private StringRedisTemplate stringRedisTemplate;    // 手动JSON序列化工具（若Hash值为对象时使用）    private static final ObjectMapper MAPPER = new ObjectMapper();    /**     * 1. 向Hash中添加单个字段（值为普通字符串）     */    @Test    void testHashPut() &#123;        // 操作Hash：key=user:info:100（用户100的信息），hashKey=name/age，hashValue=对应值        stringRedisTemplate.opsForHash().put(&quot;user:info:100&quot;, &quot;name&quot;, &quot;虎哥&quot;);        stringRedisTemplate.opsForHash().put(&quot;user:info:100&quot;, &quot;age&quot;, &quot;21&quot;);        stringRedisTemplate.opsForHash().put(&quot;user:info:100&quot;, &quot;gender&quot;, &quot;男&quot;);    &#125;    /**     * 2. 向Hash中批量添加字段（值含对象，需手动序列化）     */    @Test    void testHashPutAll() throws JsonProcessingException &#123;        // 模拟复杂值：地址对象（需转JSON字符串）        Address address = new Address(&quot;北京市&quot;, &quot;朝阳区&quot;, &quot;XX街道&quot;);        String addressJson = MAPPER.writeValueAsString(address);        // 批量封装Hash字段        Map&lt;String, Object&gt; hashMap = new HashMap&lt;&gt;();        hashMap.put(&quot;name&quot;, &quot;虎哥&quot;);        hashMap.put(&quot;age&quot;, &quot;21&quot;);        hashMap.put(&quot;address&quot;, addressJson); // 存储序列化后的对象        // 批量写入Hash        stringRedisTemplate.opsForHash().putAll(&quot;user:info:100&quot;, hashMap);    &#125;    /**     * 3. 获取Hash中单个字段的值     */    @Test    void testHashGet() throws JsonProcessingException &#123;        // 获取普通字段（name/age）        Object name = stringRedisTemplate.opsForHash().get(&quot;user:info:100&quot;, &quot;name&quot;);        Object age = stringRedisTemplate.opsForHash().get(&quot;user:info:100&quot;, &quot;age&quot;);        System.out.println(&quot;姓名：&quot; + name + &quot;，年龄：&quot; + age);        // 获取对象字段（address，需手动反序列化）        String addressJson = (String) stringRedisTemplate.opsForHash().get(&quot;user:info:100&quot;, &quot;address&quot;);        Address address = MAPPER.readValue(addressJson, Address.class);        System.out.println(&quot;地址：&quot; + address);    &#125;    /**     * 4. 获取Hash中所有字段和值（键值对）     */    @Test    void testHashGetAll() throws JsonProcessingException &#123;        Map&lt;Object, Object&gt; hashEntries = stringRedisTemplate.opsForHash().entries(&quot;user:info:100&quot;);        // 遍历处理：普通字段直接获取，对象字段需反序列化        for (Map.Entry&lt;Object, Object&gt; entry : hashEntries.entrySet()) &#123;            String hashKey = (String) entry.getKey();            Object hashValue = entry.getValue();            if (&quot;address&quot;.equals(hashKey)) &#123;                // 反序列化地址对象                Address address = MAPPER.readValue((String) hashValue, Address.class);                System.out.println(hashKey + &quot;：&quot; + address);            &#125; else &#123;                System.out.println(hashKey + &quot;：&quot; + hashValue);            &#125;        &#125;    &#125;    /**     * 5. 获取Hash中所有字段（仅键）/ 所有值（仅值）     */    @Test    void testHashKeysAndValues() &#123;        // 获取所有字段（HashKey）        Set&lt;Object&gt; hashKeys = stringRedisTemplate.opsForHash().keys(&quot;user:info:100&quot;);        System.out.println(&quot;所有字段：&quot; + hashKeys);        // 获取所有值（HashValue）        List&lt;Object&gt; hashValues = stringRedisTemplate.opsForHash().values(&quot;user:info:100&quot;);        System.out.println(&quot;所有值：&quot; + hashValues);    &#125;    /**     * 6. 删除Hash中的指定字段     */    @Test    void testHashDelete() &#123;        // 删除单个/多个字段（返回删除成功的字段数量）        Long deleteCount = stringRedisTemplate.opsForHash().delete(&quot;user:info:100&quot;, &quot;gender&quot;, &quot;age&quot;);        System.out.println(&quot;删除成功的字段数：&quot; + deleteCount);    &#125;    /**     * 7. 判断Hash中是否存在指定字段     */    @Test    void testHashHasKey() &#123;        boolean hasName = stringRedisTemplate.opsForHash().hasKey(&quot;user:info:100&quot;, &quot;name&quot;);        boolean hasGender = stringRedisTemplate.opsForHash().hasKey(&quot;user:info:100&quot;, &quot;gender&quot;);        System.out.println(&quot;是否存在name字段：&quot; + hasName);        System.out.println(&quot;是否存在gender字段：&quot; + hasGender);    &#125;    // 模拟地址对象（用于测试复杂值存储）    @Data    @NoArgsConstructor    @AllArgsConstructor    static class Address &#123;        private String province;        private String city;        private String detail;    &#125;    // 模拟用户对象（复用之前逻辑）    @Data    @NoArgsConstructor    @AllArgsConstructor    static class User &#123;        private String name;        private Integer age;    &#125;&#125;

覆盖了 Hash 结构的核心操作场景：

普通键值存储 &#x2F; 读取、批量操作
复杂对象（如 Address）的手动序列化 &#x2F; 反序列化
字段删除、存在性判断、全量键值获取

Redis代替session的业务流程设计key
1、key要具有唯一性
2、key要方便携带

数据类型选择用户信息用Hash

验证码code选择String
注意引入LoginInterceptor拦截器类没有@component注解，因此不能自动注入Bean，需要通过构造函数注入。注入的原则是谁使用谁注入，在MvcConfig拦截器配置类中使用了LoginInterceptor（编译器也爆红了，因为需要LoginInterceptor传入参数），因为MvcConfig类标注了@Configuration，因此该类由Spring构建，因此在MvcConfig类利用@Resource&#x2F;@Autowired注解来获取stringRedisTemplate。
/******** MvcConfig ********/public class MvcConfig implements WebMvcConfigurer &#123;    @Resource    private StringRedisTemplate stringRedisTemplate;    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        // 登录拦截器        registry.addInterceptor(new LoginInterceptor())                .excludePathPatterns(                        &quot;/shop/**&quot;,                        &quot;/voucher/**&quot;,                        &quot;/shop-type/**&quot;,                        &quot;/upload/**&quot;,                        &quot;/blog/hot&quot;,                        &quot;/user/code&quot;,                        &quot;/user/login&quot;                ).order(1);    &#125;&#125;/******** LoginInterceptor ********/public class LoginInterceptor implements HandlerInterceptor &#123;    //通过构造函数创建    private StringRedisTemplate redisTemplate;    public LoginInterceptor(StringRedisTemplate redisTemplate) &#123;        this.redisTemplate = redisTemplate;    &#125;    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        ...    &#125;    ...

StringReidisTemplate类型需要String,String自定义Hutool工具类中的BeanUtil.beanToMap方法通过设置字段值修改器解决类型转换异常
//1.DTO转为Map，适配Redis Hash结构（处理类型转换，忽略null值）	//1.1user对象中含有非String类型的属性，而stringRedisTemplate的Hash存储需要key和value都是String类型UserDTO userDTO = BeanUtil.copyProperties(user,UserDTO.class);Map&lt;String,Object&gt; userMap = BeanUtil.beanToMap(userDTO,new HashMap&lt;&gt;(),               CopyOptions.create()             .setIgnoreNullValue(true)// 1.2忽略null值，节省空间             .setFieldValueEditor((fieldName,fieldValue)-&gt;fieldValue.toString));//1.3 所有值转为字符串//2.存储String tokenKey = LOGIN_USER_KEY + token;	//现在就不会报错了stringRedisTemplate.opsForHash().putAll(tokenKey,userMap);

代码实操ServieceUserServiceImpl类
@Override    public Result sendCode(String phone, HttpSession session) &#123;        // 1.校验手机号        if (RegexUtils.isPhoneInvalid(phone)) &#123;            // 2.如果不符合，返回错误信息            return Result.fail(&quot;手机号格式错误！&quot;);        &#125;        // 3.符合，生成验证码        String code = RandomUtil.randomNumbers(6);        // 4.保存验证码到 redis        //可以加个业务前缀，防止其他业务的验证码冲突        stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY+phone,code,LOGIN_CODE_TTL, TimeUnit.MINUTES);        // 5.发送验证码        log.debug(&quot;发送短信验证码成功，验证码：&quot;+code);        // 返回ok        return Result.ok();    &#125;    @Override    public Result login(LoginFormDTO loginForm, HttpSession session) &#123;        // 1.校验手机号        String phone = loginForm.getPhone();        if (RegexUtils.isPhoneInvalid(phone)) &#123;            // 2.如果不符合，返回错误信息            return Result.fail(&quot;手机号格式错误！&quot;);        &#125;        // 3.从Redis获取验证码并校验        String cacheCode=stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY+phone);        String code=loginForm.getCode();        if(cacheCode == null || !cacheCode.equals(code))&#123;            //3.不一致，报错            return Result.fail(&quot;验证码错误&quot;);        &#125;        // 4.验证码一致，查询用户 select * from tb_user where phone = ?        User user=query().eq(&quot;phone&quot;,phone).one();        if(user == null)&#123;            // 5.用户不存在，创建            user =  createUserWithPhone(phone);        &#125;        // 6.保护用户信息到Redis中        // 6.1随机生成token，作为登录令牌        String token= UUID.randomUUID().toString();        // 6.2将User对象转为HashMap存储        UserDTO userDTO=BeanUtil.copyProperties(user,UserDTO.class);        Map&lt;String,Object&gt; userMap=BeanUtil.beanToMap(userDTO,new HashMap&lt;&gt;(),                CopyOptions.create()                        .setIgnoreNullValue(true)                        .setFieldValueEditor((fieldName,fieldValue)-&gt;fieldValue.toString()));        // 6.3Hash存储中添加token和DTO对象        String tokenKey=LOGIN_USER_KEY+token;        stringRedisTemplate.opsForHash().putAll(tokenKey,userMap);        // 6.4设置token的过期时间        stringRedisTemplate.expire(LOGIN_USER_KEY+token,LOGIN_USER_TTL, TimeUnit.MINUTES);        // 7.返回token        return Result.ok(token);    &#125;

拦截器
RefreshTokenInterceptor类  （左边👈第一个拦截器）
//手动new出来的类，所以不能直接注入bean，需要手动注册到spring容器中public class RefreshTokenInterceptor implements HandlerInterceptor &#123;    final private StringRedisTemplate stringRedisTemplate;    public RefreshTokenInterceptor(StringRedisTemplate stringRedisTemplate) &#123;        this.stringRedisTemplate = stringRedisTemplate;    &#125;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) &#123;        // 1.获取请求头中的token    authorization请求头        String token=request.getHeader(&quot;authorization&quot;);        //2.基于Token获取Redis中的用户        String key =LOGIN_USER_KEY+token;        Map&lt;Object,Object&gt; userMap=stringRedisTemplate.opsForHash().entries(key);        //3.判断用户是否存在        if(userMap.isEmpty()) &#123;            //为空也直接放行交给下一个拦截器处理            return true;        &#125;        // 5.将查询到的Hash数据转为UserDTO对象        UserDTO userDTO =BeanUtil.fillBeanWithMap(userMap, new UserDTO(), false);        //6.存在，将UserDTO对象存入ThreadLocal中 */        UserHolder.saveUser(userDTO);        // 7.刷新token有效期        stringRedisTemplate.expire(key,LOGIN_USER_TTL, TimeUnit.MINUTES);        //8.放行        return true;    &#125;&#125;

LoginInterceptor类
public class LoginInterceptor implements HandlerInterceptor &#123;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;       //1.判断是否需要拦截（ThreadLocal中是否有用户）        if(UserHolder.getUser()==null)&#123;            //没有，需要拦截，设置状态            response.setStatus(401);            //拦截            return false;        &#125;        //有用户，则放行        return true;    &#125;&#125;

MvcConfig类
注册器中有控制拦截器执行顺序的order字段，我们希望refresh拦截器先执行，可以通过调整order控制拦截器执行顺序。order值越大，执行的优先级越低。
@Configurationpublic class MvcConfig implements WebMvcConfigurer &#123;    @Resource    private StringRedisTemplate stringRedisTemplate;    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        // 登录拦截器        registry.addInterceptor(new LoginInterceptor())                .excludePathPatterns(                        &quot;/shop/**&quot;,                        &quot;/voucher/**&quot;,                        &quot;/shop-type/**&quot;,                        &quot;/upload/**&quot;,                        &quot;/blog/hot&quot;,                        &quot;/user/code&quot;,                        &quot;/user/login&quot;                ).order(1);     /*  内容：新增刷新token拦截器，默认对所有请求都生效         时间： 2025/9/22 17:01 */        registry.addInterceptor(new RefreshTokenInterceptor(stringRedisTemplate)).addPathPatterns(&quot;/**&quot;).order(0);    &#125;&#125;
]]></content>
      <categories>
        <category>黑马点评</category>
      </categories>
  </entry>
  <entry>
    <title>06-分布式锁</title>
    <url>/2025/10/12/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/06-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[分布式锁的原理、实现分析一、分布式锁的背景：单机锁的局限性单机模式下的 synchronized、JUC 锁（如 ReentrantLock）仅作用于单个 JVM 进程，无法在集群 &#x2F; 分布式环境（多服务器部署）下共享锁状态。若系统是集群部署，多进程间因锁不可见，会导致 “一人一单” 等并发安全逻辑失效，因此需要跨进程、多节点可见的分布式锁。
二、Redis 分布式锁的核心原理利用 Redis 的 SETNX 命令的 “互斥性” + 超时释放机制 实现：

互斥性：SETNX key value（Set if Not Exists）命令的逻辑是：只有当 Key 不存在时，才会设置成功并返回 1；若 Key 已存在，设置失败返回 0。多进程竞争时，只有一个能成功创建 Key（即 “抢到锁”），保证 “串行执行”。
超时释放：为避免进程异常（如宕机）导致锁无法释放，需给锁 Key 设置超时时间（如 EX seconds），确保锁能自动过期，防止死锁。

三、Redis 分布式锁的核心流程与实现1. 获取锁（原子性操作是关键）需同时完成 “SETNX 占锁” 和 “设置超时时间”，否则可能出现 “锁创建成功但未设置超时，进程宕机导致锁永久占用” 的问题。

推荐方案：使用 Redis 原子命令
SET key value NX EX seconds------参数--------‌NX‌（Not eXists）仅当键key不存在时才执行设置操作，保证互斥性。若键已存在，则返回nil（相当于加锁失败）‌EX seconds‌设置键的过期时间（单位为秒），自动释放锁防止死锁。例如EX 30表示30秒后自动删除该键

（或PX milliseconds），一次性完成 “互斥占锁 + 超时设置”。

示例（Redis 命令）：SET lock:order UUID NX EX 30（尝试创建 lock:order 键，值为 UUID，仅当键不存在时成功，且超时 30 秒）。
逻辑：若返回 OK，表示获取锁成功，可执行业务；若返回 nil，表示锁已被占用，需等待或重试。



2. 释放锁（需避免 “误删他人锁”）业务执行完毕后，需删除锁 Key 让其他进程竞争。为避免 “进程 A 误删进程 B 的锁”（比如进程 A 锁超时后，进程 B 刚抢到锁，进程 A 执行 DEL 误删），需增加 “锁归属校验”：

思路：占锁时，给 value 赋值为唯一标识（如 UUID）；释放前，先校验 value 是否与自身一致，再执行 DEL。

实现：通过Lua 脚本保证 “校验 + 删除” 的原子性（Redis 执行 Lua 时是单线程的，不会被中断）。Lua 教程 | 菜鸟教程
示例 Lua 脚本：
if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then    return redis.call(&#x27;del&#x27;, KEYS[1])else    return 0end

四、Redis 分布式锁的特性与优势


特性
说明



多进程可见
Redis 是独立服务，多进程（集群节点）共享其数据，锁状态全局可见。


互斥性
SETNX 命令保证 “同一时间只有一个进程能抢到锁”。


高可用
Redis 支持主从、集群部署，保障锁服务不宕机。


高性能
Redis 是内存数据库，SETNX&#x2F;DEL 等操作是低延迟的原子操作，适合高并发。


安全性
超时时间避免 “死锁”；锁归属校验避免 “误删他人锁”，保障锁的安全释放。


五、与其他分布式锁方案的对比1.0 Zookeeper 教程 | 菜鸟教程



方案
互斥实现方式
高可用
高性能
安全性
适用场景



Redis
SETNX 命令
好
好
超时释放 + 归属校验保障
高并发场景（如秒杀、订单）


MySQL
数据库行锁 &#x2F; 表锁
好
一般
断开连接自动释放锁
并发度不高的场景


Zookeeper
临时节点 + Watcher 机制
好
一般
临时节点断开自动释放锁
一致性要求极高的场景


Redis 分布式锁平衡了性能与可靠性，是企业中最常用的分布式锁方案之一，尤其适合秒杀、订单等高并发业务场景。
实现集群环境的秒杀业务代码（版本一）一、Redis 分布式锁（版本一）的核心实现1. 锁的接口定义（ILock）通过接口规范分布式锁的行为，定义两个核心方法：

tryLock(long timeoutSec)：尝试获取锁，参数为 “锁的超时时间（秒）”，成功返回true，失败返回false。
unlock()：释放锁。

2. SimpleRedisLock（基础实现）基于 Redis 实现分布式锁的核心逻辑：
（1）加锁逻辑private static final String KEY_PREFIX = &quot;lock:&quot;;@Overridepublic boolean tryLock(long timeoutSec) &#123;    // 1. 获取当前线程ID，作为锁的“归属标识”    String threadId = Thread.currentThread().getId();    // 2. 调用Redis的setIfAbsent（对应SETNX命令），同时设置超时时间    // 作用：原子性完成“占锁 + 设过期时间”，避免死锁（如加锁后服务宕机，锁自动过期释放）    //setIfAbsent()返回布尔值表示操作是否成功（true=键不存在且设置成功，false=键已存在）    Boolean success = stringRedisTemplate.opsForValue()            .setIfAbsent(KEY_PREFIX + name, threadId + &quot;&quot;, timeoutSec, TimeUnit.SECONDS);    // 包装为Boolean.TRUE，避免空指针    return Boolean.TRUE.equals(success);&#125;

（2）释放锁逻辑@Overridepublic void unlock() &#123;    // 直接删除Redis中的锁Key，释放锁    stringRedisTemplate.delete(KEY_PREFIX + name);&#125;

3. 业务集成（秒杀下单场景）在 “一人一单” 的秒杀逻辑中，集成分布式锁：
@Overridepublic Result seckillVoucher(Long voucherId) &#123;    // 省略“秒杀时间校验、库存校验”等逻辑...    Long userId = UserHolder.getUser().getId();    // 1. 创建“用户维度”的分布式锁（锁Key为：lock:order:用户ID）    SimpleRedisLock lock = new SimpleRedisLock(&quot;order:&quot; + userId, stringRedisTemplate);    // 2. 尝试加锁（超时时间1200秒）    boolean isLock = lock.tryLock(1200);    if (!isLock) &#123;        return Result.fail(&quot;不允许重复下单&quot;);    &#125;    try &#123;        // 3. 通过AOP代理执行事务方法（保证事务在锁的范围内执行）        IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();        return proxy.createVoucherOrder(voucherId);    &#125; finally &#123;        // 4. 最终释放锁（无论业务成功/失败，都保证锁释放）        lock.unlock();    &#125;&#125;

二、版本一的核心知识点与优缺点1. 优点：解决 “集群环境下的并发安全”
原子性加锁：利用setIfAbsent（Redis SET NX EX命令），保证 “加锁 + 设置过期时间” 是原子操作，避免 “加锁后宕机导致锁永久占用” 的死锁问题。
跨 JVM 生效：Redis 是独立服务，多集群节点（不同 JVM）共享锁状态，解决了 “单机synchronized锁在集群下失效” 的问题。
实现简单：代码逻辑清晰，快速满足分布式场景下 “一人一单” 的并发控制需求。

2. 缺点：存在 “锁误删” 和 “超时失控” 风险
锁误删问题：释放锁时，没有校验锁的归属。若线程 A 的锁因 “超时” 被自动释放，线程 B 抢到新锁，此时线程 A 执行完业务后，会误删线程 B 的锁（因为都操作同一个lock:order:用户ID键）。
超时失控问题：锁的超时时间是固定值，若业务执行时间超过超时时间，锁会提前释放，导致 “多个线程同时执行业务” 的并发安全问题（比如线程 A 锁超时释放，线程 B 加锁成功，此时线程 A 仍在执行业务，线程 B 也开始执行）。

三、关键技术点总结
Redis 命令核心：SET key value NX EX seconds（setIfAbsent的底层逻辑），是分布式锁 “互斥性 + 自动超时释放” 的基础。
事务与锁的协同：通过AopContext获取代理对象，保证事务在锁的范围内执行（避免 “锁释放后事务才提交” 导致的脏读）。
finally 的必要性：无论业务是否异常，都通过finally块释放锁，防止 “锁泄漏”（锁长期不释放，导致其他线程无法获取）。

该版本是 Redis 分布式锁的基础实现，能解决大部分集群场景的并发问题，但需后续优化 “锁归属校验” 和 “动态超时” 等问题。
Redis 分布式锁的 “误删” 与 “原子性” 问题及解决方案一、误删问题：锁超时后误删其他线程的锁场景：
线程 A 持有锁，但因业务阻塞（如 GC 停顿、网络延迟）导致锁超时自动释放；后续线程 A 执行 “释放锁” 操作时，会误删已被线程 B 获取的新锁，引发并发安全问题（如 “一人一单” 逻辑失效）。
解决方案：锁与线程标识绑定，释放前校验
核心思路：加锁时存入线程唯一标识（如 “UUID 前缀 + 线程 ID”），释放时校验标识是否匹配，仅释放自身持有的锁。

加锁逻辑：
生成线程唯一标识，通过 SETNX + EX 原子性占锁并设置超时，确保锁归属可追溯。
private static final String ID_PREFIX = UUID.randomUUID().toString(true) + &quot;-&quot;;@Overridepublic boolean tryLock(long timeoutSec) &#123;    // 生成当前线程的唯一标识    String threadId = ID_PREFIX + Thread.currentThread().getId();    // 原子性执行：SET key value NX EX seconds（占锁 + 设超时）    Boolean success = stringRedisTemplate.opsForValue()            .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);    return Boolean.TRUE.equals(success);&#125;

释放锁逻辑（初步优化）：
释放前校验锁的标识是否与当前线程一致，一致才删除（避免误删其他线程的锁）。
@Overridepublic void unlock() &#123;    String threadId = ID_PREFIX + Thread.currentThread().getId();    // 获取Redis中存储的锁标识    String storedId = stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);    // 仅当标识匹配时，才删除锁    if (threadId.equals(storedId)) &#123;        stringRedisTemplate.delete(KEY_PREFIX + name);    &#125;&#125;

二、原子性问题：“校验标识 + 删除锁” 非原子操作场景：
线程 A 执行 “校验标识” 后，锁因超时自动释放，线程 B 获取该锁；此时线程 A 继续执行 “删除锁”，会误删线程 B 的锁 —— 因为 “校验” 和 “删除” 是两步操作，中间可被其他操作打断，不具备原子性。
解决方案：Lua 脚本保证原子性
Redis 执行 Lua 脚本时是单线程的，脚本内的多条命令会原子性执行（中间不会被其他命令打断）。因此，将 “校验标识 + 删除锁” 封装为 Lua 脚本，确保两步操作的原子性。

Lua 脚本逻辑：
仅当锁的标识与当前线程一致时，原子性删除锁。
-- KEYS[1]：锁的Key；ARGV[1]：当前线程的唯一标识if (redis.call(&#x27;GET&#x27;, KEYS[1]) == ARGV[1]) then  return redis.call(&#x27;DEL&#x27;, KEYS[1])  -- 原子性删除锁endreturn 0  -- 标识不匹配，不操作

Java 中调用 Lua 脚本：
通过 RedisTemplate 执行 Lua 脚本，确保 “校验 + 删除” 的原子性。
// 定义Lua脚本（从类路径加载，如unlock.lua文件）private static final DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;static &#123;    UNLOCK_SCRIPT = new DefaultRedisScript&lt;&gt;();    UNLOCK_SCRIPT.setLocation(new ClassPathResource(&quot;unlock.lua&quot;)); // 脚本路径    UNLOCK_SCRIPT.setResultType(Long.class); // 脚本返回值类型&#125;public void unlock() &#123;    String lockKey = KEY_PREFIX + name; // 锁的Key（如&quot;lock:order:用户ID&quot;）    String threadId = ID_PREFIX + Thread.currentThread().getId(); // 当前线程唯一标识    // 执行Lua脚本，参数为：脚本、锁Key列表、线程标识    stringRedisTemplate.execute(            UNLOCK_SCRIPT,            Collections.singletonList(lockKey),            threadId);&#125;

三、方案价值与延伸问题
价值：结合 “线程标识校验” 和 “Lua 原子性脚本”，彻底解决 “误删锁” 问题，确保分布式锁在高并发场景下的安全性。
延伸问题：若业务执行时间 &gt; 锁超时时间，锁仍会提前释放（导致多线程并发执行业务）。需通过锁续期机制（如 Redisson 的 “看门狗”）自动延长锁的超时时间，匹配业务执行时长。

四、延伸问题：锁续期当前方案仍未解决 “锁超时时间 &lt; 业务执行时间” 的问题（若业务执行过慢，锁会提前释放，导致多线程并发执行）。后续需通过锁续期机制（如 Redisson 的 “看门狗”），自动延长锁的超时时间，匹配业务执行时长。
通过以上步骤，Redis 分布式锁既解决了 “误删他人锁” 的安全问题，又通过 Lua 脚本保证了 “释放锁” 操作的原子性，为高并发场景提供可靠的并发控制。
]]></content>
      <categories>
        <category>黑马点评</category>
      </categories>
  </entry>
  <entry>
    <title>05-优惠卷秒杀</title>
    <url>/2025/10/12/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/05-%E4%BC%98%E6%83%A0%E5%8D%B7%E7%A7%92%E6%9D%80/</url>
    <content><![CDATA[基于Redis的全局唯一ID生成器一、业务背景：为什么需要全局唯一 ID？在黑马点评的优惠券订单业务中，订单表若使用 MySQL 自增 ID，会面临两大问题：

安全性不足：自增 ID 规律性强，易被猜测出业务信息（如单日订单量）。
扩展性不足：MySQL 单表容量建议不超过 500 万，分库分表后，自增 ID 无法保证全局唯一性。

二、全局唯一 ID 生成器的核心特性一个可靠的全局 ID 生成器需满足以下特性：

唯一性：分布式系统中 ID 绝对不重复。
高可用：生成 ID 的服务 &#x2F; 组件稳定，不影响业务流程。
高性能：支撑高并发场景，生成 ID 的速度足够快。
递增性：ID 尽量递增（利于数据库索引，如 MySQL B + 树的写入性能）。
安全性：ID 无明显规律，避免泄露业务信息。

三、基于 Redis 的全局 ID 结构设计为兼顾 “递增性” 和 “安全性”，采用 “时间戳 + 序列号” 的组合结构：

符号位（1bit）：固定为 0，保证 ID 为正数。
时间戳（31bit）：以秒为单位的相对时间（减去起始时间戳1640995200L，即 2022-01-01 00:00:00），可使用约 69 年。
序列号（32bit）：秒内的计数器，由 Redis 原子自增生成，每秒可生成 (2^{32})（约 42 亿）个 ID，支撑超高并发。

四、Redis 实现全局唯一 ID 的代码剖析核心类 RedisIdWorker 利用 Redis 的原子自增保证序列号唯一性，结合时间戳实现递增：
@Componentpublic class RedisIdWorker &#123;    // 起始时间戳（2022-01-01 00:00:00的秒数）    private static final long BEGIN_TIMESTAMP = 1640995200L;    // 序列号的位数（32位，决定每秒最大生成量）    private static final int COUNT_BITS = 32;    private StringRedisTemplate stringRedisTemplate;    public RedisIdWorker(StringRedisTemplate stringRedisTemplate) &#123;        this.stringRedisTemplate = stringRedisTemplate;    &#125;    public long nextId(String keyPrefix) &#123;        // 1. 生成时间戳（相对起始时间的秒数，缩短位数）        //LocalDateTime.now() 返回当前日期和时间（精确到纳秒）        LocalDateTime now = LocalDateTime.now();        //toEpochSecond(ZoneOffset.UTC) 将当前时间转换为 UTC 时区的秒级时间戳（即从 1970 年 1 月 1 日至当前时间的总秒数）。        long nowSecond = now.toEpochSecond(ZoneOffset.UTC);        long timestamp = nowSecond - BEGIN_TIMESTAMP;        // 2. 生成序列号（按“年:月:日”分键，保证每天的序列号独立自增）        String date = now.format(DateTimeFormatter.ofPattern(&quot;yyyy:MM:dd&quot;));        // Redis increment是原子操作，保证同一秒内序列号唯一        long count = stringRedisTemplate.opsForValue().increment(&quot;icr:&quot; + keyPrefix + &quot;:&quot; + date);        // 3. 拼接时间戳和序列号（位运算：时间戳左移32位，与序列号按位或）        return timestamp &lt;&lt; COUNT_BITS | count;    &#125;&#125;

代码关键逻辑解析：
时间戳处理：通过 “当前秒数 - 起始秒数”，将时间戳范围缩短，减少位数占用，同时保证递增性。
序列号生成：利用 Redis INCR 原子性，按 “日期” 分键，确保同一秒内序列号唯一且递增；跨天自动重置，避免序列号溢出。
位运算拼接：timestamp &lt;&lt; COUNT_BITS 将时间戳左移 32 位，空出低 32 位给序列号；再通过|（按位或）将两者合并为一个long型 ID，保证结构紧凑。

五、高并发测试与CountDownLatch的作用多线程之CountDownLatch详解_多线程 countdownlatch-CSDN博客
测试代码用于验证高并发下 ID 生成的性能与唯一性，其中CountDownLatch是关键：
@Testvoid testIdWorker() throws InterruptedException &#123;    // 初始化计数器为300（表示需要300个线程完成后，才解除阻塞）    CountDownLatch latch = new CountDownLatch(300);    // 每个线程生成100个ID    Runnable task = () -&gt; &#123;        for (int i = 0; i &lt; 100; i++) &#123;            long id = redisIdWorker.nextId(&quot;order&quot;);            System.out.println(&quot;id = &quot; + id);        &#125;        latch.countDown(); // 线程完成，计数器减1    &#125;;    long begin = System.currentTimeMillis();    // 启动300个线程    for (int i = 0; i &lt; 300; i++) &#123;        es.submit(task);    &#125;    latch.await(); // 主线程阻塞，直到计数器为0    long end = System.currentTimeMillis();    System.out.println(&quot;总耗时 = &quot; + (end - begin));&#125;

CountDownLatch的作用：
同步多线程执行：让所有子线程（300 个）都生成完 ID 后，主线程再统计总耗时，从而准确评估高并发性能。
核心方法：
countDown()：子线程完成任务后调用，计数器减 1。
await()：主线程调用，阻塞直到计数器为 0，再继续执行。



六、知识点拓展与对比1. Redis 方案的优势
高性能：Redis 单实例 QPS 可达 10 万级，INCR原子操作足够快。
高可用：可通过 Redis 集群（如主从、哨兵、Cluster）保证服务不宕机。
防重复 &#x2F; 时钟问题：依赖 Redis 原子自增，无 “雪花算法” 的时钟回拨风险。

2. 其他全局 ID 方案对比


方案
优点
缺点



MySQL 自增
简单易实现
规律性强、分库分表后不唯一


UUID
全局唯一
无递增性、存储占空间、索引差


雪花算法（Snowflake）
递增、性能高
依赖机器时钟，时钟回拨会重复


分布式中间件（如 Leaf）
功能完善、性能稳定
架构复杂，需额外维护中间件


综上，黑马点评选择Redis 实现全局唯一 ID，是兼顾 “轻量、高性能、高可用、唯一性” 的折中方案，特别适合优惠券、订单等高并发场景。
优惠卷类型、秒杀下单业务及其超卖问题一、优惠券的类型与新增逻辑黑马点评的优惠券分为普通券和秒杀券，对应不同表结构与新增逻辑：



优惠券类型
表结构
新增逻辑



普通券
tb_voucher（存基础优惠信息）
直接调用save方法，持久化到数据库即可。


秒杀券
tb_voucher + tb_seckill_voucher（额外存库存、秒杀时间）
需事务性完成 3 步：1. 保存基础优惠信息到tb_voucher；2. 保存秒杀专属信息（库存、时间等）到tb_seckill_voucher；3. 库存预热到 Redis（将库存值写入 Redis，为后续秒杀做准备）。


**新增普通卷代码：  **VoucherController
@PostMappingpublic Result addVoucher(@RequestBody Voucher voucher) &#123;    voucherService.save(voucher);    return Result.ok(voucher.getId());&#125;

新增秒杀卷代码：
VoucherController
@PostMapping(&quot;seckill&quot;)public Result addSeckillVoucher(@RequestBody Voucher voucher) &#123;    voucherService.addSeckillVoucher(voucher);    return Result.ok(voucher.getId());&#125;

VoucherServiceImpl
@Override@Transactionalpublic void addSeckillVoucher(Voucher voucher) &#123;    // 保存优惠券    save(voucher);    // 保存秒杀信息    SeckillVoucher seckillVoucher = new SeckillVoucher();    seckillVoucher.setVoucherId(voucher.getId());    seckillVoucher.setStock(voucher.getStock());    seckillVoucher.setBeginTime(voucher.getBeginTime());    seckillVoucher.setEndTime(voucher.getEndTime());    seckillVoucherService.save(seckillVoucher);    // 保存秒杀库存到Redis中    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());&#125;

二、秒杀下单的核心业务流程用户点击 “秒杀抢购” 时，后端执行以下步骤：

校验秒杀时间：判断当前时间是否在秒杀的beginTime和endTime之间，否则返回 “秒杀未开始 &#x2F; 已结束”。
校验库存：查询tb_seckill_voucher中的库存，若库存不足则返回 “库存不足”。
扣减库存：通过数据库更新操作扣减库存（此环节是 “库存超卖问题” 的核心场景）。
创建订单：用 Redis 全局 ID 生成器生成唯一订单 ID，将订单信息（用户 ID、优惠券 ID 等）持久化到tb_voucher_order。

VoucherOrderServiceImpl
@Overridepublic Result seckillVoucher(Long voucherId) &#123;    // 1.查询优惠券    SeckillVoucher voucher = seckillVoucherService.getById(voucherId);    // 2.判断秒杀是否开始    if (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;        // 尚未开始        return Result.fail(&quot;秒杀尚未开始！&quot;);    &#125;    // 3.判断秒杀是否已经结束    if (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;        // 尚未开始        return Result.fail(&quot;秒杀已经结束！&quot;);    &#125;    // 4.判断库存是否充足    if (voucher.getStock() &lt; 1) &#123;        // 库存不足        return Result.fail(&quot;库存不足！&quot;);    &#125;    //5，扣减库存    boolean success = seckillVoucherService.update()            .setSql(&quot;stock= stock -1&quot;)            .eq(&quot;voucher_id&quot;, voucherId).update();    if (!success) &#123;        //扣减库存        return Result.fail(&quot;库存不足！&quot;);    &#125;    //6.创建订单    VoucherOrder voucherOrder = new VoucherOrder();    // 6.1.订单id    long orderId = redisIdWorker.nextId(&quot;order&quot;);    voucherOrder.setId(orderId);    // 6.2.用户id    Long userId = UserHolder.getUser().getId();    voucherOrder.setUserId(userId);    // 6.3.代金券id    voucherOrder.setVoucherId(voucherId);    save(voucherOrder);    return Result.ok(orderId);&#125;

三、库存超卖问题与解决方案1. 问题分析高并发下，多个线程同时执行 “查询库存 → 扣减库存” 流程，会导致 “库存被重复扣减”，最终库存为负（超卖）。
示例：线程 1 查询库存为 1（未扣减），线程 2 也查询到库存为 1，随后两线程都执行扣减，最终库存变成 - 1，违反业务规则。
2. 解决方案：悲观锁 vs 乐观锁


锁类型
思路
优缺点



悲观锁
认为线程安全问题一定会发生，操作前先加锁（如synchronized、Lock），强制线程串行执行。
优点：逻辑简单，绝对保证数据安全；缺点：串行执行导致性能大幅下降，高并发下吞吐量极低。


乐观锁
认为线程安全问题不一定发生，不加锁，而是通过 “版本控制” 或 “条件校验”，在更新时验证数据是否被篡改。
优点：非阻塞，高并发性能好；缺点：需处理更新失败的重试或降级逻辑。


3. 乐观锁的具体实现（课程案例）乐观锁的核心是 “更新时带条件，验证数据未被篡改”。课程中给出两种方式：

方式 1：基于 “库存相等” 的条件更新
seckillVoucherService.update()    .setSql(&quot;stock= stock -1&quot;)    .eq(&quot;voucher_id&quot;, voucherId)    .eq(&quot;stock&quot;, voucher.getStock()) // 预期库存与查询时一致    .update();


问题：高并发下，只有 1 个线程能命中 “库存相等” 的条件，其余线程全部失败，成功率极低。
失败的原因在于：在使用乐观锁过程中假设100个线程同时都拿到了100的库存，然后大家一起去进行扣减，但是100个人中只有1个人能扣减成功，其他的人在处理时，他们在扣减时，库存已经被修改过了，所以此时其他线程都会失败




方式 2：基于 “库存大于 0” 的条件更新
seckillVoucherService.update()    .setSql(&quot;stock= stock -1&quot;)    .eq(&quot;voucher_id&quot;, voucherId)    .gt(&quot;stock&quot;, 0) // 只要库存&gt;0，就尝试扣减    .update();


优化：只要库存有剩余，就允许扣减，成功率更高，且能避免超卖（gt(&quot;stock&quot;, 0)保证扣减时库存至少为 1）。



4. 扩展：LongAdder 优化 CAS 自旋压力Java 8 提供的LongAdder是AtomicLong的优化版，用于高并发计数场景：


原理：多线程竞争激烈时，LongAdder会拆分多个 “cell（分段计数器）”，让线程分散到不同 cell 更新，减少 CAS 自旋冲突；最终结果由base（基础计数器）和所有cell累加得到。
优势：相比AtomicLong的全局 CAS 自旋，LongAdder通过 “**分段 CAS**” 降低竞争，大幅提升高并发下的计数性能。

四、核心总结秒杀场景的关键挑战是 **“高并发下的库存安全” 与 “性能” 的平衡 **。黑马点评通过：

乐观锁（“库存&gt; 0 条件更新”）解决超卖问题，兼顾数据安全与高并发性能；
Redis 预热库存、全局唯一 ID 生成等技术，为秒杀的 “高可用、高性能” 提供支撑。

一人一单单机环境一、业务需求：优惠券 “一人一单”为避免用户重复抢购同一张优惠券，需限制同一用户对同一优惠券仅能创建一次订单。
二、核心问题与演进1. 初始问题：并发下重复下单VoucherOrderServiceImpl  
初步代码：增加一人一单逻辑
@Overridepublic Result seckillVoucher(Long voucherId) &#123;    // 1.查询优惠券    SeckillVoucher voucher = seckillVoucherService.getById(voucherId);    // 2.判断秒杀是否开始    if (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;        // 尚未开始        return Result.fail(&quot;秒杀尚未开始！&quot;);    &#125;    // 3.判断秒杀是否已经结束    if (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;        // 尚未开始        return Result.fail(&quot;秒杀已经结束！&quot;);    &#125;    // 4.判断库存是否充足    if (voucher.getStock() &lt; 1) &#123;        // 库存不足        return Result.fail(&quot;库存不足！&quot;);    &#125;    // 5.一人一单逻辑    // 5.1.用户id    Long userId = UserHolder.getUser().getId();    int count = query().eq(&quot;user_id&quot;, userId).eq(&quot;voucher_id&quot;, voucherId).count();    // 5.2.判断是否存在    if (count &gt; 0) &#123;        // 用户已经购买过了        return Result.fail(&quot;用户已经购买过一次！&quot;);    &#125;    //6，扣减库存    boolean success = seckillVoucherService.update()            .setSql(&quot;stock= stock -1&quot;)            .eq(&quot;voucher_id&quot;, voucherId).update();    if (!success) &#123;        //扣减库存        return Result.fail(&quot;库存不足！&quot;);    &#125;    //7.创建订单    VoucherOrder voucherOrder = new VoucherOrder();    // 7.1.订单id    long orderId = redisIdWorker.nextId(&quot;order&quot;);    voucherOrder.setId(orderId);    voucherOrder.setUserId(userId);    // 7.3.代金券id    voucherOrder.setVoucherId(voucherId);    save(voucherOrder);    return Result.ok(orderId);&#125;


直接在秒杀逻辑中添加 “查询用户是否已下单” 的校验，但高并发时，多个线程同时查询到 “无订单”，会同时执行下单，导致重复。

2. 尝试方案：加悲观锁（但粒度太粗）给初始方案封装了一个createVoucherOrder方法，同时为了确保他线程安全，在方法上添加了一把synchronized 锁
给 createVoucherOrder 方法加 synchronized，但所有用户共享同一把锁，请求串行执行，性能极差。
@Transactionalpublic synchronized Result createVoucherOrder(Long voucherId) &#123;	Long userId = UserHolder.getUser().getId();         // 5.1.查询订单        int count = query().eq(&quot;user_id&quot;, userId).eq(&quot;voucher_id&quot;, voucherId).count();        // 5.2.判断是否存在        if (count &gt; 0) &#123;            // 用户已经购买过了            return Result.fail(&quot;用户已经购买过一次！&quot;);        &#125;        // 6.扣减库存        boolean success = seckillVoucherService.update()                .setSql(&quot;stock = stock - 1&quot;) // set stock = stock - 1                .eq(&quot;voucher_id&quot;, voucherId).gt(&quot;stock&quot;, 0) // where id = ? and stock &gt; 0                .update();        if (!success) &#123;            // 扣减失败            return Result.fail(&quot;库存不足！&quot;);        &#125;        // 7.创建订单        VoucherOrder voucherOrder = new VoucherOrder();        // 7.1.订单id        long orderId = redisIdWorker.nextId(&quot;order&quot;);        voucherOrder.setId(orderId);        // 7.2.用户id        voucherOrder.setUserId(userId);        // 7.3.代金券id        voucherOrder.setVoucherId(voucherId);        save(voucherOrder);        // 7.返回订单id        return Result.ok(orderId);&#125;

3. 优化锁粒度：用户维度的锁使用 userId.toString().intern() 作为锁对象：

userId.toString() 生成的是新字符串对象，不同线程的同一用户 ID 会因 “新对象” 导致锁无效；
调用 intern() 后，字符串从常量池获取唯一实例，保证 “同一用户竞争同一把锁，不同用户不互斥”，大幅提升并发度。

4. 事务与锁的冲突：代理与事务范围一、Spring 事务的 “代理生效” 原理@Transactional 是通过 代理模式 实现的（JDK 动态代理或 CGLIB 子类代理）：

当调用被 @Transactional 修饰的方法时，代理对象 会先启动事务，再执行目标方法，最后根据执行结果提交 &#x2F; 回滚事务。
如果直接通过 this（目标对象自身）调用事务方法，不会经过代理，事务逻辑不会生效（相当于普通方法调用）。




“代理失效“场景
解决方案



内部方法调用
注入自身代理对象（AopContext.currentProxy()）


非 public 方法
改为 public 方法


final&#x2F;static 方法
重构为实例方法


非 Spring Bean
添加 @Component 等注解


多线程调用
使用 @Async + 事务传播


异常类型不匹配
显式指定 rollbackFor


二、“锁在方法内” 的冲突问题若锁的范围仅包裹 “目标方法内部代码”，而事务由代理控制，会出现以下时序问题：

线程 A 获取锁，调用代理方法 → 代理启动事务，执行目标方法（扣减库存、创建订单）。
线程 A 执行完目标方法，释放锁 → 但代理的 “事务提交” 还未执行（事务提交在代理方法的最后一步）。
线程 B 获取锁，调用代理方法 → 此时线程 A 的事务未提交，线程 B 查不到线程 A 未提交的订单，会重复下单。

三、解决方案：用代理对象保证 “锁包裹事务”通过 AopContext.currentProxy() 获取当前对象的代理实例，再通过代理调用事务方法，确保：

锁的范围 包含整个事务过程（从 “事务启动” 到 “事务提交 &#x2F; 回滚”）。
事务通过代理生效，且在锁的保护下执行，避免 “锁释放后事务才提交” 导致的脏读。

代码示例的核心逻辑：
synchronized (userId.toString().intern()) &#123; // 1. 加用户维度的锁    // 2. 获取当前Service的代理对象（含事务增强逻辑）    IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();    // 3. 通过代理调用方法 → 事务在代理中启动，且被锁包裹    return proxy.createVoucherOrder(voucherId);&#125;

四、关键结论
Spring 事务的生效依赖代理调用，直接 this.方法() 会绕过代理，导致事务失效。
要让 “锁保护事务的原子性”，需通过 AopContext 获取代理对象，保证锁的范围包含整个事务过程，解决 “锁释放后事务才提交” 的并发问题。

三、最终解决方案与代码剖析1. 核心逻辑：锁 + 事务 + 代理协同@Overridepublic Result seckillVoucher(Long voucherId) &#123;    // 省略“秒杀时间校验、库存校验”等逻辑...    Long userId = UserHolder.getUser().getId();    // 用用户ID的intern字符串做锁，保证同一用户竞争同一把锁    synchronized (userId.toString().intern()) &#123;        // 获取当前Service的代理对象（含事务增强）        IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();        // 通过代理调用，保证事务在锁内执行        return proxy.createVoucherOrder(voucherId);    &#125;&#125;@Transactionalpublic Result createVoucherOrder(Long voucherId) &#123;    Long userId = UserHolder.getUser().getId();    // 1. 校验：查询用户是否已下单    int count = query().eq(&quot;user_id&quot;, userId).eq(&quot;voucher_id&quot;, voucherId).count();    if (count &gt; 0) &#123;        return Result.fail(&quot;用户已下单，无法重复购买&quot;);    &#125;    // 2. 扣减库存（乐观锁，防止超卖）    boolean success = seckillVoucherService.update()            .setSql(&quot;stock = stock - 1&quot;)            .eq(&quot;voucher_id&quot;, voucherId)            .gt(&quot;stock&quot;, 0) // 库存&gt;0才扣减            .update();    if (!success) &#123;        return Result.fail(&quot;库存不足&quot;);    &#125;    // 3. 创建订单    VoucherOrder order = new VoucherOrder();    order.setId(redisIdWorker.nextId(&quot;order&quot;));    order.setUserId(userId);    order.setVoucherId(voucherId);    save(order);    return Result.ok(order.getId());&#125;

2. 关键技术点剖析
intern() 保证锁的唯一性：String.intern() 从常量池返回唯一实例，确保同一用户 ID 的锁对象唯一，实现 “用户维度排他锁”，既保证安全又减少锁竞争。
AopContext.currentProxy() 协同事务与锁：通过代理对象调用 createVoucherOrder，让事务的完整生命周期（包括提交）被包含在锁内，避免 “锁释放后事务才提交” 导致的脏读。
事务 + 乐观锁的双重保障：@Transactional 保证 “查询 - 扣减库存 - 创建订单” 的原子性；扣减库存时用乐观锁（gt(&quot;stock&quot;, 0)），进一步防止库存超卖。

四、总结“一人一单” 需求的核心是 **“并发安全、性能、事务一致性” 的平衡 **：

用用户维度的悲观锁（synchronized + intern）解决重复下单的并发问题，同时控制锁粒度提升性能；
用Spring 代理与事务的协同（AopContext）保证 “锁内事务完整”，避免脏读；
结合乐观锁扣减库存，双重保障数据一致性。

单机模式下，通过：

userId.toString().intern() 实现用户级别的锁粒度控制；
@EnableAspectJAutoProxy(exposeProxy = true) 暴露代理对象，确保事务在锁内生效；
结合 synchronized 与乐观锁，可解决 “一人一单” 的并发安全问题。

但集群环境需进一步引入分布式锁，突破单机锁的范围限制。
单机环境下 “一人一单” 的完整配置要让 synchronized(userId.toString().intern()) 结合事务正常生效，需完成以下配置，核心是暴露代理对象以便在锁内调用事务方法：
1. 添加 AspectJ 依赖（支持 AOP 代理暴露）AspectJ 是 Spring AOP 的底层依赖之一，用于支持代理对象的暴露。在 pom.xml 中添加：
&lt;dependency&gt;    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;    &lt;version&gt;1.9.6&lt;/version&gt; &lt;!-- 版本可根据Spring Boot版本适配 --&gt;&lt;/dependency&gt;

2. 启动类开启代理暴露在 Spring Boot 启动类上添加 @EnableAspectJAutoProxy(exposeProxy = true)，作用是：

允许 Spring 将代理对象暴露到 ThreadLocal 中，使得在目标方法内部可通过 AopContext.currentProxy() 获取代理实例。
确保 @Transactional 注解的事务逻辑能通过代理正常生效（避免 this.方法() 调用导致的事务失效）。

示例：
@SpringBootApplication@EnableAspectJAutoProxy(exposeProxy = true) // 暴露代理对象public class DianPingApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(DianPingApplication.class, args);    &#125;&#125;

集群环境下的并发问题一、单机环境：synchronized 为什么能工作？synchronized 是 JVM 提供的内置互斥锁，其作用范围是单个 JVM 进程内部。

同一 JVM 内的多个线程，会竞争同一个锁对象（比如方法锁的 “类对象”、对象锁的 “实例对象”）。
只有拿到锁的线程能进入 “临界区”（如 “查询订单→判断是否存在→插入新订单” 的逻辑），其他线程会被阻塞，从而保证单机内的并发安全（比如 “一人一单” 在单机下不会重复下单）。

二、集群环境：synchronized 为什么会失效？集群是多台服务器 &#x2F; 多个 JVM 进程同时提供服务（比如部署 2 个 Tomcat 实例，各自对应独立的 JVM）。此时 synchronized 的 “进程内锁” 特性，会导致锁无法跨 JVM 生效：

服务器 A 的 Tomcat（JVM 1）里，线程 1 和线程 2 会竞争JVM 1 内的锁，能保证互斥。
服务器 B 的 Tomcat（JVM 2）里，线程 3 和线程 4 会竞争JVM 2 内的锁，也能保证互斥。
但 JVM 1 的锁和 JVM 2 的锁是 “各自独立” 的！线程 1（JVM 1）和线程 3（JVM 2）可以同时拿到 “各自 JVM 内的锁”，进而同时进入 “查询订单→插入” 的逻辑 —— 这就会绕过 “一人一单” 的限制，导致重复下单。

三、如何解决？用「分布式锁」实现跨 JVM 的全局互斥分布式锁的核心思想是：让所有 JVM &#x2F; 服务实例共享一个 “全局锁资源”，从而实现跨进程的互斥。
常用的分布式锁实现方案（以 Redis 为例）：

利用 Redis 原子性命令（如 SETNX）：

当需要加锁时，向 Redis 发送 SETNX lock:user:123 &quot;随机值&quot;（lock:user:123 是锁的 key，“随机值” 用于后续释放锁时的唯一性验证），并设置过期时间（避免死锁）。
SETNX 是 “Set if Not Exists” 的缩写：如果 key 不存在，就设置成功（返回 1），表示 “拿到锁”；如果 key 已存在，设置失败（返回 0），表示 “锁被占用”。


执行临界区逻辑：
只有拿到锁的线程（或服务实例），才能执行 “查询订单→判断→插入” 的逻辑。

释放锁：
执行完逻辑后，需要原子性地删除锁（避免多线程环境下误删其他线程的锁）。通常用 Lua 脚本实现：
if redis.call(&quot;get&quot;, KEYS[1]) == ARGV[1] then    return redis.call(&quot;del&quot;, KEYS[1])else    return 0end

（验证 “锁的值是否为自己的随机值”，是为了防止 “锁过期后被其他线程误删” 的情况。）


四、总结
单机下，synchronized 靠 “JVM 内共享锁对象” 保证互斥。
集群下，多 JVM 各自的锁不共享，导致 synchronized 失效。
分布式锁通过 Redis 等中间件提供 “全局共享的锁资源”，让所有服务实例竞争同一把锁，从而实现跨进程的并发安全（如 “一人一单” 的全局控制）。

]]></content>
      <categories>
        <category>黑马点评</category>
      </categories>
  </entry>
  <entry>
    <title>07-分布式锁-redission</title>
    <url>/2025/10/12/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/07-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-redission/</url>
    <content><![CDATA[分布式锁-redission功能介绍和快速入门一、引入背景：手动 Redis 锁的局限性基于 Redis SETNX手动实现的分布式锁，存在以下核心缺陷：

不可重入：同一线程无法多次获取同一把锁（如方法嵌套调用时，易导致死锁）。
不可重试：获取锁失败后直接返回，无重试机制，高并发下成功率低。
超时释放隐患：锁超时时间固定，若业务执行超时时长，锁会提前释放，引发并发安全问题。
主从一致性问题：Redis 主从同步有延迟，主机宕机后从机升主，锁数据可能丢失，导致锁失效。

二、Redisson 是什么？Redisson 是基于 Redis 的 Java 驻内存数据网格（In-Memory Data Grid），不仅封装了 Redis 的基础操作，还提供丰富的分布式服务（如分布式锁、集合、对象等）。其中，分布式锁的增强实现解决了手动锁的缺陷，支持可重入、可重试、自动续期等企业级特性。
三、Redisson 快速使用（以 “秒杀一人一单” 为例）1. 引入依赖&lt;dependency&gt;    &lt;groupId&gt;org.redisson&lt;/groupId&gt;    &lt;artifactId&gt;redisson&lt;/artifactId&gt;    &lt;version&gt;3.13.6&lt;/version&gt; &lt;!-- 版本按需选择 --&gt;&lt;/dependency&gt;

2. 配置 Redisson 客户端@Configurationpublic class RedissonConfig &#123;    @Bean    public RedissonClient redissonClient() &#123;        Config config = new Config();         // 单节点配置（生产环境可替换为集群/哨兵配置）        config.useSingleServer()              .setAddress(&quot;redis://127.0.0.1:6379&quot;) // Redis地址              .setPassword(&quot;your-redis-password&quot;) // 若有密码              .setDatabase(0); // 数据库索引        return Redisson.create(config);    &#125;&#125;

3. 业务中集成分布式锁以 “秒杀下单，限制一人一单” 为例，用 Redisson 锁替换手动锁：
@Servicepublic class VoucherOrderServiceImpl implements IVoucherOrderService &#123;    @Resource    private RedissonClient redissonClient;    @Override    public Result seckillVoucher(Long voucherId) &#123;        // 1.查询优惠券        SeckillVoucher voucher = seckillVoucherService.getById(voucherId);        // 2.判断秒杀是否开始        if (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;            // 尚未开始            return Result.fail(&quot;秒杀尚未开始！&quot;);        &#125;        // 3.判断秒杀是否已经结束        if (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;            // 尚未开始            return Result.fail(&quot;秒杀已经结束！&quot;);        &#125;        // 4.判断库存是否充足        if (voucher.getStock() &lt; 1) &#123;            // 库存不足            return Result.fail(&quot;库存不足！&quot;);        &#125;                Long userId = UserHolder.getUser().getId();        //创建锁对象 这个代码不用了，因为我们现在要使用分布式锁        //SimpleRedisLock lock = new SimpleRedisLock(&quot;order:&quot; + userId, stringRedisTemplate);                // 获取“用户维度”的分布式锁（锁Key：lock:order:用户ID）        RLock lock = redissonClient.getLock(&quot;lock:order:&quot; + userId);                // 尝试加锁：最多等待1秒，锁自动释放时间10秒        boolean isLock = lock.tryLock(1, 10, TimeUnit.SECONDS);        if (!isLock) &#123;            return Result.fail(&quot;不允许重复下单&quot;);        &#125;        try &#123;            // 通过AOP代理执行事务方法（保证事务在锁的范围内）            IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();            return proxy.createVoucherOrder(voucherId);        &#125; finally &#123;            // 最终释放锁（无论业务成功/失败，避免锁泄漏）            lock.unlock();        &#125;    &#125;    // 事务方法：创建订单（省略具体逻辑）    @Transactional    public Result createVoucherOrder(Long voucherId) &#123;        // ...查询订单、扣减库存、创建订单等逻辑...        Long userId = UserHolder.getUser().getId();	synchronized(userId.toString().intern())&#123;         // 5.1.查询订单        int count = query().eq(&quot;user_id&quot;, userId).eq(&quot;voucher_id&quot;, voucherId).count();        // 5.2.判断是否存在        if (count &gt; 0) &#123;            // 用户已经购买过了            return Result.fail(&quot;用户已经购买过一次！&quot;);        &#125;        // 6.扣减库存        boolean success = seckillVoucherService.update()                .setSql(&quot;stock = stock - 1&quot;) // set stock = stock - 1                .eq(&quot;voucher_id&quot;, voucherId).gt(&quot;stock&quot;, 0) // where id = ? and stock &gt; 0                .update();        if (!success) &#123;            // 扣减失败            return Result.fail(&quot;库存不足！&quot;);        &#125;        // 7.创建订单        VoucherOrder voucherOrder = new VoucherOrder();        // 7.1.订单id        long orderId = redisIdWorker.nextId(&quot;order&quot;);        voucherOrder.setId(orderId);        // 7.2.用户id        voucherOrder.setUserId(userId);        // 7.3.代金券id        voucherOrder.setVoucherId(voucherId);        save(voucherOrder);        // 7.返回订单id        return Result.ok(orderId);    &#125;    &#125;&#125;

四、Redisson 锁的核心优势
可重入：支持同一线程多次获取同一把锁（内部通过 “线程 ID + 重入次数” 记录，避免方法嵌套导致的死锁）。
可重试：tryLock支持 “等待时间”，期间自动重试获取锁，提升高并发下的成功率。
自动续期（看门狗机制）：若业务执行时间超过锁的超时时间，Redisson 会自动延长锁的过期时间（默认每隔 30 秒续期一次，续期至 30 秒），保证业务执行期间锁不提前释放。
主从一致性优化：通过 “红锁（RedLock）” 机制，应对 Redis 主从同步延迟问题（多节点加锁，多数节点成功才算加锁成功）。
丰富的锁类型：除基础可重入锁，还支持公平锁、联锁、红锁、读写锁等，满足不同场景需求（如读多写少场景用ReadWriteLock提升并发）。

五、总结Redisson 是企业级分布式锁的优选方案，解决了手动基于 Redis 实现分布式锁的诸多缺陷。通过封装 “可重入、可重试、自动续期” 等完善的锁机制，为秒杀、订单等高并发场景提供了安全、高效的并发控制能力。
可重入锁、锁重试、看门狗机制、MutiLock一、可重入锁原理Redisson 通过 Redis Hash 结构 实现分布式可重入锁：

存储结构：以 “锁名称” 为大 Key，“线程ID + 标识” 为小 Key，Value为重入次数。




KEY
VALUE



KEY(大key)
field (小key)                    |                       value(重入次数)


lock
thread1                                                             1





加锁逻辑（Lua 脚本原子执行）：

若锁不存在（大 Key 不存在），则创建 Hash 并设置重入次数=1，同时设置锁超时时间；
若锁已存在且小 Key 匹配（当前线程持有），则重入次数+1，并重置锁超时时间；
若锁已存在但小 Key 不匹配（其他线程持有），则返回锁的剩余超时时间，触发重试逻辑。


作用：支持线程在分布式场景下 “嵌套获取同一把锁”，避免嵌套调用导致的死锁，与ReentrantLock的可重入特性一致。


可重入锁示例（解决嵌套加锁问题）场景：同一线程在嵌套方法中多次获取同一把锁，不会死锁。
@Servicepublic class ReentrantLockDemo &#123;    @Resource    private RedissonClient redissonClient;    // 外层方法    public void outerMethod() &#123;        // 获取锁（锁名称：&quot;reentrant:lock&quot;）        RLock lock = redissonClient.getLock(&quot;reentrant:lock&quot;);        lock.lock(); // 加锁（默认启用看门狗机制，超时30秒自动续期）        try &#123;            System.out.println(&quot;外层方法获取锁成功&quot;);            innerMethod(); // 调用内层方法（会再次获取同一把锁）        &#125; finally &#123;            lock.unlock(); // 释放锁（重入次数-1，最终减为0时真正释放）            System.out.println(&quot;外层方法释放锁&quot;);        &#125;    &#125;    // 内层方法（嵌套加锁）    private void innerMethod() &#123;        RLock lock = redissonClient.getLock(&quot;reentrant:lock&quot;);        lock.lock(); // 再次获取同一把锁（重入次数+1）        try &#123;            System.out.println(&quot;内层方法获取锁成功（可重入特性）&quot;);        &#125; finally &#123;            lock.unlock(); // 释放锁（重入次数-1）            System.out.println(&quot;内层方法释放锁&quot;);        &#125;    &#125;&#125;

核心点：Redisson 通过 Hash 结构记录 “线程标识” 和 “重入次数”，支持同一线程多次加锁，避免死锁。
二、重试、看门狗（WatchDog）机制一、源码解析 抢锁与重试机制lock()方法的核心逻辑是不断尝试获取锁，直到成功为止，具体流程如下：

初始抢锁判断
首先通过tryAcquire()方法尝试获取锁，内部通过 Redis 命令判断锁的状态：

若锁不存在：直接创建锁（记录当前线程 ID 和重入次数），返回null表示抢锁成功。
若锁已存在且属于当前线程：执行重入逻辑（增加重入次数），返回null表示重入成功。
若锁已存在且属于其他线程：返回锁的剩余过期时间（TTL），表示抢锁失败。


循环重试机制
当tryAcquire()返回 TTL（抢锁失败）时，lock()方法会进入while(true)循环，不断重复调用tryAcquire()重试抢锁。

重试间隔会根据锁的剩余 TTL 动态调整（避免无效自旋浪费资源）。
直到成功获取锁（返回null）才会退出循环，保证最终一定能拿到锁（只要持有锁的线程最终会释放）。



二、源码解析 WatchDog（看门狗）机制WatchDog解决 “业务执行时间 &gt; 锁超时时间” 导致的锁提前释放问题，Redisson 提供自动续期机制：

触发条件
仅当使用无参lock()方法时启用（此时leaseTime = -1）。若调用带参lock(leaseTime)（指定过期时间），则不启用 WatchDog，锁会在leaseTime后自动释放。

默认配置
看门狗的默认超时时间为 30 秒（可通过lockWatchdogTimeout配置），即初始锁的过期时间为 30 秒。

续约逻辑
当抢锁成功后，通过scheduleExpirationRenewal()开启续约任务，核心是renewExpiration()方法：

启动一个定时任务，每隔internalLockLeaseTime / 3（即 10 秒）执行一次。
任务逻辑：调用renewExpirationAsync()通过 Redis 命令将锁的过期时间重新设置为 30 秒。
若续约成功，递归调用renewExpiration()，继续设置下一个 10 秒后的定时任务，形成 “无限续约”。


自动终止条件

当线程释放锁（调用unlock()）时，会从EXPIRATION_RENEWAL_MAP中移除对应的续约任务，停止续约。
若持有锁的线程宕机，定时任务无法继续执行，续约终止，锁会在 30 秒后自动过期释放，避免死锁



三、核心逻辑总结
抢锁与重试：通过while(true)循环不断调用tryAcquire()，直到成功获取锁，确保最终能拿到锁。
WatchDog 续约：无参lock()时，默认 30 秒过期，每 10 秒自动续约一次，保证业务未完成时锁不会提前释放。
安全性保障：线程宕机后续约终止，锁自动过期；显式释放锁时终止续约，避免资源泄露

四、看门狗机制示例（自动续期，防止锁提前释放）场景：业务执行时间较长（超过初始锁超时时间），锁会自动续期，保证业务完成前不释放。
@Servicepublic class WatchDogDemo &#123;    @Resource    private RedissonClient redissonClient;    public void longTimeBusiness() throws InterruptedException &#123;        RLock lock = redissonClient.getLock(&quot;watchdog:lock&quot;);        // 无参lock()：默认启用看门狗，初始超时30秒，每10秒自动续期        lock.lock();         try &#123;            System.out.println(&quot;获取锁成功，开始执行长时间业务...&quot;);            // 模拟业务执行40秒（超过初始30秒超时）            Thread.sleep(40000);             System.out.println(&quot;业务执行完毕&quot;);        &#125; finally &#123;            lock.unlock(); // 业务完成后手动释放锁            System.out.println(&quot;释放锁&quot;);        &#125;    &#125;&#125;

核心点：

若业务未执行完，Redisson 会每隔 10 秒自动将锁超时时间重置为 30 秒（无需手动续期）；
若线程宕机，看门狗线程也会终止，锁最终会超时释放（避免死锁）。

三、MultiLock（红锁）原理为解决 Redis主从同步延迟导致的锁丢失问题（如主机宕机后，从机升主但未同步锁数据），Redisson 提供多节点加锁的MultiLock：

核心逻辑：要求在多个独立的 Redis 节点（非主从架构）上同时加锁，只有超过半数节点加锁成功，才算整体加锁成功；释放时，所有节点的锁都会被释放。
可靠性保证：即使部分 Redis 节点故障，只要多数节点正常，就能保证锁的安全性（类似 “分布式共识”）。
适用场景：对锁可靠性要求极高的场景（如金融交易），通过多节点冗余提升锁的容错性。

MultiLock 示例（解决主从一致性问题）场景：通过多节点加锁，确保 Redis 主从切换时锁不丢失（需部署多个独立 Redis 节点）。
1. 配置多节点 Redisson 客户端
@Beanpublic RedissonClient redissonMultiNodeClient() &#123;    Config config = new Config();    // 配置3个独立的Redis节点（非主从关系）    config.useClusterServers()          .addNodeAddress(              &quot;redis://127.0.0.1:6379&quot;,              &quot;redis://127.0.0.1:6380&quot;,              &quot;redis://127.0.0.1:6381&quot;          );    return Redisson.create(config);&#125;

2. 使用 MultiLock
@Servicepublic class MultiLockDemo &#123;    @Resource    private RedissonClient redissonMultiNodeClient;    public void multiLockBusiness() &#123;        // 获取3个节点的锁（锁名称需一致）        RLock lock1 = redissonMultiNodeClient.getLock(&quot;multi:lock&quot;);        RLock lock2 = redissonMultiNodeClient.getLock(&quot;multi:lock&quot;);        RLock lock3 = redissonMultiNodeClient.getLock(&quot;multi:lock&quot;);        // 创建MultiLock（组合3个节点的锁）        RedissonMultiLock multiLock = new RedissonMultiLock(lock1, lock2, lock3);        // 加锁：需所有节点加锁成功才算成功（默认超时30秒，启用看门狗）        multiLock.lock();        try &#123;            System.out.println(&quot;MultiLock加锁成功，执行核心业务...&quot;);        &#125; finally &#123;            multiLock.unlock(); // 释放所有节点的锁            System.out.println(&quot;MultiLock释放锁&quot;);        &#125;    &#125;&#125;

核心点：

MultiLock 要求所有节点加锁成功才算整体加锁成功；
即使某一节点宕机，其他节点仍持有锁，避免锁丢失（适合高可靠性场景）。

常用 API 说明


方法
作用
示例



lock()
加锁（默认 30 秒超时，自动续期）
lock.lock();


lock(long leaseTime, TimeUnit unit)
加锁（指定超时时间，不自动续期）
lock.lock(10, TimeUnit.SECONDS);


tryLock(long waitTime, long leaseTime, TimeUnit unit)
尝试加锁（最多等待 waitTime，超时释放）
boolean success = lock.tryLock(5, 10, TimeUnit.SECONDS);


unlock()
释放锁
lock.unlock();


总结Redisson 通过可重入结构、看门狗续期、MultiLock 多节点共识，解决了手动 Redis 锁的 “不可重入、超时失控、主从一致性” 等缺陷，是企业级分布式锁的成熟解决方案。
]]></content>
      <categories>
        <category>黑马点评</category>
      </categories>
  </entry>
  <entry>
    <title>09-Redis消息队列</title>
    <url>/2025/10/12/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/09-Redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[Redis 消息队列核心知识点总结一、消息队列的基础价值消息队列（Message Queue）包含 生产者（发送消息）、消息队列（存储与管理消息）、消费者（获取并处理消息）三个核心角色，核心作用是 解耦（生产者与消费者通过队列间接通信，避免一方等待另一方，典型场景如秒杀：生产者校验下单资格后发消息，消费者异步处理下单，大幅提升响应速度）。
二、Redis 实现消息队列的三种方式1. 基于List的消息队列
原理：利用 Redis List（双向链表）的 LPUSH（左端添加消息） + BRPOP（右端阻塞获取消息，队列空时持续等待），模拟 “先进先出” 的队列逻辑。
核心命令：
生产者：LPUSH queue:xxx &quot;msg&quot;（向队列 queue:xxx 左侧推送消息）。
消费者：BRPOP queue:xxx 0（从队列右侧阻塞获取消息，0 表示 “永久阻塞”，直到有消息）。


优缺点：
优点：
存储依赖 Redis，不受 JVM 内存容量限制；
借助 Redis 持久化（RDB&#x2F;AOF），数据安全性有基础保障；
天然支持 消息有序性（List 是有序链表，消息按入队顺序消费）。


缺点：
无 “消费确认” 机制，消息丢失风险高（如消费者处理失败未重试）；
仅支持 单消费者（同一条消息只能被一个消费者获取，无法多消费组共享）。





2. 基于PubSub（发布 - 订阅）的消息队列
原理：采用 “发布 - 订阅” 模型，生产者向**频道（Channel）**发布消息，消费者订阅频道后可实时接收消息，支持**多生产者、多消费者**。
核心命令：
生产者：PUBLISH channel:xxx &quot;msg&quot;（向频道 channel:xxx 发布消息）。
消费者：SUBSCRIBE channel:xxx（订阅指定频道，实时接收消息）；或 PSUBSCRIBE channel:*（通配符订阅，匹配所有 channel:* 格式的频道）。


优缺点：
优点：
支持 多生产者、多消费者（多个生产者可发同一频道，多个消费者可订阅同一频道）；
订阅关系灵活（PSUBSCRIBE 支持通配符，批量订阅匹配频道）。


缺点：
不支持数据持久化（Redis 重启后，订阅关系和未消费的消息会直接丢失）；
无消息确认机制，消息丢失无法避免；
消息堆积有上限（依赖 Redis 内存，堆积过多会导致消息丢失）。





3. 基于Stream的消息队列（Redis 5.0+，企业级首选）Stream是 Redis 专为消息队列设计的类型，支持 持久化、消费组、消息确认、消息回溯 等企业级特性，是生产环境的首选方案。
（1）基础生产与消费
生产消息：XADD key * field1 value1 field2 value2 ...（*表示 Redis 自动生成消息 ID，格式为 “时间戳 - 递增数”，消息以key-value键值对形式存储）。

示例：XADD users * name jack age 21（向users队列发送消息，内容为 &#123;name: &quot;jack&quot;, age: 21&#125;）。


消费消息：
XREAD COUNT n BLOCK millis STREAMS key ID（COUNT 限制单次读取数量；BLOCK配置阻塞时长（毫秒）；ID为起始消息 ID，0表示从第一条消息开始读，$表示从最新消息开始读）。

示例：XREAD COUNT 1 STREAMS users 0（从users队列的第一条消息开始，读取 1 条消息）；
阻塞消费示例：XREAD COUNT 1 BLOCK 1000 STREAMS users $（阻塞 1 秒，读取users队列的最新消息）。



（2）消费组（Consumer Group）：核心企业级特性消费组将多个消费者划分到一个组中，共同监听同一个队列，具备 消息分流、进度标记、消息确认 三大核心能力：

创建消费组：XGROUP CREATE key groupName ID [MKSTREAM]（ID 为起始消息 ID，$ 表示从最新消息开始，0 表示从第一条消息开始；MKSTREAM 表示队列不存在时自动创建）。
从消费组消费：XREADGROUP GROUP group consumer COUNT n BLOCK millis STREAMS key &gt;（group 为消费组名称；consumer 为消费者名称（自动创建）；&gt; 表示从 “未被消费的消息” 开始读取）。
消息确认：XACK key groupName msgId（消费者处理完消息后，需手动确认消息，确认后消息会从 pending-list（未确认消息列表）中移除，保证 “消息至少被消费一次”）。

（3）优缺点
优点：
支持持久化（消息存储在 Redis 中，依赖 Redis 自身的持久化机制（RDB&#x2F;AOF）保障数据安全）；
支持阻塞读取（XREAD/XREADGROUP 均支持 BLOCK 参数，实现消费者阻塞等待消息）；
消息分流（消费组内多个消费者可分摊消息，提升整体处理速度）；
消息确认（ACK）：通过XACK保证消息 “至少被消费一次”，避免丢失；
消息回溯：可通过指定ID重新消费历史消息（如处理失败后重试）。


缺点：
依赖 Redis 集群的稳定性（需保证 Redis 部署高可用，否则队列服务会受影响）；
复杂场景下（如大量消费组、高消息堆积）需关注 Redis 性能。



三、三种实现方式的对比与适用场景


实现方式
消息持久化
阻塞读取
消息确认
多消费者共享
适用场景



List
支持
支持
不支持
不支持
单消费者、对有序性要求高的轻量场景


PubSub
不支持
支持
不支持
支持
实时广播（如通知）、无持久化要求的场景


Stream
支持
支持
支持
支持
企业级消息队列（秒杀、订单异步处理等强可靠性场景）


四、Stream在 “异步秒杀下单” 中的实战应用秒杀场景中，通过Stream实现 “Redis 前置校验 + 异步下单” 的核心流程：

生产者（秒杀接口）：通过 Lua 脚本原子性校验 “库存是否充足”“是否一人一单”，校验通过后，用XADD向stream.orders队列发送消息（包含voucherId、userId、orderId等关键信息）。
消费者（后台线程）：项目启动时，创建消费组（如XGROUP CREATE stream.orders g1 0 MKSTREAM），并启动线程循环执行：
通过XREADGROUP阻塞消费stream.orders的消息；
拿到消息后，执行 “扣减数据库库存、创建订单” 的业务逻辑；
业务完成后，通过XACK确认消息，避免重复消费。


异常处理：若消息处理失败，会暂存于pending-list（未确认消息列表），消费者需通过重试逻辑（如定时读取pending-list）处理失败消息，保证 “至少消费一次”。

基于 Redis Stream 实现异步秒杀下单的核心逻辑总结一、需求与核心思路通过 Redis Stream 作为消息队列，将 “秒杀资格校验” 与 “订单创建（扣库存、写订单）” 解耦：

秒杀接口（生产者）：校验通过后，向 Stream 发送 “待下单” 消息；
后台线程（消费者）：持续从 Stream 读取消息，异步执行下单逻辑；
利用 Stream 的消费组、消息确认、Pending-List 保证消息可靠消费。

二、关键步骤与代码解析1.Lua 脚本：校验通过后发送消息到 Stream在原秒杀校验 Lua 脚本中，新增 “发送消息到 Stream” 的逻辑：
-- 3.6 发送消息到Stream队列（stream.orders）redis.call(&#x27;xadd&#x27;, &#x27;stream.orders&#x27;, &#x27;*&#x27;, &#x27;userId&#x27;, userId, &#x27;voucherId&#x27;, voucherId, &#x27;id&#x27;, orderId)


xadd stream.orders * ...：向stream.orders添加消息，* 表示由 Redis 自动生成唯一消息 ID（格式：时间戳-递增序号）；
消息内容包含 userId（用户 ID）、voucherId（优惠券 ID）、orderId（订单 ID），为后续下单提供参数。

2. 消费者线程：持续读取并处理 Stream 消息通过内部类 VoucherOrderHandler 实现Runnable，后台线程循环消费 Stream 消息：
private class VoucherOrderHandler implements Runnable &#123;    @Override    public void run() &#123;        while (true) &#123;            try &#123;                // 1.获取消息队列中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 &gt;                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(                    Consumer.from(&quot;g1&quot;, &quot;c1&quot;),                    StreamReadOptions.empty().count(1).block(Duration.ofSeconds(2)),                    StreamOffset.create(&quot;stream.orders&quot;, ReadOffset.lastConsumed())                );                // 2.判断订单信息是否为空                if (list == null || list.isEmpty()) &#123;                    // 如果为null，说明没有消息，继续下一次循环                    continue;                &#125;                // 解析数据                MapRecord&lt;String, Object, Object&gt; record = list.get(0);                Map&lt;Object, Object&gt; value = record.getValue();                VoucherOrder voucherOrder = BeanUtil.fillBeanWithMap(value, new VoucherOrder(), true);                // 3.创建订单                createVoucherOrder(voucherOrder);                // 4.确认消息 XACK                stringRedisTemplate.opsForStream().acknowledge(&quot;s1&quot;, &quot;g1&quot;, record.getId());            &#125; catch (Exception e) &#123;                log.error(&quot;处理订单异常&quot;, e);                //处理异常消息                handlePendingList();            &#125;        &#125;    &#125;    private void handlePendingList() &#123;        while (true) &#123;            try &#123;                // 1.获取pending-list中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 0                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(                    Consumer.from(&quot;g1&quot;, &quot;c1&quot;),                    StreamReadOptions.empty().count(1),                    StreamOffset.create(&quot;stream.orders&quot;, ReadOffset.from(&quot;0&quot;))                );                // 2.判断订单信息是否为空                if (list == null || list.isEmpty()) &#123;                    // 如果为null，说明没有异常消息，结束循环                    break;                &#125;                // 解析数据                MapRecord&lt;String, Object, Object&gt; record = list.get(0);                Map&lt;Object, Object&gt; value = record.getValue();                VoucherOrder voucherOrder = BeanUtil.fillBeanWithMap(value, new VoucherOrder(), true);                // 3.创建订单                createVoucherOrder(voucherOrder);                // 4.确认消息 XACK                stringRedisTemplate.opsForStream().acknowledge(&quot;s1&quot;, &quot;g1&quot;, record.getId());            &#125; catch (Exception e) &#123;                log.error(&quot;处理pendding订单异常&quot;, e);                try&#123;                    Thread.sleep(20);                &#125;catch(Exception e)&#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;

关键细节：

消费组（Consumer Group）：Consumer.from(&quot;g1&quot;, &quot;c1&quot;) 表示 “消费组 g1 中的消费者 c1”，多个消费者可加入同一组，分摊消息处理压力；
阻塞读取：block(Duration.ofSeconds(2)) 避免无消息时的 “空轮询”，降低资源消耗；
消息位置：ReadOffset.lastConsumed() 表示 “从上次消费的最后位置继续读”，保证消息不重复、不遗漏；
消息确认（ACK）：acknowledge(...) 通知 Redis “消息已处理完成”，否则消息会留在Pending-List（未确认消息列表）中，供后续重试。

3. 异常处理：Pending-List 重试机制当消息处理过程中报错（如服务宕机、数据库异常），消息会暂存于Pending-List，需通过重试保证 “至少消费一次”：
private void handlePendingList() &#123;    while (true) &#123;        try &#123;            // 1. 从Pending-List读取未确认消息（从ID=0开始，读取所有未确认消息）            List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(                Consumer.from(&quot;g1&quot;, &quot;c1&quot;),                StreamReadOptions.empty().count(1),                StreamOffset.create(&quot;stream.orders&quot;, ReadOffset.from(&quot;0&quot;))            );            // 2. 无异常消息则退出循环            if (list == null || list.isEmpty()) break;            // 3. 解析并重新处理消息（同正常消费逻辑）            MapRecord&lt;String, Object, Object&gt; record = list.get(0);            Map&lt;Object, Object&gt; value = record.getValue();            VoucherOrder voucherOrder = BeanUtil.fillBeanWithMap(value, new VoucherOrder(), true);            //创建订单            createVoucherOrder(voucherOrder);            // 4. 确认消息 XACK（从Pending-List移除）            stringRedisTemplate.opsForStream().acknowledge(&quot;stream.orders&quot;, &quot;g1&quot;, record.getId());        &#125; catch (Exception e) &#123;            log.error(&quot;处理Pending订单异常&quot;, e);            try&#123;            	Thread.sleep(20); // 重试间隔，避免频繁失败            &#125;catch(Exception e)&#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;

核心作用：

ReadOffset.from(&quot;0&quot;)：表示 “从 Pending-List 的第一条消息开始读取”，确保所有未确认的消息都能被重试；
Thread.sleep(20)：异常时短暂休眠，避免 “失败 - 立即重试 - 再失败” 的死循环，减轻系统压力。

三、Redis Stream 的核心特性与价值
消费组（Consumer Group）：
多消费者可加入同一组，分摊消息处理压力，提升整体消费速度；
消费组会记录每个消费者的 “消费进度”，避免同一条消息被多个消费者重复消费。


消息确认（ACK）与 Pending-List：
消息被读取后，需手动调用XACK确认，否则会暂存于Pending-List；
保证 “消息处理失败时可重试”，避免订单丢失，实现 “至少一次消费” 的可靠性。


异步解耦：
秒杀接口只需 “发消息”，无需等待订单创建完成，响应速度提升数倍；
下单逻辑由后台线程异步执行，不占用 Tomcat 请求线程，系统并发能力大幅增强。



四、总结基于 Redis Stream 的异步秒杀下单，通过 “消费组分流 + 消息确认 + Pending-List 重试”，完美解决了 “高并发响应” 与 “订单可靠性” 的矛盾：

秒杀接口响应更快（异步解耦）；
订单创建更可靠（消息不丢失、失败可重试）；
系统更稳定（请求线程与业务线程分离，资源占用更合理）。

相比 Redis List、PubSub，Stream 提供了更企业级的消息队列能力，是秒杀、订单异步处理等核心场景的优选方案。
总结Redis 提供了从 “轻量简单” 到 “企业级可靠” 的消息队列方案：

List适合单消费者、有序性要求高的轻量场景；
PubSub适合实时广播、无持久化要求的场景；
Stream是生产级消息队列的首选，尤其在秒杀、订单异步处理等对 “可靠性、可追溯、多消费者协同” 有要求的场景中，能有效解耦系统并保证消息一致性。

]]></content>
      <categories>
        <category>黑马点评</category>
      </categories>
  </entry>
  <entry>
    <title>11-好友关注</title>
    <url>/2025/10/12/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/11-%E5%A5%BD%E5%8F%8B%E5%85%B3%E6%B3%A8/</url>
    <content><![CDATA[一、好友关注一、基础功能：关注与取消关注业务场景：支持用户对其他用户执行 “关注”“取消关注” 操作，及查询 “是否已关注” 状态。
技术实现：

表结构：tb_follow 存储关注关系

核心字段 user_id（关注者 ID）
follow_user_id（被关注者 ID）
create_time&#96;（关注时间）。

注意: 这里把主键修改为自增长，简化开发。

接口设计：

关注 &#x2F; 取关：PUT  /follow/&#123;id&#125;/&#123;isFollow&#125;，通过 isFollow 布尔值切换关注状态；
查询关注状态：GET  /follow/or/not/&#123;id&#125;，统计数据库中关系记录的存在性。

FollowController：
//关注@PutMapping(&quot;/&#123;id&#125;/&#123;isFollow&#125;&quot;)public Result follow(@PathVariable(&quot;id&quot;) Long followUserId, @PathVariable(&quot;isFollow&quot;) Boolean isFollow) &#123;    return followService.follow(followUserId, isFollow);&#125;//取消关注@GetMapping(&quot;/or/not/&#123;id&#125;&quot;)public Result isFollow(@PathVariable(&quot;id&quot;) Long followUserId) &#123;      return followService.isFollow(followUserId);&#125;

核心逻辑：

关注：向 tb_follow 插入记录；
取消关注：从 tb_follow 删除对应记录；
依赖 UserHolder（基于 ThreadLocal）获取当前登录用户 ID，识别 “操作发起者”。

FollowService：
//取消关注service@Overridepublic Result isFollow(Long followUserId) &#123;        // 1.获取登录用户        Long userId = UserHolder.getUser().getId();        // 2.查询是否关注 select count(*) from tb_follow where user_id = ? and follow_user_id = ?        Integer count = query().eq(&quot;user_id&quot;, userId).eq(&quot;follow_user_id&quot;, followUserId).count();        // 3.判断        return Result.ok(count &gt; 0);    &#125;// 关注service @Override    public Result follow(Long followUserId, Boolean isFollow) &#123;        // 1.获取登录用户        Long userId = UserHolder.getUser().getId();        String key = &quot;follows:&quot; + userId;        // 1.判断到底是关注还是取关        if (isFollow) &#123;            // 2.关注，新增数据            Follow follow = new Follow();            follow.setUserId(userId);            follow.setFollowUserId(followUserId);            boolean isSuccess = save(follow);        &#125; else &#123;            // 3.取关，删除 delete from tb_follow where user_id = ? and follow_user_id = ?            remove(new QueryWrapper&lt;Follow&gt;()                    .eq(&quot;user_id&quot;, userId).eq(&quot;follow_user_id&quot;, followUserId));        &#125;        return Result.ok();    &#125;

查看用户详情、查询用户笔记想要去看共同关注的好友，需要首先进入到这个页面，这个页面会发起两个请求
1、去查询用户的详情
2、去查询用户的笔记
以上两个功能和共同关注没有什么关系，但是需要完善功能，保证功能完整。
// UserController 根据id查询用户@GetMapping(&quot;/&#123;id&#125;&quot;)public Result queryUserById(@PathVariable(&quot;id&quot;) Long userId)&#123;	// 查询详情	User user = userService.getById(userId);	if (user == null) &#123;		return Result.ok();	&#125;	UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class);	// 返回	return Result.ok(userDTO);&#125;// BlogController  根据id查询博主的探店笔记@GetMapping(&quot;/of/user&quot;)public Result queryBlogByUserId(		@RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;) Integer current,		@RequestParam(&quot;id&quot;) Long id) &#123;	// 根据用户查询	Page&lt;Blog&gt; page = blogService.query()			.eq(&quot;user_id&quot;, id).page(new Page&lt;&gt;(current, SystemConstants.MAX_PAGE_SIZE));	// 获取当前页数据	List&lt;Blog&gt; records = page.getRecords();	return Result.ok(records);&#125;

二、拓展功能：共同关注（Redis Set 应用）业务场景：展示 “当前用户” 与 “目标博主” 的共同关注列表。
技术升级（Redis Set 优化）：

改造关注逻辑（双写数据库与 Redis）：

关注时：除写入 tb_follow，还向 Redis Set（键为 follows:&#123;userId&#125;）添加 follow_user_id；
取关时：除删除 tb_follow 记录，还从 Redis Set 移除对应 follow_user_id；
目的：利用 Redis Set 的集合运算能力，快速实现 “共同关注” 查询。

FollowServiceImpl
@Overridepublic Result follow(Long followUserId, Boolean isFollow) &#123;    // 1.获取登录用户    Long userId = UserHolder.getUser().getId();    String key = &quot;follows:&quot; + userId;    // 1.判断到底是关注还是取关    if (isFollow) &#123;        // 2.关注，新增数据        Follow follow = new Follow();        follow.setUserId(userId);        follow.setFollowUserId(followUserId);        boolean isSuccess = save(follow);        if (isSuccess) &#123;            // 把关注用户的id，放入redis的set集合 sadd userId followerUserId            stringRedisTemplate.opsForSet().add(key, followUserId.toString());        &#125;    &#125; else &#123;        // 3.取关，删除 delete from tb_follow where user_id = ? and follow_user_id = ?        boolean isSuccess = remove(new QueryWrapper&lt;Follow&gt;()                .eq(&quot;user_id&quot;, userId).eq(&quot;follow_user_id&quot;, followUserId));        if (isSuccess) &#123;            // 把关注用户的id从Redis集合中移除            stringRedisTemplate.opsForSet().remove(key, followUserId.toString());        &#125;    &#125;    return Result.ok();&#125;

共同关注实现：

分别获取 “当前用户的关注集合（follows:&#123;currentUserId&#125;）” 和 “目标博主的关注集合（follows:&#123;bloggerId&#125;）”；
通过 opsForSet().intersect(key1, key2) 求两个 Set 的交集（即共同关注的用户 ID）；
根据交集 ID 查询用户信息，返回共同关注列表。

FollowServiceImpl
@Overridepublic Result followCommons(Long id) &#123;    // 1.获取当前用户    Long userId = UserHolder.getUser().getId();    String key = &quot;follows:&quot; + userId;    // 2.求交集    String key2 = &quot;follows:&quot; + id;    Set&lt;String&gt; intersect = stringRedisTemplate.opsForSet().intersect(key, key2);    if (intersect == null || intersect.isEmpty()) &#123;        // 无交集        return Result.ok(Collections.emptyList());    &#125;    // 3.解析id集合    List&lt;Long&gt; ids = intersect.stream().map(Long::valueOf).collect(Collectors.toList());    // 4.查询用户    List&lt;UserDTO&gt; users = userService.listByIds(ids)            .stream()            .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))            .collect(Collectors.toList());    return Result.ok(users);&#125;

三、技术要点与优势
Redis Set 的核心价值：
元素唯一性：天然保证 “关注关系无重复”；
高效集合运算：交集/并集/差集 操作时间复杂度为 O (n)，远超数据库 JOIN 查询，适合 “共同关注” 等场景；
轻量缓存：相比数据库，Redis 操作更高效，降低数据库压力。


用户上下文传递：
依赖 UserHolder（ThreadLocal 封装）传递当前登录用户 ID，简化 “操作用户识别” 逻辑。


数据一致性：
关注 &#x2F; 取关需同时维护数据库和 Redis（双写）；若对一致性要求极高，可采用 “数据库为源，Redis 定期同步” 的最终一致性方案。



四、总结“好友关注” 模块体现了 “数据库存事实、缓存存计算型数据” 的分层设计思想：基础关注关系由数据库持久化，而 “共同关注” 这类需集合运算的场景，通过 Redis Set 优化性能与逻辑复杂度，是缓存辅助业务的典型实践。
二、好友关注 - Feed流实现方法一、Feed 流的概念与模式

对于传统的模式的内容解锁：我们是需要用户去通过搜索引擎或者是其他的方式去解锁想要看的内容
对于新型的Feed流的的效果：不需要我们用户再去推送信息，而是系统分析用户到底想要什么，然后直接把内容推送给用户，从而使用户能够更加的节约时间，不用主动去寻找。


Feed 流（“投喂” 流）是为用户持续提供沉浸式内容的机制，让用户无需主动搜索即可获取感兴趣信息。
Feed流产品有两种常见模式：Timeline：不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注。例如朋友圈

优点：信息全面，不会有缺失。并且实现也相对简单
缺点：信息噪音较多，用户不一定感兴趣，内容获取效率低

智能排序：利用智能算法屏蔽掉违规的、用户不感兴趣的内容。推送用户感兴趣信息来吸引用户

优点：投喂用户感兴趣信息，用户粘度很高，容易沉迷
缺点：如果算法不精准，可能起到反作用本例中的个人页面，是基于关注的好友来做Feed流，因此采用Timeline的模式。该模式的实现方案有三种：

本例中的个人页面，是基于关注的好友来做Feed流，因此采用Timeline的模式。（按内容发布时间排序，展示关注用户的动态）。
Timeline模式的实现方案有三种：



模式
核心逻辑
优点
缺点



拉模式（读扩散）
用户读取时，从所有关注对象中拉取内容后聚合排序。
节省存储（无冗余推送）
读取延迟高、高并发压力大


推模式（写扩散）
内容发布时，主动推送到所有粉丝的 “收件箱”。
读取时效快
大 V 粉丝多时有存储压力


推拉结合
普通用户用 “推模式”，大 V 用 “拉模式”，平衡存储与读取。
兼顾两者优势
逻辑复杂


二、好友关注场景的 Feed 流实现（推模式）需求：

修改新增探店笔记的业务，在保存blog到数据库的同时，推送到粉丝的Redis收件箱
收件箱满足可以根据时间戳排序，必须用Redis的数据结构实现
查询收件箱数据时，可以实现分页查询

推送逻辑（发布笔记时触发）
用户发布笔记时，需完成 “保存笔记 + 向所有粉丝推送”：

保存笔记到数据库；
查询该用户的所有粉丝；
用 Redis SortedSet 向每个粉丝的 “收件箱” 推送笔记 ID（score为当前时间戳，保证按时间排序）。

核心代码：
@Overridepublic Result saveBlog(Blog blog) &#123;    // 1.获取登录用户    UserDTO user = UserHolder.getUser();    blog.setUserId(user.getId());    // 2.保存探店笔记    boolean isSuccess = save(blog);    if(!isSuccess)&#123;        return Result.fail(&quot;新增笔记失败!&quot;);    &#125;    // 3.查询笔记作者的所有粉丝 select * from tb_follow where follow_user_id = ?    List&lt;Follow&gt; follows = followService.query().eq(&quot;follow_user_id&quot;, user.getId()).list();    // 4.推送笔记id给所有粉丝    for (Follow follow : follows) &#123;        // 4.1.获取粉丝id        Long fanId = follow.getUserId();        // 4.2.推送        String key = FEED_KEY + fanId;        stringRedisTemplate.opsForZSet().add(key, blog.getId().toString(), System.currentTimeMillis());    &#125;    // 5.返回id    return Result.ok(blog.getId());&#125;

三、好友关注 - 滚动分页查询（粉丝读取收件箱）需求：在个人主页的“关注”卡片中，查询并展示推送的Blog信息：
具体操作如下：

每次查询完成后，我们要分析出查询出数据的最小时间戳，这个值会作为下一次查询的条件

我们需要找到与上一次查询相同的查询个数作为偏移量，下次查询时，跳过这些查询过的数据，拿到我们需要的数据


传统分页（page+size）会因 Feed 流实时更新导致重复 &#x2F; 缺失，需用 “最小时间戳 + 偏移量” 实现滚动分页：

请求参数：lastId（上一次查询的最小时间戳）、offset（偏移量，跳过重复数据）；
Redis 操作：用ZREVRANGEBYSCORE按时间戳倒序查询，范围0 ~ lastId，跳过offset条后取指定数量；
结果处理：解析笔记 ID、计算新的minTime（本次查询的最小时间戳）和offset（下次查询的偏移量）。

定义出来具体的返回值实体类:
@Datapublic class ScrollResult &#123;    private List&lt;?&gt; list;    private Long minTime;    private Integer offset;&#125;

BlogController:
@GetMapping(&quot;/of/follow&quot;)public Result queryBlogOfFollow(    @RequestParam(&quot;lastId&quot;) Long max, @RequestParam(value = &quot;offset&quot;, defaultValue = &quot;0&quot;) Integer offset)&#123;    return blogService.queryBlogOfFollow(max, offset);&#125;

注意：RequestParam 表示接受url地址栏传参的注解，当方法上参数的名称和url地址栏不相同时，可以通过RequestParam 来进行指定
核心代码 BlogServiceImpl：
@Overridepublic Result queryBlogOfFollow(Long max, Integer offset) &#123;    // 1.获取当前用户    Long userId = UserHolder.getUser().getId();    // 2.查询收件箱 ZREVRANGEBYSCORE key Max Min LIMIT offset count    String key = FEED_KEY + userId;        //从Redis收件箱查询：倒序、范围0~max、跳过offset条、取2条    Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTuples = stringRedisTemplate.opsForZSet()        .reverseRangeByScoreWithScores(key, 0, max, offset, 2);    // 3.非空判断    if (typedTuples == null || typedTuples.isEmpty()) &#123;        return Result.ok();    &#125;    // 4.解析数据：blogId、minTime（时间戳）、offset    List&lt;Long&gt; blogIds = new ArrayList&lt;&gt;(typedTuples.size());    long minTime = 0;     int os = 1; //newOffset 初始偏移量    for (ZSetOperations.TypedTuple&lt;String&gt; tuple : typedTuples) &#123;         // 4.1.获取id        blogIds.add(Long.valueOf(tuple.getValue()));        // 4.2.获取分数(时间戳）        long time = tuple.getScore().longValue();        if(time == minTime)&#123;            os++;// 相同时间戳，偏移量+1        &#125;else&#123;            minTime = time;            os = 1;// 新时间戳，重置偏移量        &#125;    &#125;	os = minTime == max ? os : os + offset;    // 5.根据id查询blog    String idStr = StrUtil.join(&quot;,&quot;, blogIds);    List&lt;Blog&gt; blogs = query().in(&quot;id&quot;, blogIds).last(&quot;ORDER BY FIELD(id,&quot; + idStr + &quot;)&quot;).list();    for (Blog blog : blogs) &#123;        // 5.1.查询blog有关的用户        queryBlogUser(blog);        // 5.2.查询blog是否被点赞        isBlogLiked(blog);    &#125;    // 6.封装并返回（含下次查询的minTime和offset）    ScrollResult result = new ScrollResult();    result.setList(blogs);    result.setOffset(os);    result.setMinTime(minTime);    return Result.ok(result);&#125;

四、技术要点与价值
Redis SortedSet 的核心作用：

按score（时间戳）排序，天然支持 “按发布时间倒序” 的 Timeline 需求；
支持范围查询（ZREVRANGEBYSCORE），结合offset实现滚动分页，解决传统分页的 “重复 &#x2F; 缺失” 问题。


推模式的适用场景：
好友关注场景中，用户粉丝量通常不大，推模式的 “存储压力” 可接受，且能保证读取时效（粉丝直接从自己的收件箱取数据，无需实时聚合）。

滚动分页的逻辑：
通过 “记录上次查询的最小时间戳 + 相同时间戳的偏移量”，确保每次查询 “接着上一次的位置继续读”，既不重复也不遗漏。


总结好友关注的 Feed 流采用 推模式 + Redis SortedSet + 滚动分页，既保证了 “关注动态的实时推送”，又解决了 “Feed 流实时更新导致的分页混乱” 问题，是 “写扩散” 在中小规模粉丝场景下的典型实践。
]]></content>
      <categories>
        <category>黑马点评</category>
      </categories>
  </entry>
  <entry>
    <title>13-用户签到</title>
    <url>/2025/10/12/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/13-%E7%94%A8%E6%88%B7%E7%AD%BE%E5%88%B0/</url>
    <content><![CDATA[
三个&gt;是无符号的右移，而两个&gt;是有符号的右移

用户签到一、签到功能的存储优化：BitMap（位图）传统用数据库表（如tb_sign）存储签到记录，会因 “用户 + 日期” 的维度组合产生大量冗余数据。而 BitMap（位图） 利用位运算极大压缩存储成本：

原理：用 1 个 bit（0&#x2F;1） 表示 “某用户某天是否签到”，1 字节（8bit）可存储 8 天的签到状态；
Redis 支持：基于 String 类型实现，通过SETBIT&#x2F;GETBIT等命令操作，单个 Key 最大支持2^32个 bit（约 512MB，可覆盖超大规模场景）。

Redis中是利用string类型数据结构实现BitMap，因此最大上限是512M，转换为bit则是 2^32个bit位。
正因为BitMap底层是基于String数据结构，因此其操作也都封装在字符串相关操作中了。
BitMap的操作命令有：

SETBIT：向指定位置（offset）存入一个0或1
GETBIT ：获取指定位置（offset）的bit值
BITCOUNT ：统计BitMap中值为1的bit位的数量
BITFIELD ：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值
BITFIELD_RO ：获取BitMap中bit数组，并以十进制形式返回
BITOP ：将多个BitMap的结果做位运算（与 、或、异或）
BITPOS ：查找bit数组中指定范围内第一个0或1出现的位置

二、签到功能实现（Redis BitMap）业务需求：用户每日签到，记录状态并统计连续签到天数。
1. 单日签到（SETBIT）
Key 设计：sign:&#123;userId&#125;:&#123;yyyyMM&#125;（按 “用户 + 年月” 分组，便于按月统计）；
Offset 计算：当月第n天的偏移量为n-1（如 5 号的偏移量是 4）；

UserController
@PostMapping(&quot;/sign&quot;)public Result sign()&#123;   return userService.sign();&#125;

UserServiceImpl
@Overridepublic Result sign() &#123;    // 1.获取当前登录用户    Long userId = UserHolder.getUser().getId();    // 2.获取日期    LocalDateTime now = LocalDateTime.now();    // 3.拼接key    String keySuffix = now.format(DateTimeFormatter.ofPattern(&quot;:yyyyMM&quot;));    String key = USER_SIGN_KEY + userId + keySuffix;    // 4.获取今天是本月的第几天    int dayOfMonth = now.getDayOfMonth();    // 5.写入Redis SETBIT key offset 1    stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - 1, true);    return Result.ok();&#125;

2. 连续签到统计（BITFIELD + 位运算）核心逻辑：从 “当天” 向前遍历 BitMap，统计连续为1的位数（即连续签到天数）。

步骤：
用BITFIELD获取 “当月截止今天” 的所有签到位（返回十进制数）；
通过  位与（&amp;） 和 右移（&gt;&gt;&gt;） 遍历每一位，统计连续1的次数；



UserController
@GetMapping(&quot;/sign/count&quot;)public Result signCount()&#123;    return userService.signCount();&#125;

UserServiceImpl
@Overridepublic Result signCount() &#123;    // 1.获取当前登录用户    Long userId = UserHolder.getUser().getId();    // 2.获取日期    LocalDateTime now = LocalDateTime.now();    // 3.拼接key    String keySuffix = now.format(DateTimeFormatter.ofPattern(&quot;:yyyyMM&quot;));    String key = USER_SIGN_KEY + userId + keySuffix;    // 4.获取今天是本月的第几天    int dayOfMonth = now.getDayOfMonth();    // 5.获取本月截止今天为止的所有的签到记录，返回的是一个十进制的数字 BITFIELD sign:5:202203 GET u14 0    List&lt;Long&gt; result = stringRedisTemplate.opsForValue().bitField(            key,            BitFieldSubCommands.create()//创建一个 BitField 命令的构建器，用于定义对位图的操作,用于读取连续的位数据并转换为整数。                    .get(//表示读取一个 无符号整数（unsigned），长度为 dayOfMonth 位（即当月已过的天数）                        BitFieldSubCommands                         .BitFieldType                         .unsigned(dayOfMonth))//指定要执行的是 &quot;读取位&quot; 操作                     .valueAt(0)//指定从位图的 偏移量 0 开始读取（即从当月第 1 天对应的位开始）    );    if (result == null || result.isEmpty()) &#123;        // 没有任何签到结果        return Result.ok(0);    &#125;    Long num = result.get(0);    if (num == null || num == 0) &#123;        return Result.ok(0);    &#125;    // 6.循环遍历    int count = 0;    while (true) &#123;        // 6.1.让这个数字与1做与运算，得到数字的最后一个bit位  // 判断这个bit位是否为0        if ((num &amp; 1) == 0) &#123;            // 如果为0，说明未签到，结束            break;        &#125;else &#123;            // 如果不为0，说明已签到，计数器+1            count++;        &#125;        // 把数字右移一位，抛弃最后一个bit位，继续下一个bit位        num &gt;&gt;&gt;= 1;    &#125;    return Result.ok(count);&#125;

三、BitMap 的拓展：缓存穿透优化缓存穿透：请求 “数据库和缓存都不存在的数据”，导致每次请求直击数据库，压力剧增。
BitMap 优化思路：

用 BitMap 维护 “数据库存在的 ID 集合”（将 ID 通过哈希映射到 BitMap 的位上，存在则置1）；
请求到达时，先通过 BitMap 判断 “ID 是否可能存在”：
若 BitMap 对应位为0，直接拦截（确定不存在）；
若为1，再查询缓存 &#x2F; 数据库（存在概率高，减少无效查询）。



优势：相比 “维护 ID 列表”，BitMap 存储更紧凑（1 亿 ID 仅需约 12MB），且哈希映射的时间复杂度为O(1)。
四、关键技术点
BitMap 的存储效率：
1 亿条签到记录，若用数据库表需约 2GB 存储，而 BitMap 仅需约 12MB（1亿 / 8 / 1024 / 1024 ≈ 12MB），存储成本大幅降低。

BitMap 命令特性：

SETBIT&#x2F;GETBIT：高效操作单个位；
BITFIELD：批量操作连续位（如一次性获取 “当月前 n 天” 的签到数据）；
BITCOUNT：统计所有为1的位（可直接用于 “当月总签到次数” 统计）。


连续签到算法：
利用 “位与（&amp;）” 判断最后一位是否为1，再通过 “右移（&gt;&gt;&gt;）” 遍历前一位，直到遇到0，统计连续1的次数。


总结用户签到模块通过Redis BitMap实现了 “低存储成本 + 高效位运算” 的签到与统计，同时 BitMap 可拓展用于缓存穿透等场景，是 Redis “巧用位操作压缩成本” 的典型实践。核心是理解 “用 bit 表示状态，通过位运算高效处理批量状态” 的设计思想。
]]></content>
      <categories>
        <category>黑马点评</category>
      </categories>
  </entry>
  <entry>
    <title>12-附近商铺</title>
    <url>/2025/10/12/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/12-%E9%99%84%E8%BF%91%E5%95%86%E9%93%BA/</url>
    <content><![CDATA[
stream流的使用
dependency Analyzer插件

附近商户一、GEO 数据结构：地理坐标存储与查询GEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据。常见的命令有：

GEOADD：添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member）
GEODIST：计算指定的两个点之间的距离并返回
GEOHASH：将指定member的坐标转为hash字符串形式并返回
GEOPOS：返回指定member的坐标
GEORADIUS：指定圆心、半径，找到该圆内包含的所有member，并按照与圆心之间的距离排序后返回。6.以后已废弃
GEOSEARCH：在指定范围内搜索member，并按照与指定点之间的距离排序后返回。范围可以是圆形或矩形。6.2.新功能
GEOSEARCHSTORE：与GEOSEARCH功能一致，不过可以把结果存储到一个指定的key。 6.2.新功能

二、数据导入：按商户类型分组存储业务需求：查询 “附近的商户” 时，需按 “商户类型” 筛选（如美食、酒店），因此需按类型分组存储地理坐标。
实现逻辑：

从数据库查询所有商户信息；
按typeId（商户类型 ID）分组，同类型商户存入 Redis 同一 GEO 集合；
用GEOADD批量添加商户的经纬度（x为经度，y为纬度）和商户 ID（member）。

代码及详解：测试环境通过单元测试载入数据
HmDianPingApplicationTests：
@Testvoid loadShopData() &#123;    // 1.查询店铺信息    List&lt;Shop&gt; list = shopService.list();    // 2.把店铺分组，按照typeId分组，typeId一致的放到一个集合    Map&lt;Long, List&lt;Shop&gt;&gt; map = list.stream().collect(Collectors.groupingBy(Shop::getTypeId));    // 3.分批完成写入Redis    for (Map.Entry&lt;Long, List&lt;Shop&gt;&gt; entry : map.entrySet()) &#123;        // 3.1.获取类型id        Long typeId = entry.getKey();        String key = SHOP_GEO_KEY + typeId;        // 3.2.获取同类型的店铺的集合        List&lt;Shop&gt; value = entry.getValue();        List&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; locations = new ArrayList&lt;&gt;(value.size());        // 3.3.写入redis GEOADD key 经度 纬度 member        for (Shop shop : value) &#123;            // stringRedisTemplate.opsForGeo().add(key, new Point(shop.getX(), shop.getY()), shop.getId().toString());            locations.add(new RedisGeoCommands.GeoLocation&lt;&gt;(                    shop.getId().toString(),                    new Point(shop.getX(), shop.getY())            ));        &#125;        stringRedisTemplate.opsForGeo().add(key, locations);    &#125;&#125;

设计理由：
GEO 本身不支持按类型筛选，通过typeId作为键前缀分组，可直接定位 “某类型商户的 GEO 集合”，避免全量扫描。
1. Map 的创建：按条件分组代码通过Collectors.groupingBy()将店铺列表按typeId分组，生成了一个Map&lt;Long, List&lt;Shop&gt;&gt;：
Map&lt;Long, List&lt;Shop&gt;&gt; map = list.stream()    .collect(Collectors.groupingBy(Shop::getTypeId));


作用：将原本无序的List&lt;Shop&gt;转换为按店铺类型（typeId）归类的 Map。
Map 结构：
键（Key）：Long类型，对应店铺的typeId（店铺类型 ID）。
值（Value）：List&lt;Shop&gt;类型，存储所有typeId相同的店铺对象。


优势：通过一次流处理完成分组，替代了传统的 “循环 + 判断 + 手动添加” 方式，代码更简洁高效。

2. Map 的结构：键值对的业务意义这个 Map 的结构直接对应业务需求：同类型的店铺需要批量写入 Redis 的同一个 GEO 集合中（Redis 的 GEO 键格式为SHOP_GEO_KEY + typeId）。
例如：

若typeId=1的店铺有 3 家，则 Map 中会有一个键值对：key=1，value=[shop1, shop2, shop3]。
后续写入 Redis 时，就可以基于这个键值对，直接获取该类型对应的所有店铺，批量处理。

3. Map 的遍历：处理分组后的数据通过遍历 Map 的entrySet()，逐个处理每个分组的数据：
for (Map.Entry&lt;Long, List&lt;Shop&gt;&gt; entry : map.entrySet()) &#123;    Long typeId = entry.getKey(); // 获取分组的typeId    List&lt;Shop&gt; shops = entry.getValue(); // 获取该类型的所有店铺    // 基于typeId和shops批量写入Redis&#125;


Map.Entry的作用：entrySet()方法返回 Map 中所有键值对的集合（Set&lt;Entry&gt;），每个Entry对象封装了一个key和对应的value，方便同时获取键和值。
遍历优势：相比 “先获取所有 key 再逐个 get (value)” 的方式，直接遍历entrySet()减少了对 Map 的查询次数，性能更优。

三、附近商户查询：按距离排序与分页业务需求：根据用户当前坐标（x，y），查询指定类型、指定范围内的商户，按距离排序并支持分页。
实现步骤：

判断是否需要地理查询：若未提供坐标（x&#x2F;y为 null），直接按类型从数据库分页查询；
地理查询参数计算：分页参数（from&#x3D;（当前页 - 1）页大小，end&#x3D; 当前页页大小）、搜索范围（如 5000 米）；
GEO 搜索：用GEOSEARCH查询 “以用户坐标为中心、5000 米范围内” 的商户，返回商户 ID 及距离；
结果处理：
截取分页范围内的商户 ID（跳过from条，取到end条）；
根据 ID 从数据库查询商户详情，关联距离信息；
按 GEO 返回的顺序排序（保证按距离排序）。



ShopController
@GetMapping(&quot;/of/type&quot;)//参数required当设置为false时，前端可以不传递该参数，此时方法参数会被赋值为null;若未设置此属性或设为true，则缺少参数会抛出MissingServletRequestParameterException异常public Result queryShopByType(        @RequestParam(&quot;typeId&quot;) Integer typeId,        @RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;) Integer current,        @RequestParam(value = &quot;x&quot;, required = false) Double x,        @RequestParam(value = &quot;y&quot;, required = false) Double y) &#123;   return shopService.queryShopByType(typeId, current, x, y);&#125;

ShopServiceImpl
@Override    public Result queryShopByType(Integer typeId, Integer current, Double x, Double y) &#123;        // 1.判断是否需要根据坐标查询        if (x == null || y == null) &#123;            // 不需要坐标查询，按数据库查询            Page&lt;Shop&gt; page = query()                    .eq(&quot;type_id&quot;, typeId)                    .page(new Page&lt;&gt;(current, SystemConstants.DEFAULT_PAGE_SIZE));//使用 MyBatis-Plus 的分页查询（page()方法）            // 返回数据            return Result.ok(page.getRecords());        &#125;        // 2.计算分页参数        int from = (current - 1) * SystemConstants.DEFAULT_PAGE_SIZE;        int end = current * SystemConstants.DEFAULT_PAGE_SIZE;        // 3.GEO查询,查询redis、按照距离排序、分页。结果：shopId、distance        String key = SHOP_GEO_KEY + typeId;        GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = stringRedisTemplate.opsForGeo() // GEOSEARCH key BYLONLAT x y BYRADIUS 10 WITHDISTANCE                .search(                        key,// Redis中存储该类型店铺地理信息的键                        GeoReference.fromCoordinate(x, y),GeoReference.fromCoordinate(x, y), // 参考坐标（用户的经纬度）                        new Distance(5000),// 搜索范围：5000单位（默认米） 				 RedisGeoCommands.GeoSearchCommandArgs.newGeoSearchArgs()                    .includeDistance()// 包含距离信息                    .limit(end)// 最多返回end条结果（用于分页）                );        // 4.解析出id        if (results == null) &#123;            return Result.ok(Collections.emptyList());// 无结果，返回空列表        &#125;        List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt;&gt; list = results.getContent();        // 若结果总数 &lt;= from，说明当前页无数据（如第2页但只有10条数据，from=20则无结果）        if (list.size() &lt;= from) &#123;            // 没有下一页了，结束            return Result.ok(Collections.emptyList());        &#125;        // 4.1.截取 from ~ end的部分        List&lt;Long&gt; ids = new ArrayList&lt;&gt;(list.size());        Map&lt;String, Distance&gt; distanceMap = new HashMap&lt;&gt;(list.size());        list.stream().skip(from).forEach(result -&gt; &#123;            // 4.2.获取店铺id            String shopIdStr = result.getContent().getName();            ids.add(Long.valueOf(shopIdStr));            // 4.3.获取距离            Distance distance = result.getDistance();// 店铺到用户的距离            distanceMap.put(shopIdStr, distance);// 存储“店铺ID-距离”映射        &#125;);        // 5.根据id查询Shop        String idStr = StrUtil.join(&quot;,&quot;, ids);        List&lt;Shop&gt; shops = query()            .in(&quot;id&quot;, ids)            .last(&quot;ORDER BY FIELD(id,&quot; + idStr + &quot;)&quot;)//按GEO返回顺序排序            .list();        // 给每个店铺设置距离（单位由Redis的Distance决定，默认米）        for (Shop shop : shops) &#123;     		 shop.setDistance(distanceMap.get(shop.getId().toString()).getValue());        &#125;        // 6.返回        return Result.ok(shops);    &#125;

四、关键技术点与注意事项
Spring Data Redis 版本兼容：
GEOSEARCH是 Redis 6.2 + 新增命令，需确保 Spring Data Redis 版本≥2.6.2、Lettuce（Redis 客户端）≥6.1.6，否则会报错。

分页逻辑：
传统分页（page+size）不适用地理查询，改用 “from（跳过条数）+end（最大返回条数）” 实现，避免因数据动态变化导致重复 &#x2F; 缺失。

性能优化：

GEO 仅存储商户 ID，详细信息从数据库查询（减少 Redis 内存占用）；
按类型分组存储，缩小查询范围，提升GEOSEARCH效率。


距离单位：
Distance默认单位为米，可通过构造函数指定（如new Distance(5, Metrics.KILOMETERS)表示 5 公里）。


总结附近商户功能通过Redis GEO实现地理坐标的高效存储与范围查询，结合 “按类型分组” 和 “滚动分页”，既满足了 “按距离排序” 的业务需求，又保证了查询性能。核心是利用 GEO 的GEOADD和GEOSEARCH命令，实现 “添加坐标 - 范围搜索 - 距离计算” 的完整流程，是地理位置服务的典型实践。
]]></content>
      <categories>
        <category>黑马点评</category>
      </categories>
  </entry>
  <entry>
    <title>14-UV统计</title>
    <url>/2025/10/12/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/14-UV%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[UV统计一、UV 与 PV 的概念区分
UV（Unique Visitor，独立访客）：1 天内同一用户多次访问网站，仅记录 1 次，用于衡量 “真实访问的用户数量”。
PV（Page View，页面浏览量）：用户每访问一个页面，就记录 1 次，用于衡量 “网站的总流量规模”。

二、HyperLogLog（HLL）：轻量级 UV 统计方案传统 UV 统计需存储 “所有访问用户的 ID”，若 UV 达百万级，存储成本极高。HyperLogLog 是一种概率型数据结构，解决了 “海量去重统计” 的存储痛点：

核心优势：
超小内存占用：单个 HLL 在 Redis 中永远小于 16KB，即使统计千万级 UV，内存也不会爆炸；
近似去重统计：以约 0.81% 的误差，实现 “海量数据的去重计数”；
支持合并操作：可将多个 HLL 的统计结果合并（如 “日 UV” 合并为 “周 UV”）。



三、Redis 中 HLL 的核心命令
PFADD key element [element ...]：向 HLL 中添加元素（支持批量添加多个元素）；
PFCOUNT key [key ...]：统计 HLL 的近似基数（即去重后的元素总数量）；
PFMERGE destkey sourcekey [sourcekey ...]：将多个 HLL 合并为一个（用于多维度 UV 的合并统计，如 “日 UV” 合并为 “月 UV”）。

四、百万级 UV 统计的测试验证通过单元测试模拟 “100 万用户访问”，验证 HLL 的存储与统计效果：
@Testvoid testHyperLogLog() &#123;    String[] users = new String[1000]; // 临时数组，用于批量添加    int index = 0;    for (int i = 1; i &lt;= 1000000; i++) &#123;        users[index++] = &quot;user_&quot; + i; // 构造100万个不同的用户ID        if (i % 1000 == 0) &#123; // 每1000个用户，批量添加到HLL            index = 0;            stringRedisTemplate.opsForHyperLogLog().add(&quot;hll:uv&quot;, users);        &#125;    &#125;    // 统计UV数量（近似值）    Long size = stringRedisTemplate.opsForHyperLogLog().size(&quot;hll:uv&quot;);    System.out.println(&quot;UV统计结果（近似）：&quot; + size);&#125;

测试结论：

内存占用：单个 HLL 键仅占用约 16KB，远低于 “存储 100 万用户 ID” 的传统方案（若用 Set 存储，需约数十 MB）；
统计误差：实际统计结果与真实值（100 万）的误差在 0.81% 以内，完全满足 UV 统计的 “近似精度” 需求。

五、适用场景与局限性适用场景：

海量数据的去重统计（如 UV、独立 IP 统计、网站访客数统计）；
对 “统计精度” 要求不绝对严格（误差可接受），但对 “内存占用” 敏感的场景。

局限性：

不支持 “查询具体元素”，仅能统计 “去重后的总数”；
存在约 0.81% 的统计误差，不适合 “精准计数” 场景（如订单数、库存数）。

总结HyperLogLog 是 Redis 为 “海量去重统计” 量身打造的轻量级方案，通过概率算法在 “极小内存占用” 与 “可接受的统计误差” 之间取得平衡，是 UV 统计、独立访客分析等场景的最优技术选择。核心要理解其 “用‘概率换空间’实现高效去重统计” 的设计思想。
]]></content>
      <categories>
        <category>黑马点评</category>
      </categories>
  </entry>
  <entry>
    <title>Lombok快速上手</title>
    <url>/2025/10/15/java/Lombok%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</url>
    <content><![CDATA[@Data在实体类上加 @Data 注解，自动为该类生成 *getter 和 setter 方法，以及 equals、*hashCode 和 toString 方法。
Lombok 实现代码生成的原理，其利用注解处理器机制，在编译过程中动态添加方法。干涉编译过程，实现代码生成。

**@Data**：一站式注解，等价于 @Getter @Setter @RequiredArgsConstructor @ToString @EqualsAndHashCode，适合普通数据类（允许修改字段）。
@Value：只读版本，等价于@Getter @FieldDefaults(makeFinal=true, level=PRIVATE) @AllArgsConstructor @ToString @EqualsAndHashCode，类和字段自动为 final（不可修改）。
**注意：Java 17+ 的 **Record 类型可替代 @Value（Record 天生不可变，自动生成 equals&#x2F;hashCode 等），更推荐使用。



@Getter@Getter 直接添加到类上或是字段上。命名规则：get+ 字段名首字母大写；

添加到类上时，将为类中所有字段添加 Getter 方法
添加到字段上时，仅对此字段生效

访问权限：@Getter(AccessLevel.xxx)  有 PUBLIC、PACKAGE、PRIVATE、PROTECTED、MODULE（仅限模块内使用，与 PACKAGE 类似，相当于不添加任何访问权限关键字。）、NONE
**添加额外注解： **@Getter(onMethod_ = &#123; xxx... &#125;)，花括号里面为注解。 如：@Getter(onMethod_ = &#123; @Deprecated &#125;)
懒加载（一开始的时候此字段没有值，当我们需要的时候再将值添加到此处；字段必须是 private 且 final 的），lazy=true：单例模式
@Setter参数与@Getter 用法一致，命名规则：set+ 字段名首字母大写；唯一一个不一样的参数为 onParam，它可以在形参上的额外添加的自定义注解。

如果我们手动编写了对应字段的 Getter 或 Setter 方法（按照上述命名规则进行判断）那么 Lombok 提供的注解将不会生效，也不会覆盖我们自己编写的方法，但是仅限于同名不同参的情况;
如果出现同名不同参数的情况导致误判，我们也可以使用@Tolerate 注解使 Lombok 忽略它的存在，继续生成。

构造方法Lombok 提供了三个用于处理构造方法的注解：

@NoArgsConstructor：为类生成无参构造方法（不包含任何参数）。
access：指定构造方法的访问修饰符（默认 public），其可选值为 AccessLevel 枚举。
force：当类中包含 final 字段时，默认情况下使用 @NoArgsConstructor 会报错（因为 final 字段必须初始化）。** **若设置 force = true，Lombok 会强制生成无参构造，并将 final 字段初始化为默认值（如 0、false、null 等）。


@AllArgsConstructor：为类生成包含所有字段的构造方法（无论字段是否为 final、是否有初始值）。
access：同 @NoArgsConstructor，指定构造方法的访问修饰符（默认 public）。
构造参数的顺序与类中字段****声明的顺序一致。




@RequiredArgsConstructor：为类生成包含必要字段的构造方法。
access：同前两个注解，指定访问修饰符（默认 public）。
staticName：若指定该参数（如 staticName = &quot;of&quot;），则不生成构造方法，而是生成一个静态工厂方法，通过该方法创建实例。
「必要字段」定义：
被 final 修饰且未初始化的字段（必须在构造时赋值）。
**被 **@NonNull 注解标记的字段（无论是否为 final，需保证非空）。






@ToString最简单的 toString 方法生成，只需要在类上添加一个@ToString 注解即可。
@ToString 常用参数：

exclude：
指定需要****排除的字段，这些字段不会出现在 toString() 的结果中。默认值：空数组
默认值：空数组@ToString(exclude = &#123;&quot;password&quot;, &quot;age&quot;&#125;) // 排除password和age字段
* `of`：  * **指定需要****包含**的字段（白名单），仅这些字段会出现在 `toString()` 结果中（与 `exclude` 互斥，不能同时使用）。**默认值**：空数组（若未指定，默认包含所有字段）  * ```    @ToString(of = &#123;&quot;username&quot;, &quot;email&quot;&#125;) // 只包含这两个字段




includeFieldNames：
控制是否在 toString() 中显示字段名（如 name=张三 中的 name=）。默认值：true（显示字段名）
@ToString(includeFieldNames = false) // 打印结果不显示字段名
* `callSuper`：  * **控制是否在 **`toString()` 中**包含父类的 `toString()` 结果**。**默认值**：`false`（不包含父类信息）  * ```    @ToString(callSuper = true) // 包含父类的toString结果




doNotUseGetters：
控制是否****直接访问字段（而非通过 getter 方法）获取值。默认值：false
@ToString(doNotUseGetters = true) // 直接访问字段，不调用getter
* `onlyExplicitlyIncluded`：  * **仅包含被 **`@ToString.Include` 注解标记的字段或方法（精确控制包含内容）。**默认值**：`false`（默认包含所有字段，除非被 `exclude` 排除）  * `@ToString.Include` 用于标记需要包含的字段或方法，可单独修饰字段或方法（方法会被执行并将返回值加入 `toString`）。## @EqualsAndHashCode**自动生成 **`equals()` 和 `hashCode()` 方法，默认基于类中**所有非静态、非 transient 字段**进行判断和计算，避免手动编写时的冗余和错误。| **参数 / 注解**          | **作用**                                                      | **注意事项**                                                                  || ------------------------ | ------------------------------------------------------------- | ----------------------------------------------------------------------------- || `exclude`                | **排除指定字段（不参与 equals/hashCode）**                    | **与**`of` 互斥，不可同时使用                                                 || `of`                     | **仅包含指定字段（白名单，仅这些字段参与）**                  | **与**`exclude` 互斥                                                          || `callSuper`              | **是否包含父类的 equals/hashCode 结果（即父类字段是否参与）** | **默认**`false`；父类未重写 equals 时（用 Object 实现），开启可能导致逻辑错误 || `onlyExplicitlyIncluded` | **仅包含被**`@Include` 标记的字段 / 方法                      | **需配合**`@EqualsAndHashCode.Include` 使用                                   || `@Include`               | **标记参与计算的字段 / 方法（支持方法返回值）**               | **可通过**`replaces = &quot;字段名&quot;` 替代指定字段的比较                            || `@Exclude`               | **标记不参与计算的字段**                                      | **无需开启**`onlyExplicitlyIncluded`，直接生效                                || `cacheStrategy`          | **控制 hashCode 缓存策略（**`NEVER`/`LAZY`）                  | `LAZY` 适合不可变类（字段值不变），可变类使用可能导致哈希值与实际状态不一致   |1. **方法参与计算**：   `@EqualsAndHashCode.Include` 可标记无参方法，其返回值会纳入 equals 和 hashCode 计算。例如：
 @EqualsAndHashCode(onlyExplicitlyIncluded = true)
 public class User &#123;
   private String name;
   private int age;
   
   @EqualsAndHashCode.Include(name = &quot;adult&quot;)
   public boolean isAdult() &#123; // 用方法结果参与比较
       return age &gt;= 18;
   &#125;



 } 2. **`replaces` 属性**：   **用方法结果替代指定字段的比较，例如：** @EqualsAndHashCode(onlyExplicitlyIncluded &#x3D; true) public class User {     private int id;          @EqualsAndHashCode.Include(replaces &#x3D; “id”) &#x2F;&#x2F; 替代 id 字段的比较     public int normalizedId() {         return Math.abs(id); &#x2F;&#x2F; 用绝对值参与比较     } } &#96;&#96;&#96;



缓存策略（LAZY）：第一次计算 hashCode 后缓存结果，后续直接返回，适合****不可变类（字段值不会修改）。若字段可变，缓存的哈希值会与实际状态脱节，导致集合（如 HashMap）操作异常。
**可变类慎用 **cacheStrategy = LAZY，避免哈希值与对象实际状态不一致。



Accessors 强化注解Lombok 为我们提供了一个@Accessors 注解，用于配置 lombok 如何生成和查找 getters 和 setters 即 用于强化 getter 和 setter 方法的生成规则，提供更灵活的访问器风格（如链式调用、fluent 风格等）
常用参数：

fluent（流畅风格、简化前缀）
生成的 getter&#x2F;setter 方法名直接使用****字段名，而非默认的 getXxx()&#x2F;setXxx(...)。默认值：false


chain（链式调用）
让 setter 方法返回当前对象（this），而非默认的 void，支持连续调用多个 setter。


prefix（字段前缀）
指定字段的前缀，生成 getter&#x2F;setter 时会自动忽略前缀，仅保留后续部分作为方法名。



]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Lombok</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis快速上手</title>
    <url>/2025/10/15/java/Mybatis%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</url>
    <content><![CDATA[一、Mybatis 简介与快速上手1.1 什么是 Mybatis
核心定位：Mybatis 是一款持久层框架，专注于解决 Java 应用与数据库交互的问题，属于 ORM（对象关系映射）技术的一种实现。
历史背景：前身是 Apache 的 iBatis 框架，2010 年迁移到 Google Code 并更名为 Mybatis，后托管于 GitHub，目前最新稳定版为 3.5.x（2025.10）。
解决的问题：
消除 JDBC 冗余代码（手动加载驱动、创建连接、处理结果集等）
实现 SQL 与 Java 代码分离，便于维护
提供灵活的 SQL 定制能力（无需像 Hibernate 那样受限于 ORM 自动生成的 SQL）


核心思想：通过配置文件或注解定义 SQL 语句与 Java 对象的映射关系，框架自动完成数据的查询、封装与持久化操作。

1.2 环境搭建基础依赖配置
Maven 依赖（核心 + 数据库驱动）：

&lt;!-- Mybatis核心依赖 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;    &lt;version&gt;3.5.16&lt;/version&gt;&lt;/dependency&gt;&lt;!-- MySQL驱动（根据数据库类型选择） --&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;8.0.33&lt;/version&gt; &lt;!-- 适配MySQL 8.x --&gt;&lt;/dependency&gt;


Gradle 依赖：

implementation &#x27;org.mybatis:mybatis:3.5.16&#x27;implementation &#x27;mysql:mysql-connector-java:8.0.33&#x27;

1.3 配置文件结构（mybatis-config.xml）Mybatis 核心配置文件包含框架全局设置，标签顺序有严格要求（properties → settings → typeAliases → … → environments → mappers）
&lt;configuration&gt;    &lt;!-- 1. 引入外部配置文件（如数据库连接信息） --&gt;    &lt;properties resource=&quot;db.properties&quot;/&gt;    &lt;!-- 2. 全局设置 --&gt;    &lt;settings&gt;        &lt;!-- 开启驼峰命名自动映射（数据库user_name → 实体userName） --&gt;        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;        &lt;!-- 开启日志（可选LOG4J、SLF4J等） --&gt;        &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;        &lt;!-- 二级缓存开关 --&gt;        &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;    &lt;/settings&gt;    &lt;!-- 3. 类型别名（简化类名书写） --&gt;    &lt;typeAliases&gt;        &lt;!-- 单个类别名 --&gt;        &lt;typeAlias type=&quot;com.example.pojo.User&quot; alias=&quot;User&quot;/&gt;        &lt;!-- 包扫描（默认别名为类名首字母小写，如User→user） --&gt;        &lt;package name=&quot;com.example.pojo&quot;/&gt;    &lt;/typeAliases&gt;    &lt;!-- 4. 环境配置（可配置多环境，default指定默认环境） --&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;!-- 事务管理器：JDBC（依赖数据库事务）/MANAGED（交给容器管理） --&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt;            &lt;!-- 数据源：POOLED（连接池）/UNPOOLED（无连接池）/JNDI（容器数据源） --&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;$&#123;db.driver&#125;&quot;/&gt; &lt;!-- 从properties文件获取 --&gt;                &lt;property name=&quot;url&quot; value=&quot;$&#123;db.url&#125;&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;$&#123;db.username&#125;&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;$&#123;db.password&#125;&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;!-- 5. 映射器（注册SQL映射文件或接口） --&gt;    &lt;mappers&gt;        &lt;!-- 方式1：资源路径（XML文件） --&gt;        &lt;mapper resource=&quot;mappers/UserMapper.xml&quot;/&gt;        &lt;!-- 方式2：接口全类名（需XML与接口同包同名） --&gt;        &lt;mapper class=&quot;com.example.mapper.UserMapper&quot;/&gt;        &lt;!-- 方式3：包扫描（批量注册接口） --&gt;        &lt;package name=&quot;com.example.mapper&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;

补充：db.properties 文件示例：
db.driver=com.mysql.cj.jdbc.Driverdb.url=jdbc:mysql://localhost:3306/test?useSSL=false&amp;serverTimezone=UTCdb.username=rootdb.password=123456

1.4 基础使用示例（工具类 + 核心 API）工具类封装（MybatisUtil）public class MybatisUtil &#123;    // SqlSessionFactory是线程安全的，全局只需要一个实例    private static SqlSessionFactory sqlSessionFactory;    static &#123;        try &#123;            // 1. 加载配置文件（InputStream/Reader均可）            InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);            // 2. 创建SqlSessionFactory（建造者模式）            sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);        &#125; catch (IOException e) &#123;            throw new RuntimeException(&quot;初始化SqlSessionFactory失败&quot;, e);        &#125;    &#125;    /**     * 获取SqlSession实例     * @param autoCommit 是否自动提交事务（DML操作建议关闭自动提交）     * @return SqlSession（线程不安全，需单独获取）     */    public static SqlSession openSession(boolean autoCommit) &#123;        return sqlSessionFactory.openSession(autoCommit);    &#125;    // 简化调用：默认不自动提交    public static SqlSession openSession() &#123;        return openSession(false);    &#125;&#125;

核心 API 说明
SqlSessionFactory：工厂类，负责创建 SqlSession，全局唯一，线程安全。
SqlSession：会话对象，封装了数据库连接，提供 CRUD 方法，线程不安全，需每次使用时创建，用完关闭。
使用流程：
通过工具类获取 SqlSession
执行 SQL 操作（直接调用 API 或通过 Mapper 接口）
提交 &#x2F; 回滚事务（DML 操作）
关闭 SqlSession（try-with-resources 自动关闭）




数据定义语言(DDL)、数据查询语言（DQL）、数据操纵语言（DML）、数据控制语言（DCL）

1.5 MyBatis 与 JDBC 的对比（解决 JDBC 的核心痛点）JDBC 操作数据库的典型流程：
// JDBC原生代码（冗余且繁琐）Connection conn = null;PreparedStatement ps = null;ResultSet rs = null;try &#123;    // 1. 加载驱动（硬编码）    Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);    // 2. 创建连接（URL/账号/密码硬编码）    conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/test&quot;, &quot;root&quot;, &quot;123456&quot;);    // 3. 编写SQL（字符串拼接易引发注入）    String sql = &quot;select * from user where id = &quot; + id; // 存在SQL注入风险    ps = conn.prepareStatement(sql);    // 4. 执行查询    rs = ps.executeQuery();    // 5. 手动封装结果集（重复劳动）    User user = new User();    while (rs.next()) &#123;        user.setId(rs.getInt(&quot;id&quot;));        user.setName(rs.getString(&quot;name&quot;));        // ... 更多字段映射    &#125;&#125; catch (Exception e) &#123;    e.printStackTrace();&#125; finally &#123;    // 6. 手动关闭资源（繁琐且易遗漏）    if (rs != null) try &#123; rs.close(); &#125; catch (SQLException e) &#123;&#125;    if (ps != null) try &#123; ps.close(); &#125; catch (SQLException e) &#123;&#125;    if (conn != null) try &#123; conn.close(); &#125; catch (SQLException e) &#123;&#125;&#125;

MyBatis 的优化点：

消除硬编码：通过配置文件管理数据库连接信息和 SQL
防注入：使用#&#123;&#125; 预编译参数（替代 JDBC 的字符串拼接）
自动映射：结果集自动封装为 Java 对象（无需手动rs.getXXX()）
资源管理：自动处理连接、Statement、ResultSet 的创建与关闭
事务简化：通过SqlSession 的 commit()&#x2F;rollback() 统一管理

1.6 初次使用的细节补充
Mapper 配置文件的 DTD 引入：在 XML 映射文件头部添加 DTD 约束，确保标签格式正确（IDE 会自动提示）：&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
环境配置细节：environments 标签的 default 属性需与某个 environment 的 id 一致；transactionManager 的 MANAGED 类型会将事务交给容器（如 Spring）管理，此时 MyBatis 不做任何事务处理。

1.7 XML 格式规范与特殊字符处理（1）基本格式规则
根节点唯一：核心配置文件根节点为&lt;configuration&gt;，映射文件为 &lt;mapper&gt;
标签嵌套严格：子标签必须符合 MyBatis 规定的顺序（如configuration 的子标签顺序不可乱）
属性值引号：单引号或双引号均可，建议统一使用双引号

（2）特殊字符处理（转义字符与 CDATA）当 SQL 中包含&lt;、&gt;、&amp; 等特殊字符时，有两种处理方式：

转义字符：
&lt;!-- 原SQL：select * from user where age &lt; 18 --&gt;&lt;select id=&quot;selectYoungUser&quot; resultType=&quot;User&quot;&gt;    select * from user where age &lt; 18 &lt;!-- &lt; 对应 &lt; --&gt;&lt;/select&gt;

XML 中常用的转义字符归纳如下：



转义序列
对应字符
说明



&amp;amp 或 &amp;
&amp;
和


&amp;lt 或 &lt;
&lt;
小于号


&amp;gt 或 &gt;
&gt;
大于号


&amp;quot
&quot;
双引号


&amp;nbsp
（空格）
空格


&amp;copy
©
版权符


&amp;reg
®
注册符



CDATA 区域（无需转义，适合复杂 SQL）：
&lt;select id=&quot;selectYoungUser&quot; resultType=&quot;User&quot;&gt;    &lt;![CDATA[        select * from user where age &lt; 18 and status &amp; 1 = 1    ]]&gt;&lt;/select&gt;

（3）Java 解析 XML 示例（了解 MyBatis 底层原理）MyBatis 通过 DOM 解析 XML 配置文件，简化示例：
// 解析MyBatis映射文件中的SQLpublic class XmlParser &#123;    public static void main(String[] args) throws Exception &#123;        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();        DocumentBuilder builder = factory.newDocumentBuilder();        Document doc = builder.parse(Resources.getResourceAsStream(&quot;mappers/UserMapper.xml&quot;));        // 获取select标签的SQL内容        Node node = doc.getElementsByTagName(&quot;select&quot;).item(0);        String sql = node.getTextContent().trim();        System.out.println(&quot;解析到的SQL：&quot; + sql);    &#125;&#125;

二、核心查询操作详解2.1 基础查询配置（XML 映射文件）UserMapper.xml 核心标签说明：
&lt;mapper namespace=&quot;userMapper&quot;&gt; &lt;!-- 命名空间：区分不同映射文件的SQL --&gt;    &lt;!-- 1. 简单查询 --&gt;    &lt;select         id=&quot;selectAllUser&quot;  &lt;!-- SQL唯一标识（与namespace组合为全限定名）--&gt;        resultType=&quot;User&quot;   &lt;!-- 结果类型（单个对象/集合元素类型） --&gt;        timeout=&quot;30&quot;&gt;       &lt;!-- 超时时间（秒） --&gt;        select * from user    &lt;/select&gt;    &lt;!-- 2. 条件查询（单个参数） --&gt;    &lt;select         id=&quot;selectUserById&quot;         parameterType=&quot;int&quot;  &lt;!-- 参数类型（可省略，Mybatis自动推断） --&gt;        resultType=&quot;User&quot;&gt;        select * from user where id = #&#123;id&#125;  &lt;!-- #&#123;id&#125;：参数占位符（预编译，防SQL注入） --&gt;    &lt;/select&gt;    &lt;!-- 3. 多条件查询（注意参数传递方式） --&gt;    &lt;select id=&quot;selectUserByIdAndAge&quot; resultType=&quot;User&quot;&gt;        select * from user where id = #&#123;id&#125; and age = #&#123;age&#125;    &lt;/select&gt;&lt;/mapper&gt;

2.2 Java 调用方式（3 种常用方式）方式 1：直接通过 SqlSession 调用（指定全限定名）try (SqlSession session = MybatisUtil.openSession()) &#123;    // 全限定名 = namespace + id    User user = session.selectOne(&quot;userMapper.selectUserById&quot;, 1);     List&lt;User&gt; users = session.selectList(&quot;userMapper.selectAllUser&quot;);&#125;

方式 2：多参数传递（@Param 注解 &#x2F; Map）
@Param 注解（推荐，清晰直观）：

// Mapper接口方法User selectUserByIdAndAge(@Param(&quot;id&quot;) int id, @Param(&quot;age&quot;) int age);// XML中直接使用#&#123;id&#125;和#&#123;age&#125;（无需额外配置）


Map 传递（适合参数较多的场景）：

Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();params.put(&quot;id&quot;, 1);params.put(&quot;age&quot;, 18);User user = session.selectOne(&quot;selectUserByIdAndAge&quot;, params);

方式 3：通过实体类传递参数// 实体类@Datapublic class UserQuery &#123;    private int id;    private int age;&#125;// XML中使用#&#123;属性名&#125;&lt;select id=&quot;selectByQuery&quot; resultType=&quot;User&quot;&gt;    select * from user where id = #&#123;id&#125; and age = #&#123;age&#125;&lt;/select&gt;// 调用UserQuery query = new UserQuery();query.setId(1);query.setAge(18);User user = session.selectOne(&quot;selectByQuery&quot;, query);

2.3 字段映射问题解决（3 种方案）当实体类字段与数据库列名不一致时（如实体uid vs 数据库 id），需手动映射：
方案 1：resultMap（最常用，XML 配置）&lt;!-- 定义映射规则 --&gt;&lt;resultMap id=&quot;userMap&quot; type=&quot;User&quot;&gt;    &lt;id property=&quot;uid&quot; column=&quot;id&quot;/&gt; &lt;!-- 主键映射 --&gt;    &lt;result property=&quot;username&quot; column=&quot;name&quot;/&gt; &lt;!-- 普通字段映射 --&gt;    &lt;result property=&quot;userAge&quot; column=&quot;age&quot;/&gt;&lt;/resultMap&gt;&lt;!-- 使用映射规则 --&gt;&lt;select id=&quot;selectUserById&quot; resultMap=&quot;userMap&quot;&gt;    select * from user where id = #&#123;id&#125;&lt;/select&gt;

方案 2：SQL 别名（简单场景）&lt;select id=&quot;selectUserById&quot; resultType=&quot;User&quot;&gt;    select id as uid, name as username, age as userAge from user where id = #&#123;id&#125;&lt;/select&gt;

方案 3：全局驼峰映射（针对下划线命名）在mybatis-config.xml 中开启：
&lt;settings&gt;    &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt;


效果：数据库user_name → 实体 userName，user_age → userAge

三、接口绑定与注解开发3.1 接口绑定（推荐方式）核心原理：通过动态代理，将 Mapper 接口与 XML 映射文件绑定，无需编写实现类。
步骤 1：定义 Mapper 接口public interface UserMapper &#123;    // 方法名 = XML中select的id    // 参数类型 = parameterType    // 返回值类型 = resultType/resultMap    User selectUserById(int id);    List&lt;User&gt; selectAllUser();    int insertUser(User user);    int updateUserAge(@Param(&quot;id&quot;) int id, @Param(&quot;age&quot;) int age);    int deleteUserById(int id);&#125;

步骤 2：配置 XML 映射文件（namespace 必须为接口全类名）&lt;mapper namespace=&quot;com.example.mapper.UserMapper&quot;&gt; &lt;!-- 接口全类名 --&gt;    &lt;select id=&quot;selectUserById&quot; resultType=&quot;User&quot;&gt; &lt;!-- id = 方法名 --&gt;        select * from user where id = #&#123;id&#125;    &lt;/select&gt;&lt;/mapper&gt;

步骤 3：通过接口调用try (SqlSession session = MybatisUtil.openSession()) &#123;    // 获取接口代理对象    UserMapper mapper = session.getMapper(UserMapper.class);    // 调用方法（自动执行对应SQL）    User user = mapper.selectUserById(1);&#125;

3.2 注解开发（简化配置）适合简单 SQL，复杂 SQL 建议用 XML。
常用注解说明


注解
作用
示例



@Select
查询操作
@Select(“SELECT * FROM user WHERE id &#x3D; #{id}”)


@Insert
插入操作
@Insert(“INSERT INTO user(name) VALUES(#{name})”)


@Update
更新操作
@Update(“UPDATE user SET name &#x3D; #{name} WHERE id &#x3D; #{id}”)


@Delete
删除操作
@Delete(“DELETE FROM user WHERE id &#x3D; #{id}”)


@Results
定义结果映射
@Results({@Result(property&#x3D;”uid”, column&#x3D;”id”)})


@Param
声明参数名
方法参数前加 @Param (“id”)


@Options
额外配置（如自增主键）
@Options(useGeneratedKeys &#x3D; true, keyProperty &#x3D; “id”)


示例代码public interface UserMapper &#123;    // 基础查询    @Select(&quot;SELECT * FROM user WHERE id = #&#123;id&#125;&quot;)    User selectUserById(int id);    // 插入并返回自增主键    @Options(useGeneratedKeys = true, keyProperty = &quot;id&quot;) // 主键回写至实体id属性    @Insert(&quot;INSERT INTO user(name, age) VALUES(#&#123;name&#125;, #&#123;age&#125;)&quot;)    int insertUser(User user);    // 结果映射（解决字段不一致）    @Results(&#123;        @Result(property = &quot;uid&quot;, column = &quot;id&quot;),       // 主键映射        @Result(property = &quot;username&quot;, column = &quot;name&quot;) // 普通字段映射    &#125;)    @Select(&quot;SELECT * FROM user&quot;)    List&lt;User&gt; selectAllUser();    // 动态SQL（注解中用&lt;script&gt;包裹）    @Select(&quot;&lt;script&gt;&quot; +            &quot;SELECT * FROM user WHERE 1=1&quot; +            &quot;&lt;if test=&#x27;name != null&#x27;&gt; AND name = #&#123;name&#125;&lt;/if&gt;&quot; +            &quot;&lt;if test=&#x27;age != null&#x27;&gt; AND age = #&#123;age&#125;&lt;/if&gt;&quot; +            &quot;&lt;/script&gt;&quot;)    List&lt;User&gt; selectByCondition(User user);&#125;

四、复杂关系查询（关联映射）4.1 一对一查询（如 User 与 UserDetail）实体类设计@Datapublic class User &#123;    private int id;    private String name;    private UserDetail detail; // 一对一关联（一个用户对应一个详情）&#125;@Datapublic class UserDetail &#123;    private int id;    private String address;    private Date registerTime;&#125;

关联查询实现（2 种方式）方式 1：关联查询（JOIN 语句，一次查询）&lt;resultMap id=&quot;userWithDetail&quot; type=&quot;User&quot;&gt;    &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;    &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt;    &lt;!-- association：一对一关联 --&gt;    &lt;association         property=&quot;detail&quot;      &lt;!-- 实体中关联属性名 --&gt;        javaType=&quot;UserDetail&quot;&gt; &lt;!-- 关联属性类型 --&gt;        &lt;id property=&quot;id&quot; column=&quot;detail_id&quot;/&gt; &lt;!-- 注意column与查询结果别名对应 --&gt;        &lt;result property=&quot;address&quot; column=&quot;address&quot;/&gt;        &lt;result property=&quot;registerTime&quot; column=&quot;register_time&quot;/&gt;    &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectUserWithDetail&quot; resultMap=&quot;userWithDetail&quot;&gt;    SELECT         u.id, u.name,         ud.id as detail_id, ud.address, ud.register_time     FROM user u     LEFT JOIN user_detail ud ON u.id = ud.user_id     WHERE u.id = #&#123;id&#125;&lt;/select&gt;

方式 2：嵌套查询（子查询，多次查询）&lt;resultMap id=&quot;userWithDetail&quot; type=&quot;User&quot;&gt;    &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;    &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt;    &lt;association         property=&quot;detail&quot;         javaType=&quot;UserDetail&quot;        column=&quot;id&quot;                   &lt;!-- 传递给子查询的参数（user的id） --&gt;        select=&quot;selectUserDetail&quot;/&gt;   &lt;!-- 子查询的id --&gt;&lt;/resultMap&gt;&lt;!-- 主查询 --&gt;&lt;select id=&quot;selectUserWithDetail&quot; resultMap=&quot;userWithDetail&quot;&gt;    select * from user where id = #&#123;id&#125;&lt;/select&gt;&lt;!-- 子查询（根据user_id查详情） --&gt;&lt;select id=&quot;selectUserDetail&quot; resultType=&quot;UserDetail&quot;&gt;    select * from user_detail where user_id = #&#123;id&#125;&lt;/select&gt;

注意：嵌套查询可能导致 N+1 问题（查询 1 个用户引发 1 次主查询 + N 次子查询），建议优先用关联查询。
多参数传递association 标签的 column 属性支持多列传递（用于子查询需要多个参数的场景）：
&lt;resultMap id=&quot;userWithDetail&quot; type=&quot;User&quot;&gt;    &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;    &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt;    &lt;association         property=&quot;detail&quot;         javaType=&quot;UserDetail&quot;        column=&quot;&#123;userId=id, status=status&#125;&quot; &lt;!-- 多列参数（key为子查询参数名，value为当前查询列名） --&gt;        select=&quot;selectUserDetailByMultiParams&quot;/&gt;&lt;/resultMap&gt;&lt;!-- 子查询接收多参数 --&gt;&lt;select id=&quot;selectUserDetailByMultiParams&quot; resultType=&quot;UserDetail&quot;&gt;    select * from user_detail where user_id = #&#123;userId&#125; and status = #&#123;status&#125;&lt;/select&gt;

4.2 一对多查询（如 User 与 Book）实体类设计@Datapublic class User &#123;    private int id;    private String name;    private List&lt;Book&gt; books; // 一对多关联（一个用户有多本书）&#125;@Datapublic class Book &#123;    private int id;    private String title;    private int userId; // 关联用户id&#125;

实现方式（关联查询）&lt;resultMap id=&quot;userWithBooks&quot; type=&quot;User&quot;&gt;    &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;    &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt;    &lt;!-- collection：一对多关联 --&gt;    &lt;collection         property=&quot;books&quot;    &lt;!-- 集合属性名 --&gt;        ofType=&quot;Book&quot;&gt;      &lt;!-- 集合元素类型（区别于javaType） --&gt;        &lt;id property=&quot;id&quot; column=&quot;book_id&quot;/&gt;        &lt;result property=&quot;title&quot; column=&quot;title&quot;/&gt;        &lt;result property=&quot;userId&quot; column=&quot;user_id&quot;/&gt;    &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectUserWithBooks&quot; resultMap=&quot;userWithBooks&quot;&gt;    SELECT         u.id, u.name,         b.id as book_id, b.title, b.user_id     FROM user u     LEFT JOIN book b ON u.id = b.user_id     WHERE u.id = #&#123;id&#125;&lt;/select&gt;

加载方式collection 标签的 fetchType 属性控制加载方式（eager 立即加载 &#x2F; lazy 延迟加载）：
&lt;resultMap id=&quot;userWithBooks&quot; type=&quot;User&quot;&gt;    &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;    &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt;    &lt;collection         property=&quot;books&quot;         ofType=&quot;Book&quot;        column=&quot;id&quot;        select=&quot;selectBooksByUserId&quot;        fetchType=&quot;lazy&quot;/&gt; &lt;!-- 延迟加载：只有调用user.getBooks()时才执行子查询 --&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectBooksByUserId&quot; resultType=&quot;Book&quot;&gt;    select * from book where user_id = #&#123;id&#125;&lt;/select&gt;

延迟加载配置（需在全局设置中开启）：
&lt;settings&gt;    &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;!-- 全局延迟加载开关 --&gt;    &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt; &lt;!-- 按需加载（不触发关联对象全加载） --&gt;&lt;/settings&gt;

五、DML 操作与事务5.1 增删改操作（XML 配置）插入操作（含自增主键）&lt;insert     id=&quot;insertUser&quot;     parameterType=&quot;User&quot;    useGeneratedKeys=&quot;true&quot;  &lt;!-- 开启自增主键获取 --&gt;    keyProperty=&quot;id&quot;&gt;        &lt;!-- 主键值回写至实体的id属性 --&gt;    INSERT INTO user(name, age) VALUES(#&#123;name&#125;, #&#123;age&#125;)&lt;/insert&gt;


调用后可通过user.getId() 获取自动生成的主键

非自增主键（如 UUID）的获取方式：
&lt;insert id=&quot;insertUserWithUUID&quot;&gt;    &lt;!-- 插入前生成UUID --&gt;    &lt;selectKey         keyProperty=&quot;id&quot;    &lt;!-- 主键回写至实体的id属性 --&gt;        resultType=&quot;String&quot; &lt;!-- 主键类型 --&gt;        order=&quot;BEFORE&quot;&gt;     &lt;!-- 执行时机：BEFORE（插入前）/AFTER（插入后） --&gt;        SELECT REPLACE(UUID(), &#x27;-&#x27;, &#x27;&#x27;) AS id    &lt;/selectKey&gt;    INSERT INTO user(id, name) VALUES(#&#123;id&#125;, #&#123;name&#125;)&lt;/insert&gt;

联合主键场景（keyColumn 指定数据库列名）：
&lt;insert id=&quot;insertOrderItem&quot; useGeneratedKeys=&quot;true&quot;         keyProperty=&quot;itemId&quot; keyColumn=&quot;item_id&quot;&gt; &lt;!-- 多主键用逗号分隔：keyColumn=&quot;col1,col2&quot; --&gt;    INSERT INTO order_item(order_id, product_id, quantity)     VALUES(#&#123;orderId&#125;, #&#123;productId&#125;, #&#123;quantity&#125;)&lt;/insert&gt;


此配置避免了插入后需手动查询主键的额外操作，简化了关联数据的插入逻辑。

更新操作&lt;update id=&quot;updateUser&quot; parameterType=&quot;User&quot;&gt;    UPDATE user     SET name = #&#123;name&#125;, age = #&#123;age&#125;     WHERE id = #&#123;id&#125;&lt;/update&gt;

删除操作&lt;delete id=&quot;deleteUserById&quot; parameterType=&quot;int&quot;&gt;    DELETE FROM user WHERE id = #&#123;id&#125;&lt;/delete&gt;

5.2 事务管理Mybatis 事务默认依赖 JDBC 事务管理器，需手动控制提交 &#x2F; 回滚。
事务操作流程try (SqlSession session = MybatisUtil.openSession()) &#123; // 关闭自动提交（默认）    UserMapper mapper = session.getMapper(UserMapper.class);    try &#123;        // 执行多个DML操作        mapper.insertUser(user1);        mapper.updateUser(user2);        session.commit(); // 全部成功则提交    &#125; catch (Exception e) &#123;        session.rollback(); // 失败则回滚        throw new RuntimeException(&quot;事务执行失败&quot;, e);    &#125;&#125;

事务特性
原子性：多个操作要么全成功，要么全失败
一致性：事务前后数据状态一致
隔离性：不同事务互不干扰（依赖数据库隔离级别）
持久性：提交后数据永久保存

六、动态 SQL 与缓存6.1 动态 SQL（XML 标签详解）动态 SQL 用于根据条件动态生成 SQL 语句，避免字符串拼接的繁琐与风险。
（1）if 标签（条件判断）&lt;select id=&quot;selectByCondition&quot; resultType=&quot;User&quot;&gt;    SELECT * FROM user WHERE 1=1    &lt;if test=&quot;name != null and name != &#x27;&#x27;&quot;&gt; &lt;!-- test中用OGNL表达式 --&gt;        AND name = #&#123;name&#125;    &lt;/if&gt;    &lt;if test=&quot;age != null&quot;&gt;        AND age = #&#123;age&#125;    &lt;/if&gt;&lt;/select&gt;

动态 SQL 中 if 标签的复杂场景
&lt;!-- 多条件模糊查询 + 范围查询 --&gt;&lt;select id=&quot;selectUserByAdvancedCondition&quot; resultType=&quot;User&quot;&gt;    SELECT * FROM user    &lt;where&gt;        &lt;if test=&quot;name != null and name != &#x27;&#x27;&quot;&gt;            AND name LIKE CONCAT(&#x27;%&#x27;, #&#123;name&#125;, &#x27;%&#x27;) &lt;!-- 模糊查询拼接 --&gt;        &lt;/if&gt;        &lt;if test=&quot;ageRange != null&quot;&gt; &lt;!-- 传入Map&lt;String, Integer&gt; ageRange，包含min和max --&gt;            AND age BETWEEN #&#123;ageRange.min&#125; AND #&#123;ageRange.max&#125;        &lt;/if&gt;        &lt;if test=&quot;statusList != null and statusList.size() &gt; 0&quot;&gt; &lt;!-- 传入List&lt;Integer&gt; --&gt;            AND status IN            &lt;foreach collection=&quot;statusList&quot; item=&quot;s&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;                #&#123;s&#125;            &lt;/foreach&gt;        &lt;/if&gt;    &lt;/where&gt;&lt;/select&gt;

（2）where 标签（自动处理 AND&#x2F;OR）&lt;select id=&quot;selectByCondition&quot; resultType=&quot;User&quot;&gt;    SELECT * FROM user    &lt;where&gt; &lt;!-- 自动移除首个AND/OR --&gt;        &lt;if test=&quot;name != null&quot;&gt;AND name = #&#123;name&#125;&lt;/if&gt;        &lt;if test=&quot;age != null&quot;&gt;AND age = #&#123;age&#125;&lt;/if&gt;    &lt;/where&gt;&lt;/select&gt;

（3）set 标签（更新时自动处理逗号）&lt;update id=&quot;updateUser&quot; parameterType=&quot;User&quot;&gt;    UPDATE user    &lt;set&gt; &lt;!-- 自动移除末尾逗号 --&gt;        &lt;if test=&quot;name != null&quot;&gt;name = #&#123;name&#125;,&lt;/if&gt;        &lt;if test=&quot;age != null&quot;&gt;age = #&#123;age&#125;&lt;/if&gt;    &lt;/set&gt;    WHERE id = #&#123;id&#125;&lt;/update&gt;

（4）foreach 标签（循环遍历，批量操作）
批量删除：

&lt;delete id=&quot;batchDelete&quot;&gt;    DELETE FROM user WHERE id IN    &lt;foreach         collection=&quot;list&quot;  &lt;!-- 集合参数名（list/map.key/数组） --&gt;        item=&quot;id&quot;          &lt;!-- 遍历元素别名 --&gt;        open=&quot;(&quot;           &lt;!-- 开始符号 --&gt;        separator=&quot;,&quot;      &lt;!-- 分隔符 --&gt;        close=&quot;)&quot;&gt;         &lt;!-- 结束符号 --&gt;        #&#123;id&#125;    &lt;/foreach&gt;&lt;/delete&gt;


批量插入：

&lt;insert id=&quot;batchInsert&quot;&gt;    INSERT INTO user(name, age) VALUES    &lt;foreach collection=&quot;list&quot; item=&quot;user&quot; separator=&quot;,&quot;&gt;        (#&#123;user.name&#125;, #&#123;user.age&#125;)    &lt;/foreach&gt;&lt;/insert&gt;

（5）choose 标签（分支选择，类似 switch）&lt;select id=&quot;selectByChoose&quot; resultType=&quot;User&quot;&gt;    SELECT * FROM user WHERE 1=1    &lt;choose&gt;        &lt;when test=&quot;id != null&quot;&gt;AND id = #&#123;id&#125;&lt;/when&gt; &lt;!-- 优先满足的条件 --&gt;        &lt;when test=&quot;name != null&quot;&gt;AND name = #&#123;name&#125;&lt;/when&gt;        &lt;otherwise&gt;AND age = 18&lt;/otherwise&gt; &lt;!-- 所有条件不满足时 --&gt;    &lt;/choose&gt;&lt;/select&gt;

6.2 缓存机制（一级缓存 + 二级缓存）缓存用于减少数据库访问，提高查询效率。
6.2.1 一级缓存（SqlSession 级别，默认开启）
作用范围：同一个 SqlSession 内，多次查询同一数据（相同 SQL + 参数），只执行一次 SQL，后续从缓存获取。
失效场景：
执行增删改操作（自动清空缓存）
手动调用session.clearCache()
关闭 SqlSession 后重新获取



一级缓存深度解析（1）核心代码逻辑（MyBatis 源码简化）
// SqlSession的查询方法（简化）public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) &#123;    BoundSql boundSql = ms.getBoundSql(parameter);    CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql); // 生成缓存键    return query(ms, parameter, rowBounds, resultHandler, key, boundSql);&#125;private &lt;E&gt; List&lt;E&gt; query(...) &#123;    List&lt;E&gt; list;    try &#123;        list = (List&lt;E&gt;) localCache.getObject(key); // 从一级缓存获取        if (list == null) &#123;            list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql); // 查数据库        &#125;    &#125; // ...    return list;&#125;

（2）localCacheScope 配置的影响
&lt;settings&gt;    &lt;!-- 默认为SESSION：一级缓存作用于整个SqlSession --&gt;    &lt;!-- 设置为STATEMENT：每次查询后清空缓存，即一级缓存失效 --&gt;    &lt;setting name=&quot;localCacheScope&quot; value=&quot;STATEMENT&quot;/&gt;&lt;/settings&gt;


SESSION（默认）：同一 SqlSession 内多次查询同一数据，仅执行一次 SQL
STATEMENT：每次查询都执行 SQL（适合需要实时数据的场景）

6.2.2 二级缓存（Mapper 级别，需手动开启）
作用范围：同一个 Mapper 接口的不同 SqlSession 共享缓存。
开启步骤：

**	**1、全局配置开启（默认已开启）：
&lt;settings&gt;    &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt;

**	**2、在 Mapper.xml 中声明缓存：
&lt;!-- 缓存配置 --&gt;&lt;cache     eviction=&quot;LRU&quot;        &lt;!-- 回收策略：LRU（最近最少使用）/FIFO（先进先出）等 --&gt;    flushInterval=&quot;60000&quot; &lt;!-- 刷新间隔（毫秒） --&gt;    size=&quot;512&quot;            &lt;!-- 最大缓存对象数 --&gt;    readOnly=&quot;true&quot;/&gt;     &lt;!-- 是否只读（true：返回缓存对象副本，性能好） --&gt;

**	**3、实体类需实现 Serializable 接口（二级缓存可能涉及序列化）

缓存控制：
useCache=&quot;false&quot;：当前查询不使用缓存（如实时性要求高的数据）
flushCache=&quot;true&quot;：执行后清空缓存（增删改默认 true，查询默认 false）



二级缓存深度解析（1）查询流程与多层装饰结构
查询顺序：二级缓存 → 一级缓存 → 数据库
二级缓存的装饰链（默认）：PerpetualCache（基础缓存）→ LruCache（淘汰策略）→ LoggingCache（日志）→ SynchronizedCache（线程安全）→ …
（2）缓存一致性问题及解决
问题示例：两个 SqlSession 操作同一数据，Session1 更新后未同步到二级缓存，导致 Session2 读取旧数据。
// Session1更新数据try (SqlSession session1 = MybatisUtil.openSession()) &#123;    session1.getMapper(UserMapper.class).updateUserAge(1, 20);    session1.commit(); // 提交后会清空UserMapper的二级缓存&#125;// Session2查询（此时二级缓存已清空，会查数据库）try (SqlSession session2 = MybatisUtil.openSession()) &#123;    User user = session2.getMapper(UserMapper.class).selectUserById(1); // 得到最新数据&#125;

解决：MyBatis 在 DML 操作后会自动清空当前 Mapper 的二级缓存（因 flushCache=&quot;true&quot; 默认开启），确保缓存一致性。
（3）eviction 属性的缓存淘汰算法
&lt;cache     eviction=&quot;FIFO&quot; &lt;!-- 可选值：                     LRU（最近最少使用，默认）                     FIFO（先进先出）                     SOFT（软引用，内存不足时淘汰）                     WEAK（弱引用，垃圾回收时淘汰）                    --&gt;    size=&quot;1000&quot;/&gt; &lt;!-- 最多缓存1000个对象 --&gt;

6.2.3 自定义缓存实现（1）自定义 Cache 类public class MyRedisCache implements Cache &#123;    private final String id; // 缓存唯一标识（Mapper接口全类名）    private RedisTemplate&lt;String, Object&gt; redisTemplate; // 假设已配置RedisTemplate    public MyRedisCache(String id) &#123;        this.id = id;    &#125;    @Override    public String getId() &#123; return id; &#125;    @Override    public void putObject(Object key, Object value) &#123;        // 存入Redis，设置过期时间        redisTemplate.opsForValue().set(key.toString(), value, 30, TimeUnit.MINUTES);    &#125;    @Override    public Object getObject(Object key) &#123;        // 从Redis获取        return redisTemplate.opsForValue().get(key.toString());    &#125;    @Override    public Object removeObject(Object key) &#123;        // 从Redis删除        redisTemplate.delete(key.toString());        return null;    &#125;    @Override    public void clear() &#123;        // 清空当前Mapper的缓存（通过key前缀匹配删除）        Set&lt;String&gt; keys = redisTemplate.keys(id + &quot;:*&quot;);        if (keys != null) redisTemplate.delete(keys);    &#125;    @Override    public int getSize() &#123;        // 获取缓存数量（简化实现）        return redisTemplate.keys(id + &quot;:*&quot;).size();    &#125;&#125;

（2）启用自定义缓存（XML 或注解）
XML 方式（在 Mapper.xml 中）：&lt;cache type=&quot;com.example.cache.MyRedisCache&quot;/&gt;
注解方式（在 Mapper 接口上）：@CacheNamespace(implementation = MyRedisCache.class)public interface UserMapper &#123; ... &#125;

6.2.4 缓存控制属性详解
useCache：控制查询是否使用二级缓存（默认 true）&lt;select id=&quot;selectUserById&quot; resultType=&quot;User&quot; useCache=&quot;false&quot;&gt; &lt;!-- 不使用二级缓存 --&gt;    select * from user where id = #&#123;id&#125;&lt;/select&gt;
flushCache：控制操作后是否清空二级缓存（DML 默认 true，查询默认 false）&lt;select id=&quot;selectUserById&quot; resultType=&quot;User&quot; flushCache=&quot;true&quot;&gt; &lt;!-- 查询后清空二级缓存 --&gt;    select * from user where id = #&#123;id&#125;&lt;/select&gt;

七、高级特性（选学）7.1 类型处理器（TypeHandler）用于 Java 类型与 JDBC 类型的自定义转换（如 String→ 自定义对象、Date→LocalDate）。
自定义类型处理器示例// 自定义String与MyString的转换@MappedJdbcTypes(JdbcType.VARCHAR) // 关联JDBC类型@MappedTypes(MyString.class)       // 关联Java类型public class MyStringHandler extends BaseTypeHandler&lt;MyString&gt; &#123;    // 设置参数（Java→JDBC）    @Override    public void setNonNullParameter(PreparedStatement ps, int i,                                   MyString parameter, JdbcType jdbcType) throws SQLException &#123;        ps.setString(i, parameter.getValue()); // 存储自定义对象的字符串值    &#125;    // 从结果集获取（JDBC→Java）    @Override    public MyString getNullableResult(ResultSet rs, String columnName) throws SQLException &#123;        return new MyString(rs.getString(columnName));    &#125;    // 其他重载方法（按列索引获取）    @Override    public MyString getNullableResult(ResultSet rs, int columnIndex) throws SQLException &#123;        return new MyString(rs.getString(columnIndex));    &#125;    @Override    public MyString getNullableResult(CallableStatement cs, int columnIndex) throws SQLException &#123;        return new MyString(cs.getString(columnIndex));    &#125;&#125;

注册类型处理器&lt;typeHandlers&gt;    &lt;typeHandler handler=&quot;com.example.handler.MyStringHandler&quot;/&gt;&lt;/typeHandlers&gt;

7.2 拦截器（插件）用于在 SQL 执行过程中插入自定义逻辑（如日志记录、性能监控、SQL 改写）。
自定义拦截器示例@Intercepts(&#123; // 声明拦截的目标方法    @Signature(        type = Executor.class,       // 拦截的接口        method = &quot;query&quot;,            // 拦截的方法名        args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125; // 方法参数    )&#125;)public class LogInterceptor implements Interceptor &#123;    // 拦截逻辑    @Override    public Object intercept(Invocation invocation) throws Throwable &#123;        // 1. 前置处理（如记录开始时间）        long start = System.currentTimeMillis();        // 2. 执行原方法        Object result = invocation.proceed();        // 3. 后置处理（如记录执行时间）        long end = System.currentTimeMillis();        System.out.println(&quot;SQL执行时间：&quot; + (end - start) + &quot;ms&quot;);        return result;    &#125;    // 生成代理对象    @Override    public Object plugin(Object target) &#123;        return Plugin.wrap(target, this);    &#125;    // 设置属性（从配置文件读取）    @Override    public void setProperties(Properties properties) &#123;        // 可通过properties获取配置参数    &#125;&#125;

注册拦截器&lt;plugins&gt;    &lt;plugin interceptor=&quot;com.example.interceptor.LogInterceptor&quot;&gt;        &lt;!-- 可选：设置拦截器属性 --&gt;        &lt;property name=&quot;logLevel&quot; value=&quot;INFO&quot;/&gt;    &lt;/plugin&gt;&lt;/plugins&gt;

八、最佳实践总结8.1 配置优化
连接池配置：使用 POOLED 数据源，并合理设置连接池参数（初始大小、最大活跃数等）
日志配置：开发环境开启 DEBUG 日志，生产环境关闭或设为 INFO，便于调试与性能优化
类型别名：使用包扫描方式配置，减少全类名书写
驼峰映射：开启 mapUnderscoreToCamelCase，减少 resultMap 配置

8.2 开发规范
SQL 与代码分离：复杂 SQL 写在 XML 中，简单 SQL 用注解，提高可维护性
参数传递：多参数优先用 @Param 注解，避免 Map 传递（可读性差）
结果映射：字段不一致时优先用 resultMap，而非 SQL 别名（映射规则集中管理）
命名规范：
Mapper 接口方法名与 XML 中 id 保持一致
表名、列名用小写 + 下划线，实体类用驼峰命名
映射文件与接口同包同名（便于包扫描）



8.3 性能优化批量操作：
批量插入 &#x2F; 更新使用ExecutorType.BATCH 模式
避免循环调用单条 SQL（N 次网络请求）

使用ExecutorType.BATCH 模式的完整示例及日志分析：
try (SqlSession session = sqlSessionFactory.openSession(ExecutorType.BATCH)) &#123; // 批处理执行器    UserMapper mapper = session.getMapper(UserMapper.class);    long start = System.currentTimeMillis();    for (int i = 0; i &lt; 1000; i++) &#123;        User user = new User();        user.setName(&quot;user&quot; + i);        mapper.insertUser(user);        // 每500条提交一次（避免内存溢出）        if (i % 500 == 0) &#123;            session.flushStatements(); // 刷入数据库（未提交事务）        &#125;    &#125;    session.commit(); // 最终提交    System.out.println(&quot;耗时：&quot; + (System.currentTimeMillis() - start) + &quot;ms&quot;);&#125;

日志分析：批处理模式下，MyBatis 会将 SQL 语句预编译一次，多次设置参数后批量执行，日志中只会出现一次 Preparing: INSERT INTO user(...)，避免了单条插入的多次预编译开销。
分页查询：分页查询实现（PageHelper 插件）
Mybatis 本身不直接支持分页，推荐使用第三方插件PageHelper 简化分页逻辑：
**	**添加依赖（Maven）：
&lt;dependency&gt;    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;    &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;    &lt;version&gt;5.3.3&lt;/version&gt;&lt;/dependency&gt;

**	**配置插件（在 mybatis-config.xml 的 &lt;plugins&gt; 标签中）：
&lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt;    &lt;!-- 数据库方言（可选，自动检测） --&gt;    &lt;property name=&quot;helperDialect&quot; value=&quot;mysql&quot;/&gt;    &lt;!-- 分页参数合理化（页码&lt;=0查第一页，页码&gt;总页数查最后一页） --&gt;    &lt;property name=&quot;reasonable&quot; value=&quot;true&quot;/&gt;&lt;/plugin&gt;

**	**使用方式：
try (SqlSession session = MybatisUtil.openSession()) &#123;    UserMapper mapper = session.getMapper(UserMapper.class);    // 1. 设置分页参数（页码从1开始，每页10条）    PageHelper.startPage(1, 10);    // 2. 执行查询（无需修改SQL，插件自动拼接LIMIT）    List&lt;User&gt; users = mapper.selectAllUser();    // 3. 封装分页结果    Page&lt;User&gt; page = (Page&lt;User&gt;) users;    System.out.println(&quot;总条数：&quot; + page.getTotal());    System.out.println(&quot;总页数：&quot; + page.getPages());    System.out.println(&quot;当前页数据：&quot; + page.getResult());&#125;

缓存策略：
高频查询、低频修改的数据开启二级缓存
实时性要求高的数据禁用缓存（useCache=false）

查询优化：
避免SELECT *，只查询需要的字段
关联查询优先用 JOIN，避免嵌套查询导致的 N+1 问题
分页查询使用 Mybatis 分页插件（如 PageHelper）

通过以上内容，可以系统掌握 Mybatis 的核心用法、高级特性及最佳实践，在实际开发中根据场景灵活选择配置与实现方式，提升开发效率与系统性能。
九、常见问题与解决方案9.1 映射文件相关错误
错误 1：org.apache.ibatis.binding.BindingException: Invalid bound statement (not found)原因：Mapper 接口与 XML 映射文件未正确绑定解决：

确保 XML 的namespace 与接口全类名一致
确保 XML 中id 与接口方法名一致
检查 XML 文件是否在mybatis-config.xml 的 &lt;mappers&gt; 中注册


错误 2：java.io.IOException: Could not find resource mappers/UserMapper.xml原因：XML 文件路径错误或未被 Maven 打包解决：

Maven 项目中，XML 文件若放在src/main/java 下，需在 pom.xml 中添加资源过滤：

&lt;build&gt;    &lt;resources&gt;        &lt;resource&gt;            &lt;directory&gt;src/main/java&lt;/directory&gt;            &lt;includes&gt;                &lt;include&gt;**/*.xml&lt;/include&gt;            &lt;/includes&gt;        &lt;/resource&gt;    &lt;/resources&gt;&lt;/build&gt;

9.2 字段映射错误
错误：查询结果字段为null（实体类属性与数据库列名不一致）解决：
开启驼峰映射（mapUnderscoreToCamelCase=true）
使用resultMap 手动定义映射关系
在 SQL 中给列名添加别名（如id as userId）



9.3 事务相关错误
错误：插入数据后数据库无记录（未提交事务）原因：Mybatis 默认关闭自动提交，DML 操作需手动commit() 解决：执行 session.commit() 或开启自动提交（openSession(true)）

十、Mybatis 与 Spring 整合10.1 核心依赖（Maven）&lt;!-- Spring核心 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;    &lt;version&gt;5.3.24&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Spring JDBC（事务管理） --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;    &lt;version&gt;5.3.24&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Mybatis-Spring整合包 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;    &lt;version&gt;2.0.7&lt;/version&gt;&lt;/dependency&gt;

10.2 Spring 配置文件（applicationContext.xml）&lt;!-- 1. 数据源（替换Mybatis原生数据源） --&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;    &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test?useSSL=false&quot;/&gt;    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;    &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;&lt;/bean&gt;&lt;!-- 2. SqlSessionFactory（由Spring管理） --&gt;&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;!-- 加载Mybatis核心配置 --&gt;    &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;    &lt;!-- 扫描映射文件 --&gt;    &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mappers/*.xml&quot;/&gt;&lt;/bean&gt;&lt;!-- 3. Mapper接口扫描（自动生成代理对象） --&gt;&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;    &lt;property name=&quot;basePackage&quot; value=&quot;com.example.mapper&quot;/&gt; &lt;!-- Mapper接口所在包 --&gt;&lt;/bean&gt;&lt;!-- 4. 事务管理器 --&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;&lt;!-- 开启事务注解 --&gt;&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;

10.3 整合后使用方式// 1. 注入Mapper接口（Spring自动管理）@Servicepublic class UserService &#123;    @Autowired    private UserMapper userMapper;    // 2. 事务控制（通过注解）    @Transactional    public void addUser(User user) &#123;        userMapper.insertUser(user);    &#125;&#125;
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis-plus快速上手</title>
    <url>/2025/10/15/java/Mybatis-plus%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</url>
    <content><![CDATA[一、环境说明
技术栈版本：SpringBoot3、JDK17、IntelliJ IDEA、MyBatisPlus 3.5.11
核心依赖（关键版本）：
mybatis-plus-spring-boot3-starter:3.5.11
mysql-connector-java:8.0.33
hutool-all:5.8.22
lombok（简化实体类）



二、核心章节内容（12 章）第 1 章：快速入门1.1 MyBatis-Plus 简介核心特性：

无侵入：不改变现有工程结构
损耗小：启动自动注入基础 CRUD，性能无感知损耗
强 CRUD：内置通用 Mapper、通用 Service
支持 Lambda 调用：避免字段硬编码
内置代码生成器、分页插件（支持多数据库）

1.2 环境准备
建库建表 SQL：CREATE DATABASE `mybatis_plus_demo` DEFAULT CHARACTER SET utf8mb4;CREATE TABLE `user` (  `id` int NOT NULL AUTO_INCREMENT,  `name` varchar(255) DEFAULT NULL,  `age` int DEFAULT NULL,  `email` varchar(255) DEFAULT NULL,  `status` varchar(255) DEFAULT NULL,  `create_time` datetime DEFAULT NULL,  `update_time` datetime DEFAULT NULL,  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=1571093847 DEFAULT CHARSET=utf8mb4;
配置文件（application.yml）：spring:  datasource:    url: jdbc:mysql://你的数据库地址?useSSL=false&amp;serverTimezone=UTC    username: root    password: root    driver-class-name: com.mysql.cj.jdbc.Drivermybatis-plus:  configuration:    log-impl:org.apache.ibatis.logging.stdout.StdOutImpl # 打印SQL
核心代码：
实体类： @Data@TableName(value = &quot;user&quot;, autoResultMap = true)public class User &#123;    @TableId(type = IdType.AUTO)     private Integer id;     private String name;     private Integer age;     private String email; &#125;
Mapper 接口：@Mapperpublic interface UserMapper extends BaseMapper&lt;User&gt; &#123; &#125;
启动类：添加 @MapperScan(&quot;com.lglbc.mybatisplusdemo.mapper&quot;)



1.3 基础 CRUD 操作（测试用例）
插入：userMapper.insert(user)
@Test
 public void testInsert() &#123;
 User user = new User();
        user.setAge(10);
        user.setName(&quot;ljh&quot;);
        user.setEmail(&quot;ljh@fjm&quot;);
        userMapper.insert(user);
 &#125;
* **查询：**`selectById(id)`、`selectList(null)`（查所有）  * ```    // 根据ID查询    @Test     public void testSelectById() &#123;     User user = userMapper.selectById(12);     System.out.println(user);     &#125;     // 查询所有    @Test     public void testSelect() &#123;     List&lt;User&gt; users = userMapper.selectList(null);            users.forEach(System.out::println);     &#125;




更新：updateById(user)
@Test
 public void testUpdate() &#123;
 User user = userMapper.selectById(12);
        user.setName(&quot;更新&quot;);
        userMapper.updateById(user);
 &#125;
* **删除：**`deleteById(id)`  * ```    @Test     public void testDelete() &#123;            userMapper.deleteById(1);     &#125;





第 2 章：IService 接口2.1 基础配置
Service 接口：
public interface UserService extends IService&lt;User&gt; &#123;
     // 可以在此添加⾃定义⽅法
    List&lt;User&gt; selectByAgeRange(Integer minAge, Integer maxAge);
&#125;
* **Service 实现类：**  * ```    @Service     public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService &#123;         @Override         public List&lt;User&gt; selectByAgeRange(Integer minAge, Integer maxAge) &#123;             LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();             wrapper.between(User::getAge, minAge, maxAge);             return this.list(wrapper);         &#125;     &#125;





2.2 IService 核心方法演示（含批量 &#x2F; 链式）


操作类型
关键方法



保存
save(user)（单条）、saveBatch(users, 1000)（批量，每 1000 条一批）


保存或更新
saveOrUpdate(user)（按 ID 判断）、saveOrUpdateBatch(users)


删除
removeById(id)、removeByMap(map)、remove(wrapper)、removeByIds(ids)


更新
updateById(user)、update(wrapper)（条件更新）、updateBatchById(users)


查询
getById(id)、getOne(wrapper)、list()、list(wrapper)、count(wrapper)


分页
配置PaginationInnerInterceptor 后，调用 page(new Page&lt;&gt;(1,2), wrapper)


IService 接口提供了比 BaseMapper 更丰富的 CRUD 操作，以下通过具体测试用例（基于 JUnit）演示各核心方法的使用，所有示例均来自课程文档中的实战代码。
一、保存操作包含单条数据保存与批量数据保存，批量保存可指定每批处理条数以优化性能。
// 1. 测试保存单个实体@Test void testSave() &#123;    User user = new User();     user.setName(&quot;张三&quot;);     user.setAge(25);     user.setEmail(&quot;zhangsan@example.com&quot;);     boolean result = userService.save(user); // 单条保存核心方法    System.out.println(&quot;保存结果: &quot; + result);&#125;// 2. 测试批量保存（每1000条为一批，避免内存溢出）@Test void testSaveBatch() &#123;    List&lt;User&gt; users = new ArrayList&lt;&gt;();     for (int i = 0; i &lt; 5; i++) &#123;        User user = new User();        user.setName(&quot;用户&quot; + i);         user.setAge(20 + i);         users.add(user);    &#125;    boolean result = userService.saveBatch(users, 1000); // 批量保存核心方法（指定批次大小）    System.out.println(&quot;批量保存结果:&quot; + result);&#125;

二、保存或更新操作根据实体是否包含 ID 自动判断：ID 存在则执行更新，ID 不存在则执行插入，支持单条与批量操作。
// 1. 单条保存或更新（按ID判断）@Testvoid testSaveOrUpdate() &#123;     User user = new User();     user.setId(1L); // ID存在，执行更新；ID不存在，执行插入    user.setName(&quot;更新后的名字&quot;);    boolean result = userService.saveOrUpdate(user); // 单条保存或更新核心方法    System.out.println(&quot;保存或更新结果:&quot; + result);&#125;// 2. 批量保存或更新@Testvoid testSaveOrUpdateBatch() &#123;     List&lt;User&gt; users = userService.list(); // 先查询已有数据    users.forEach(user -&gt; user.setName(user.getName() + &quot;_updated&quot;)); // 批量修改字段    boolean result = userService.saveOrUpdateBatch(users); // 批量保存或更新核心方法    System.out.println(&quot;批量保存或更新结果:&quot; + result);&#125;

三、删除操作支持按 ID、按条件（Map &#x2F; 条件构造器）、批量删除，覆盖多种删除场景。
// 1. 根据ID删除@Testvoid testRemoveById() &#123;     boolean result = userService.removeById(1L); // 按ID删除核心方法    System.out.println(&quot;删除结果:&quot; + result);&#125;// 2. 根据Map条件删除（Map的key为字段名，value为字段值）@Testvoid testRemoveByMap() &#123;     Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();    map.put(&quot;name&quot;, &quot;张三&quot;);     map.put(&quot;age&quot;, 25); // 条件：name=张三 且 age=25    boolean result = userService.removeByMap(map); // 按Map条件删除核心方法    System.out.println(&quot;根据Map条件删除结果:&quot; + result);&#125;// 3. 根据条件构造器删除（支持复杂条件）@Testvoid testRemove() &#123;     LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();     wrapper.eq(User::getName, &quot;张三&quot;).gt(User::getAge, 20); // 条件：name=张三 且 age&gt;20    boolean result = userService.remove(wrapper); // 按条件构造器删除核心方法    System.out.println(&quot;根据条件构造器删除结果:&quot; + result);&#125;// 4. 批量删除（按ID集合）@Testvoid testRemoveByIds() &#123;     List&lt;Long&gt; ids = Arrays.asList(1L, 2L, 3L); // 待删除的ID集合    boolean result = userService.removeByIds(ids); // 批量删除核心方法    System.out.println(&quot;批量删除结果:&quot; + result);&#125;

四、更新操作支持按 ID、按条件（条件构造器）、批量更新，满足不同更新需求。
// 1. 根据ID更新@Testvoid testUpdateById() &#123;     User user = userService.getById(1L); // 先查询待更新数据    user.setName(&quot;新名字&quot;); // 修改字段    boolean result = userService.updateById(user); // 按ID更新核心方法    System.out.println(&quot;更新结果:&quot; + result);&#125;// 2. 根据条件更新（统一修改符合条件的记录）@Testvoid testUpdate() &#123;     UpdateWrapper&lt;User&gt; wrapper = new UpdateWrapper&lt;&gt;();     wrapper.set(&quot;name&quot;, &quot;统一新名字&quot;).gt(&quot;age&quot;, 20); // 操作：name设为&quot;统一新名字&quot;；条件：age&gt;20    boolean result = userService.update(wrapper); // 按条件更新核心方法    System.out.println(&quot;条件更新结果:&quot; + result);&#125;// 3. 批量更新（按ID集合批量修改）@Testvoid testUpdateBatchById() &#123;     List&lt;User&gt; users = userService.list(); // 先查询已有数据    users.forEach(user -&gt; user.setAge(user.getAge() + 1)); // 批量修改age字段（+1）    boolean result = userService.updateBatchById(users); // 批量更新核心方法    System.out.println(&quot;批量更新结果:&quot; + result);&#125;

五、查询操作覆盖单条查询、列表查询、数量统计等场景，支持按 ID、按条件查询，且兼容 Lambda 条件构造器。
// 1. 根据ID查询单条数据@Testvoid testGetById() &#123;     User user = userService.getById(1L); // 按ID查询核心方法    System.out.println(user);&#125;// 2. 根据条件查询单条数据（若有多条，默认抛异常，可设置allowMultipleResults=true允许返回第一条）@Testvoid testGetOne() &#123;     LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();     wrapper.gt(User::getAge, 20); // 条件：age&gt;20    User user = userService.getOne(wrapper); // 按条件查询单条核心方法    System.out.println(user);&#125;// 3. 查询列表（查询所有/按条件查询）@Testvoid testList() &#123;     // 3.1 查询所有数据    List&lt;User&gt; users = userService.list(); // 查询所有核心方法    users.forEach(System.out::println);    // 3.2 按条件查询列表    LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();     wrapper.like(User::getName, &quot;张&quot;); // 条件：name包含&quot;张&quot;    List&lt;User&gt; filteredUsers = userService.list(wrapper); // 按条件查询列表核心方法    filteredUsers.forEach(System.out::println);&#125;// 4. 查询记录总数（统计所有/按条件统计）@Testvoid testCount() &#123;     // 4.1 统计所有记录数    long count = userService.count(); // 统计所有核心方法    System.out.println(&quot;总记录数: &quot; + count);    // 4.2 按条件统计记录数    LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();     wrapper.gt(User::getAge, 20); // 条件：age&gt;20    long filteredCount = userService.count(wrapper); // 按条件统计核心方法    System.out.println(&quot;年龄大于20的记录数:&quot; + filteredCount);&#125;

六、分页查询操作需先配置分页插件（PaginationInnerInterceptor），再通过 page() 方法实现分页，支持无条件 &#x2F; 有条件分页。
// 1. 配置分页插件（全局配置，需在配置类中声明）@Configuration public class MybatisPlusConfig &#123;    @Bean    public MybatisPlusInterceptor mybatisPlusInterceptor() &#123;         MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();        interceptor.addInnerInterceptor(new PaginationInnerInterceptor()); // 注册分页插件        return interceptor;    &#125;&#125;// 2. 分页查询测试@Testvoid testPage() &#123;     Page&lt;User&gt; page = new Page&lt;&gt;(1, 2); // 构建分页对象：当前页（1）、每页条数（2）    // 2.1 无条件分页    Page&lt;User&gt; result1 = userService.page(page); // 无条件分页核心方法    System.out.println(&quot;总记录数:&quot; + result1.getTotal());     result1.getRecords().forEach(System.out::println); // 打印当前页数据    // 2.2 有条件分页    LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();     wrapper.gt(User::getAge, 20); // 条件：age&gt;20    Page&lt;User&gt; result2 = userService.page(page, wrapper); // 有条件分页核心方法    System.out.println(&quot;年龄大于20的记录数:&quot; + result2.getTotal());    result2.getRecords().forEach(System.out::println);&#125;

七、链式调用操作通过 Lambda 链式语法简化查询、更新、删除逻辑，代码更简洁易读。
@Testvoid testChain() &#123;     // 1. 查询链式调用：age&gt;20 且 name包含&quot;张&quot;，直接返回列表    List&lt;User&gt; users = userService.lambdaQuery()                                  .gt(User::getAge, 20)                                  .like(User::getName, &quot;张&quot;)                                  .list();    users.forEach(System.out::println);    // 2. 更新链式调用：name=张三 的用户，将age设为30    boolean updateResult = userService.lambdaUpdate()                                      .eq(User::getName, &quot;张三&quot;)                                      .set(User::getAge, 30)                                      .update();    System.out.println(&quot;更新结果:&quot; + updateResult);    // 3. 删除链式调用：name=李四 的用户，直接执行删除    boolean removeResult = userService.lambdaUpdate()                                       .eq(User::getName, &quot;李四&quot;)                                      .remove();    System.out.println(&quot;删除结果:&quot; + removeResult);&#125;

2.3 链式调用示例// 查询：年龄&gt;20且名字含“张”userService    .lambdaQuery()    .gt(User::getAge, 20)    .like(User::getName, &quot;张&quot;)    .list();// 更新：名字=“张三”的用户年龄设为30userService    .lambdaUpdate()    .eq(User::getName, &quot;张三&quot;)    .set(User::getAge, 30)    .update();//删除：删除名字=“李四”的用户 userService     .lambdaUpdate()     .eq(User::getName, &quot;李四&quot;)     .remove();

2.4 自定义方法在 Service 接口定义List&lt;User&gt; selectByAgeRange(Integer minAge, Integer maxAge)，实现类用 LambdaQueryWrapper 实现条件查询。
一、Service 接口定义（自定义方法声明）**在 **UserService 接口中继承 IService&lt;User&gt;，并添加自定义方法 selectByAgeRange，用于根据传入的最小年龄和最大年龄查询用户列表。
import com.baomidou.mybatisplus.extension.service.IService;import java.util.List;// 继承IService&lt;User&gt;获得基础CRUD能力，同时声明自定义方法public interface UserService extends IService&lt;User&gt; &#123;    // 自定义方法：根据年龄范围（minAge~maxAge）查询用户列表    List&lt;User&gt; selectByAgeRange(Integer minAge, Integer maxAge);&#125;

二、Service 实现类（自定义方法逻辑实现）**创建 **UserServiceImpl 类，继承 ServiceImpl&lt;UserMapper, User&gt; 并实现 UserService 接口，在自定义方法中通过 LambdaQueryWrapper 构建 “年龄在 minAge 和 maxAge 之间” 的查询条件，最终调用 this.list(wrapper) 执行查询。
import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import org.springframework.stereotype.Service;import java.util.List;@Service // 交给Spring容器管理，确保能被注入使用public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService &#123;    // 实现自定义方法：按年龄范围查询    @Override    public List&lt;User&gt; selectByAgeRange(Integer minAge, Integer maxAge) &#123;        // 1. 创建LambdaQueryWrapper（类型安全，避免字段硬编码）        LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();        // 2. 构建条件：年龄 between minAge 和 maxAge（包含边界值）        wrapper.between(User::getAge, minAge, maxAge);        // 3. 调用list()方法执行查询，返回符合条件的用户列表        return this.list(wrapper);    &#125;&#125;

2.5 批量操作性能优化在处理大批量数据时，直接执行全量批量操作可能导致内存占用过高（甚至 OOM）、数据库连接压力过大等问题。IService 接口的批量操作性能优化核心方案为****分批处理，通过控制单次批量操作的数据量，平衡内存消耗与数据库交互效率。
针对大批量数据（如万级、十万级数据）的批量新增、更新等操作，不直接调用无批次限制的批量方法（如 saveBatch(users)），而是手动指定单次批次大小，将全量数据拆分为多批逐步执行，避免一次性加载大量数据到内存。
@Test void testBatchPerformance() &#123;    // 1. 模拟大批量数据（示例：10万条用户数据）    List&lt;User&gt; users = new ArrayList&lt;&gt;();     for (int i = 0; i &lt; 100000; i++) &#123;        User user = new User();        user.setName(&quot;用户_&quot; + i); // 构造用户姓名        user.setAge(i % 100); // 构造用户年龄（0-99随机分布）        users.add(user);    &#125;    // 2. 分批执行批量插入：每1000条数据为一批    boolean result = userService.saveBatch(users, 1000);     System.out.println(&quot;批量插入结果:&quot; + result);&#125;

上述代码中，saveBatch(users, 1000) 方法的第二个参数 1000 即为单次批次大小，表示每积累 1000 条数据执行一次批量插入操作，10 万条数据最终会拆分为 100 批逐步处理。
第 3 章：条件构造器（Wrapper）3.1 构造器类型
QueryWrapper：通用查询构造器（需硬编码字段名，易出错）
LambdaQueryWrapper：Lambda 语法查询（类型安全，推荐）
UpdateWrapper&#x2F;LambdaUpdateWrapper：更新操作构造器

3.2 核心查询条件（Lambda 方式示例）


条件类型
代码示例



等值 &#x2F; 不等值
eq(User::getName, &quot;张三&quot;).ne(User::getAge, 18)


范围
gt(User::getAge, 18).between(User::getAge, 20, 30)


模糊查询
like(User::getName, &quot;张&quot;).likeLeft(User::getName, &quot;张&quot;)（% 张）


AND&#x2F;OR 嵌套
and(w -&gt; w.eq(User::getName, &quot;张三&quot;).or().eq(User::getName, &quot;李四&quot;))


字段选择
select(User::getId, User::getName, User::getAge)（只查指定字段）


动态条件
eq(StringUtils.isNotBlank(name), User::getName, name)（非空才加条件）


子查询
inSql(User::getId, &quot;select id from user where age &gt; 20&quot;)


一、基础查询条件一、等值 &#x2F; 不等值查询**通过 **eq（等于）、ne（不等于）方法构建字段与值的匹配条件，Lambda 方式直接引用实体类字段（如 User::getName），避免硬编码字段名导致的错误。
// Lambda方式：查询姓名为“张三”且年龄不等于18的用户LambdaQueryWrapper&lt;User&gt; lambdaWrapper = new LambdaQueryWrapper&lt;&gt;();lambdaWrapper.eq(User::getName, &quot;张三&quot;) // 等值条件：name = &quot;张三&quot;             .ne(User::getAge, 18);    // 不等值条件：age != 18

二、范围查询**通过 **gt（大于）、ge（大于等于）、lt（小于）、le（小于等于）、between（区间包含）方法构建数值型字段的范围条件，适用于年龄、时间等字段的范围筛选。
// Lambda方式：查询年龄大于18、大于等于20、小于30、小于等于25，且在20-30区间内的用户LambdaQueryWrapper&lt;User&gt; lambdaWrapper = new LambdaQueryWrapper&lt;&gt;();lambdaWrapper.gt(User::getAge, 18)     // 范围条件：age &gt; 18             .ge(User::getAge, 20)     // 范围条件：age &gt;= 20             .lt(User::getAge, 30)     // 范围条件：age &lt; 30             .le(User::getAge, 25)     // 范围条件：age &lt;= 25             .between(User::getAge, 20, 30); // 区间条件：age BETWEEN 20 AND 30

三、模糊查询**通过 **like（全模糊，% 值 %）、likeLeft（左模糊，% 值）、likeRight（右模糊，值 %）、notLike（不包含，NOT LIKE % 值 %）方法构建字符串字段的模糊匹配条件，适用于姓名、邮箱等字段的模糊搜索。
// Lambda方式：查询姓名包含“张”、以“张”结尾、以“张”开头，且不包含“李”的用户LambdaQueryWrapper&lt;User&gt; lambdaWrapper = new LambdaQueryWrapper&lt;&gt;();lambdaWrapper.like(User::getName, &quot;张&quot;)     // 全模糊：name LIKE %张%             .likeLeft(User::getName, &quot;张&quot;) // 左模糊：name LIKE %张             .likeRight(User::getName, &quot;张&quot;)// 右模糊：name LIKE 张%             .notLike(User::getName, &quot;李&quot;); // 不包含：name NOT LIKE %李%

二、复杂条件组合一、AND&#x2F;OR 条件组合（多条件并列与分支）**通过 **and() 和 or() 方法实现多条件的并列或分支组合，Lambda 表达式内可嵌套子条件，确保查询逻辑与业务需求一致。适用于 “满足 A 条件且（满足 B 或 C 条件）”“满足 A 条件或（满足 B 且 C 条件）” 等场景。
示例代码（查询逻辑：姓名为 “张三” 或 “李四”，****且 年龄大于 20；或 年龄大于 20 且小于 30）：
LambdaQueryWrapper&lt;User&gt; lambdaWrapper = new LambdaQueryWrapper&lt;&gt;();// 1. and() 内嵌套 OR 分支：整体为“（姓名=张三 或 姓名=李四）”的条件，与后续条件用 AND 连接lambdaWrapper.and(w -&gt; w.eq(User::getName, &quot;张三&quot;).or().eq(User::getName, &quot;李四&quot;))             // 2. or() 内嵌套 AND 分支：整体为“（年龄&gt;20 且 年龄&lt;30）”的条件，与前面条件用 OR 连接             .or(w -&gt; w.gt(User::getAge, 20).lt(User::getAge, 30));

上述代码中，and() 和 or() 方法的参数为 Lambda 表达式，用于定义分支内的子条件，避免因条件优先级混乱导致的查询错误，且字段引用（如 User::getName）无硬编码风险。
二、嵌套条件（强制条件优先级）**通过 **nested() 方法将一组子条件包裹为 “嵌套块”，强制该组子条件优先执行，适用于 “（满足 A 或 B 条件）且（满足 C 且 D 条件）” 等需要明确优先级的场景（类似 SQL 中的括号分组）。
示例代码（查询逻辑：（姓名为 “张三” 或 “李四”）****且（年龄大于 20 且小于 30））：
LambdaQueryWrapper&lt;User&gt; lambdaWrapper = new LambdaQueryWrapper&lt;&gt;();// 1. nested() 包裹第一个子条件块：（姓名=张三 或 姓名=李四），优先执行lambdaWrapper.nested(w -&gt; w.eq(User::getName, &quot;张三&quot;).or().eq(User::getName, &quot;李四&quot;))             // 2. and() 连接第二个子条件块：（年龄&gt;20 且 年龄&lt;30），与嵌套块用 AND 连接             .and(w -&gt; w.gt(User::getAge, 20).lt(User::getAge, 30));

**与普通 **and()&#x2F;or() 组合不同，nested() 明确标识子条件块的优先级，即使后续条件复杂，也能保证嵌套块内的逻辑优先执行，避免 SQL 解析时的优先级错乱。
三、排序与分页一、排序（控制结果集顺序）**通过 **orderByAsc（升序）和 orderByDesc（降序）方法指定排序字段，支持单字段或多字段排序，Lambda 方式直接引用实体类字段，避免字段名硬编码错误。

核心逻辑


升序：orderByAsc(实体类::字段名1, 实体类::字段名2)（按字段 1 升序，字段 1 相同则按字段 2 升序）
降序：orderByDesc(实体类::字段名)
可组合使用升序与降序方法，满足复杂排序需求。


示例代码

// Lambda方式：按年龄升序、ID升序，再按创建时间降序排序LambdaQueryWrapper&lt;User&gt; lambdaWrapper = new LambdaQueryWrapper&lt;&gt;();lambdaWrapper.orderByAsc(User::getAge, User::getId)  // 多字段升序：先age，再id             .orderByDesc(User::getCreateTime);       // 单字段降序：create_time// 执行查询，结果按上述规则排序List&lt;User&gt; sortedUsers = userMapper.selectList(lambdaWrapper);

上述排序逻辑对应文档中 Lambda 方式的排序实现，通过链式调用明确排序规则，可读性与可维护性更强。
二、分页（大数据量分批获取）**分页需先配置分页插件，再通过 **Page 对象指定分页参数（当前页、每页大小），结合 LambdaQueryWrapper 实现条件分页查询，支持获取总记录数、当前页数据等关键信息。
1. 前置步骤：配置分页插件
**需在配置类中注册 **PaginationInnerInterceptor 插件（指定数据库类型），确保分页功能生效：
@Configurationpublic class MybatisPlusConfig &#123;    @Bean    public MybatisPlusInterceptor mybatisPlusInterceptor() &#123;        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();        // 注册分页插件，指定数据库类型（如MySQL）        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));        return interceptor;    &#125;&#125;

上述分页插件配置为文档中生产环境的标准配置，是分页查询的前提。
2. 分页查询示例（Lambda 方式）
**通过 **Page 对象定义分页参数，结合 selectPage 方法执行分页查询，返回的 Page 对象包含总记录数、当前页数据等信息：
// 1. 构建分页对象：参数1=当前页（从1开始），参数2=每页大小Page&lt;User&gt; page = new Page&lt;&gt;(1, 10);  // 第1页，每页10条数据// 2. 构建Lambda查询条件：查询年龄&gt;20的用户LambdaQueryWrapper&lt;User&gt; lambdaWrapper = new LambdaQueryWrapper&lt;&gt;();lambdaWrapper.gt(User::getAge, 20);// 3. 执行分页查询：调用selectPage方法，传入分页对象与查询条件Page&lt;User&gt; resultPage = userMapper.selectPage(page, lambdaWrapper);// 4. 解析分页结果long total = resultPage.getTotal();  // 获取总记录数List&lt;User&gt; currentPageUsers = resultPage.getRecords();  // 获取当前页数据System.out.println(&quot;总记录数：&quot; + total);System.out.println(&quot;第1页数据：&quot; + currentPageUsers);

**该分页逻辑与文档中 Lambda 方式的分页实现一致，通过分页插件与 **Page 对象配合，高效处理大数据量查询，避免一次性加载过多数据导致内存溢出。
四、字段选择（筛选返回字段）**通过 **select 方法指定需要查询的实体类字段，仅返回目标字段数据（而非全表字段），减少数据传输量与数据库查询开销，适用于只需要部分字段的场景。

核心逻辑


语法：select(实体类::目标字段1, 实体类::目标字段2, ...)
**作用：仅查询指定字段，例如只查 **id、name、age，不查 email、createTime 等无关字段。


示例代码

// Lambda方式：仅查询用户的id、name、age字段，排除其他字段LambdaQueryWrapper&lt;User&gt; lambdaWrapper = new LambdaQueryWrapper&lt;&gt;();lambdaWrapper.select(User::getId, User::getName, User::getAge)  // 指定返回字段             .eq(User::getAge, 25);  // 附加查询条件：年龄=25// 执行查询，返回的User对象中仅id、name、age有值，其他字段为nullList&lt;User&gt; partialUsers = userMapper.selectList(lambdaWrapper);

**该实现与文档中 Lambda 方式的字段选择逻辑完全一致，通过 **select 方法精准控制返回字段，优化查询性能。
3.3 更新构造器示例// LambdaUpdateWrapper：更新名字=“张三”的用户LambdaUpdateWrapper&lt;User&gt; lambdaUpdate = new LambdaUpdateWrapper&lt;&gt;();lambdaUpdate.set(User::getAge,30)    .set(User::getEmail,&quot;new@example.com&quot;)    .eq(User::getName, &quot;张三&quot;);userMapper.update(null, lambdaUpdate);//UpdateWrapperUpdateWrapper&lt;User&gt; updateWrapper = new UpdateWrapper&lt;&gt;(); updateWrapper.set(&quot;age&quot;, 30)     .set(&quot;email&quot;, &quot;new@example.com&quot;)     .eq(&quot;name&quot;, &quot;张三&quot;); userMapper.update(null, updateWrapper);

3.4 动态条件构建根据参数有效性（非空 &#x2F; 非空白）决定是否添加查询条件，避免因参数无效导致的冗余 SQL 或错误查询，通过参数有效性判断实现条件的动态开关，避免编写大量 if-else 逻辑。
// 定义可能为空的查询参数String name = &quot;张三&quot;;    // 示例：姓名参数（非空）Integer minAge = 20;    // 示例：最小年龄参数（非空）Integer maxAge = 30;    // 示例：最大年龄参数（非空）// 1. 创建LambdaQueryWrapperLambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();// 2. 动态添加条件：仅当参数有效时，条件才生效wrapper.eq(StringUtils.isNotBlank(name), User::getName, name)  // 姓名非空白时，添加“name=张三”       .gt(minAge != null, User::getAge, minAge)              // 最小年龄非空时，添加“age&gt;20”       .lt(maxAge != null, User::getAge, maxAge);             // 最大年龄非空时，添加“age&lt;30”// 执行查询：最终条件为“name=张三 AND age&gt;20 AND age&lt;30”List&lt;User&gt; users = userMapper.selectList(wrapper);

3.5 子查询（Lambda 方式）**子查询是将一个查询结果作为另一个查询的条件（如 **IN 子句），MyBatis-Plus 支持传统字符串拼接、Lambda 语法及更安全的 “子 Wrapper” 三种方式，其中 Lambda 方式避免字段硬编码，“子 Wrapper” 方式进一步减少 SQL 注入风险。
// 传统⽅式queryWrapper.inSql(&quot;id&quot;, &quot;select id from user where age &gt; 20&quot;); // Lambda⽅式lambdaWrapper.inSql(User::getId, &quot;select id from user where age &gt; 20&quot;); // 更安全的⼦查询⽅式LambdaQueryWrapper&lt;User&gt; subWrapper = new LambdaQueryWrapper&lt;&gt;(); subWrapper     .select(User::getId)     .gt(User::getAge, 20); lambdaWrapper     .in(User::getId, userMapper.selectObjs(subWrapper))

3.6 最佳实践
优先使⽤ Lambda ⽅式：类型安全，重构友好
**合理使⽤动态条件：避免构建过于复杂的条件 **
**注意 SQL 注⼊⻛险：避免直接拼接⽤户输⼊ **
批量操作优化：对于⼤批量数据，使⽤分批处理

第 4 章：流式查询（处理大数据）4.1 两种实现方式
ResultHandler 方式（推荐）：
// Mapper接口定义@Select(&quot;SELECT * FROM user $&#123;ew.customSqlSegment&#125;&quot;)@Options(resultSetType = ResultSetType.FORWARD_ONLY)@ResultType(User.class)void selectStream(@Param(Constants.WRAPPER) Wrapper&lt;User&gt; wrapper, ResultHandler&lt;User&gt; handler);// 使用：逐行处理数据，避免OOMuserMapper.selectStream(Wrappers.emptyWrapper(), context -&gt; &#123;  User user = context.getResultObject();  // 处理逻辑  System.out.println(&quot;已处理第&quot; + context.getResultCount() + &quot;条&quot;);&#125;);
Cursor 方式（Java8+，需事务）：
// Mapper定义@Select(&quot;SELECT * FROM user LIMIT #&#123;limit&#125;&quot;)Cursor&lt;User&gt; scan(@Param(&quot;limit&quot;) int limit);// 使用（try-with-resources自动关闭）@Transactional // 必须加事务，保持连接try (Cursor&lt;User&gt; cursor = userMapper.scan(100000)) &#123;  cursor.forEach(user -&gt; &#123; /* 处理逻辑 */ &#125;);&#125;

注意：必须⼿动关闭 Cursor 或使⽤ try-with-resources


4.2 结合 MyBatis-Plus 特性的实现结合 MyBatis-Plus 特性的流式查询主要包含****通用 BaseMapper 流式查询与带条件的分页流式处理两类，核心是借助 BaseMapper 原生方法 + ResultHandler 实现数据逐行 &#x2F; 分批处理，避免大数据量加载导致的内存溢出（OOM）。
1、通用 BaseMapper 流式查询无需自定义 Mapper 接口方法，直接使用 BaseMapper 自带的selectList 方法，通过传入 Wrappers.emptyWrapper()（无额外查询条件时）和 ResultHandler 接口，实现对查询结果的逐行流式处理。该方式支持 BaseMapper 的所有查询方法（如带条件的 selectList），无需额外扩展，简化开发流程。
// 直接调用BaseMapper的selectList方法，实现流式查询userMapper.selectList(    Wrappers.emptyWrapper(), // 无额外查询条件（若需条件，可替换为LambdaQueryWrapper）    new ResultHandler&lt;User&gt;() &#123; // 结果处理器：逐行处理查询到的数据        @Override        public void handleResult(ResultContext&lt;? extends User&gt; context) &#123;            // 1. 获取当前流式处理的单条数据            User currentUser = context.getResultObject();            // 2. 自定义数据处理逻辑（如数据校验、格式转换、写入文件等）            // 示例：打印当前处理的数据ID            System.out.println(&quot;正在处理用户ID：&quot; + currentUser.getId());            // 注意：此处逻辑需轻量化，避免阻塞流式处理        &#125;    &#125;);


**Wrappers.emptyWrapper()**：当无需筛选条件（查询全表数据）时使用，若需添加查询条件（如年龄 &gt; 20），可替换为 Wrappers.lambdaQuery().gt(User::getAge, 20)，兼容所有 Lambda 条件构造器用法；
**ResultContext**：用于获取流式处理的上下文信息，核心方法 getResultObject() 获取当前行数据，还可通过 getResultCount() 获取已处理的数据总数；
支持范围：文档明确说明 “支持所有 BaseMapper 的查询方法”，即 BaseMapper 中带 ResultHandler 参数的查询方法（如 selectByMap、selectOne 等），均可用此方式实现流式处理。

2、带条件的分页流式处理针对 “需筛选条件 + 大数据量分批处理” 场景，结合****分页（控制每批数据量） 与 Lambda 条件（筛选目标数据），通过 BaseMapper 的 selectList 方法传入 Page（分页参数）、LambdaQueryWrapper（查询条件）和 ResultHandler（批量处理逻辑），实现 “按批次流式处理符合条件的数据”，精准控制内存占用。
// 1. 构建分页对象：控制每批处理的数据量（当前页=1，每页大小=10000，即每批处理1万条）Page&lt;User&gt; page = new Page&lt;&gt;(1, 10000); // 2. 构建Lambda查询条件：筛选“年龄&gt;20”的用户（可根据业务扩展条件）LambdaQueryWrapper&lt;User&gt; wrapper = Wrappers.lambdaQuery();wrapper.gt(User::getAge, 20); // 筛选条件：age &gt; 20// 3. 调用BaseMapper的selectList，实现分页流式处理userMapper.selectList(    page,          // 分页参数：控制每批数据量    wrapper,       // 条件构造器：筛选目标数据    context -&gt; &#123;   // 结果处理器：批量处理当前批次的数据        // 1. 获取当前批次中的单条数据        User user = context.getResultObject();        // 2. 批量处理逻辑（如批量写入数据库、批量导出Excel等）        // 示例：将当前用户数据添加到临时集合，累计到1000条时统一处理        tempUserList.add(user);        if (tempUserList.size() &gt;= 1000) &#123;            batchExport(tempUserList); // 自定义批量导出方法            tempUserList.clear(); // 清空集合，释放内存        &#125;    &#125;);


分页参数作用：Page&lt;&gt;(1, 10000) 中 “10000” 为每批处理的最大条数，即使待处理数据总量为 100 万条，也会自动拆分为 100 批（每批 1 万条）逐步处理，避免一次性加载 100 万条数据到内存；
条件与流式结合：Lambda 条件（gt(User::getAge, 20)）先筛选出符合条件的数据，再按分页批量流式处理，避免对无关数据进行无效处理，提升效率；
批量处理优势：相比 “逐行处理”，“每批 1 万条 + 批量逻辑” 减少 IO 次数（如批量写入文件 &#x2F; 数据库），平衡内存占用与处理效率。

4.3 场景选择


场景
推荐方案
特点



简单流式处理
ResultHandler
配置简单，无需事务


Java8 流式操作
Cursor
支持 Stream API


大数据量批处理
分页 + 流式
内存控制更精确（每批 1 万条）


复杂事务场景
@Transactional
保证数据一致性


4.4 注意事项
流式查询期间保持数据库连接打开，避免中途断连；
合理设置fetchSize（500-5000），避免频繁 IO；
不建议在流式处理中执行其他数据库操作。
结果集类型必须为FORWARD_ONLY

第 5 章：枚举映射（自动转换）5.1 两种实现方式
@EnumValue 注解（推荐）： **通过 **@EnumValue 直接标记枚举中 “需存入数据库的属性”，MyBatis-Plus 会自动将该属性值与数据库字段关联，支持 String、Integer 等多种类型。public enum GenderEnum &#123;  MALE(&quot;M&quot;, &quot;男性&quot;), FEMALE(&quot;F&quot;, &quot;女性&quot;);  @EnumValue // 标记存入数据库的值  private final String code;  private final String desc;  // 构造器+getter&#125;
实现 IEnum 接口： **通过实现 MyBatis-Plus 提供的 **IEnum 接口，并覆写 getValue() 方法，指定 “存入数据库的枚举值”。该方式需强绑定接口，灵活性略低于 @EnumValue 注解。public enum StatusEnum implements IEnum&lt;Integer&gt; &#123;  LOCK(1, &quot;锁定&quot;), DISABLE(2, &quot;禁用&quot;);  private final int value;  private final String desc;  @Override public Integer getValue() &#123; return this.value; &#125; // 必须实现&#125;

5.2 配置差异
3.5.2 + 版本：无需额外配置，直接在实体类用枚举字段即可；
3.5.2 之前：需在 application.yml 配置枚举包路径：mybatis-plus:  type-enums-package: com.example.enums

5.3 实体类与数据库设计（对应关系）1. 实体类中使用枚举**在实体类（如 **User）中直接声明枚举类型属性，无需额外注解（除 @Data 等 Lombok 注解）。
import lombok.Data;import com.baomidou.mybatisplus.annotation.TableName;@Data@TableName(&quot;user&quot;) // 关联数据库表public class User &#123;    private Long id; // 主键    private String name; // 用户名    // 枚举属性1：使用IEnum接口的枚举（对应数据库status字段）    private StatusEnum status;     // 枚举属性2：使用@EnumValue注解的枚举（对应数据库gender字段）    private GenderEnum gender; &#125;

2. 数据库表设计**数据库表字段类型需与枚举的 “映射值类型” 一致（如 **StatusEnum 的 value 为 int，数据库字段设为 INT；GenderEnum 的 code 为 String，数据库字段设为 CHAR(1)）。
CREATE TABLE user (    id BIGINT PRIMARY KEY AUTO_INCREMENT, -- 主键自增    name VARCHAR(50) NOT NULL COMMENT &#x27;用户名&#x27;, -- 用户名    status INT DEFAULT 1 COMMENT &#x27;状态（1=锁定，2=禁用）&#x27;, -- 对应StatusEnum的value（int类型）    gender CHAR(1) COMMENT &#x27;性别（M=男性，F=女性）&#x27; -- 对应GenderEnum的code（char(1)类型）) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

5.4 常见问题
枚举值为 null：检查数据库字段类型与枚举值类型匹配（如 tinyint 不能映射 boolean）；
JSON 序列化：用 Jackson 时添加 @JsonValue 注解指定序列化值（如 @JsonValue private final String code）。

第 6 章：自动填充（审计字段）MyBatis-Plus 提供了强⼤的⾃动填充功能，可以⾃动为创建时间、更新时间等公共字段赋值，极⼤简化了开发⼯作。以下是完 整的实现⽅案：
6.1 基础配置
实体类标注填充规则：@Datapublic class User &#123;  @TableField(fill = FieldFill.INSERT) // 插入时填充（创建时间/创建人）  private LocalDateTime createTime;  @TableField(fill = FieldFill.INSERT_UPDATE) // 插入+更新时填充（更新时间/更新人）  private LocalDateTime updateTime;  @TableField(fill = FieldFill.INSERT)  private Long createUser;&#125;
实现 MetaObjectHandler：@Component // 必须交给Spring管理public class MyMetaObjectHandler implements MetaObjectHandler &#123;  @Override  public void insertFill(MetaObject metaObject) &#123;    // 严格模式：字段类型必须匹配（推荐）    this.strictInsertFill(metaObject, &quot;createTime&quot;, LocalDateTime.class, LocalDateTime.now());    this.strictInsertFill(metaObject, &quot;createUser&quot;, Long.class, getCurrentUserId());    this.strictInsertFill(metaObject, &quot;updateTime&quot;, LocalDateTime.class, LocalDateTime.now());  &#125;  @Override  public void updateFill(MetaObject metaObject) &#123;    this.strictUpdateFill(metaObject, &quot;updateTime&quot;, LocalDateTime.class, LocalDateTime.now());    this.strictUpdateFill(metaObject, &quot;updateUser&quot;, Long.class, getCurrentUserId());  &#125;  // 用ThreadLocal获取当前用户ID（登录时设置）  private Long getCurrentUserId() &#123; return BaseContext.getCurrentId(); &#125;&#125;

6.2 高级功能
ThreadLocal 存储用户：BaseContext 类用 static ThreadLocal&lt;Long&gt; 存当前用户 ID，登录拦截器中设置；

public class BaseContext &#123;
     private static ThreadLocal&lt;Long&gt; threadLocal = new ThreadLocal&lt;&gt;();
     public static void setCurrentId(Long id) &#123;
            threadLocal.set(id);
         &#125;
     public static Long getCurrentId() &#123;
         return threadLocal.get();
         &#125;
 &#125;
* **在登录过滤器或拦截器中设置⽤户 ID：**
//登录成功后设置
BaseContext.setCurrentId(loginUser.getId())
* **填充模式：**  * **严格模式（**`strictInsertFill`）：字段类型不匹配则不填充，安全性高；  * **非严格模式（**`setFieldValByName`）：更灵活，但易出错。
// 严格模式（推荐）
this.strictInsertFill(metaObject, &quot;createTime&quot;, LocalDateTime.class, LocalDateTime.now());
 // ⾮严格模式
metaObject.setValue(&quot;createTime&quot;, new Date());
#### 6.3 常见问题* **填充不生效**：检查 `@Component` 是否添加、实体字段名与填充方法一致、strict 模式下类型匹配；* **时间类型**：推荐用 `LocalDateTime`（JDK8+），避免 `Date` 的线程安全问题。### 第 7 章：主键策略#### 7.1 策略类型（IdType 枚举）| **策略值**       | **描述**                                          || ---------------- | ------------------------------------------------- || **AUTO**         | **数据库自增（需表字段设 AUTO\_INCREMENT）**      || **NONE**         | **跟随全局配置（默认全局为 ASSIGN\_ID）**         || **INPUT**        | **手动设置主键（或实现 IKeyGenerator）**          || **ASSIGN\_ID**   | **自动分配 ID（默认雪花算法，支持 Long/String）** || **ASSIGN\_UUID** | **自动分配 UUID（String 类型，无中划线）**        |#### 7.2 配置优先级1. **局部注解（最高）**：`@TableId(type = IdType.AUTO) private Long id`；
 @Data
public class Permission &#123;
   @TableId(value = &quot;id&quot;, type = IdType.AUTO) // 数据库⾃增
   private Long id;
   @TableId(type = IdType.ASSIGN_ID) // 雪花算法（默认）
   private String orderId;
&#125;
 2. **全局配置（中）：**
 mybatis-plus:
 global-config:
   db-config:
     id-type: assign_id # 全局默认雪花算法



 3. **默认策略（最低）**：未配置时默认 `ASSIGN_ID`。#### 7.3 策略详解* **雪花算法（ASSIGN\_ID）**： 默认实现类：`DefaultIdentifierGenerator`  * **64 位 ID（1 符号位 + 41 时间戳 + 10 机器 ID+12 序列号），支持分布式，每秒生成 400 万 + ID；*** **数据库自增（AUTO）**：需表字段设 `AUTO_INCREMENT`，适合单机项目；  * **实体类配置：**
   @TableId(type &#x3D; IdType.AUTO)  private Long id;  * **UUID（ASSIGN\_UUID）**：无需数据库依赖，适合字符串主键场景。  * ```    @TableId(type = IdType.ASSIGN_UUID)     private String uuid;


7.4 自定义策略实现IdentifierGenerator 接口：
@Componentpublic class CustomIdGenerator implements IdentifierGenerator &#123;  @Override  public Long nextId(Object entity) &#123;    return IdWorker.getId(); // 自定义ID生成逻辑  &#125;&#125;

第 8 章：逻辑删除（软删除）8.1 基础实现
数据库准备：添加逻辑删除字段 ALTER TABLE user ADD COLUMN deleted TINYINT DEFAULT 0 COMMENT &#39;逻辑删除标识&#39;；
配置方式：
方式 1：实体类注解@TableLogic private Integer deleted；
方式 2：全局配置（推荐，统一规则）：mybatis-plus:  global-config:    db-config:      logic-delete-field: deleted # 实体类字段名      logic-delete-value: 1 # 已删除值      logic-not-delete-value: 0 # 未删除值



8.2 核心特性
自动 SQL 改写：
删除：DELETE FROM user WHERE id=? → UPDATE user SET deleted=1 WHERE id=? AND deleted=0；
查询：自动添加WHERE deleted=0（无需手动写条件）；


无感知使用：调用 userMapper.deleteById(id) 即可触发逻辑删除，与物理删除用法一致。

8.3 注意事项
性能优化：为 deleted 字段加索引（ALTER TABLE user ADD INDEX idx_deleted (deleted)）；
查询已删除数据：用 wrapper.last(&quot;OR deleted = 1&quot;) 关闭自动过滤；
自定义 SQL：手写 SQL 需手动处理 deleted 条件。

8.4 高级用法
**查询包含已删除数据 **

// 1. 创建LambdaQueryWrapper，查询ID为1的用户（包含已删除数据）LambdaQueryWrapper&lt;User&gt; wrapper = Wrappers.lambdaQuery();wrapper.eq(User::getId, 1L) // 基础条件：ID = 1       .last(&quot;OR deleted = 1&quot;); // 关键：追加条件，包含已删除数据（假设已删除值为1）// 2. 执行查询：返回ID=1的所有数据（无论是否删除）List&lt;User&gt; userList = userMapper.selectList(wrapper);


⾃定义删除值

  // 自定义逻辑删除值：未删除=0，已删除=2（覆盖默认的0/1）//@TableLogic 注解的 value（未删除值）和 delval（已删除值）参数配置，优先级高于全局配置。   @TableLogic(value = &quot;0&quot;, delval = &quot;2&quot;)    private Integer deleted; // 逻辑删除字段


全局配置优先级




配置层级
配置方式
优先级



注解配置
在实体类字段上用@TableLogic(value = &quot;...&quot;, delval = &quot;...&quot;) 配置
最高


全局配置
在application.yml 中通过 mybatis-plus.global-config.db-config 配置
中间


默认配置
未任何配置时，默认 “未删除 &#x3D; 0，已删除 &#x3D; 1”，逻辑删除字段名为deleted
最低


第 9 章：多数据源（动态切换）9.1 基础配置
引入依赖：&lt;dependency&gt;  &lt;groupId&gt;com.baomidou&lt;/groupId&gt;  &lt;artifactId&gt;dynamic-datasource-spring-boot-starter&lt;/artifactId&gt;  &lt;version&gt;3.6.1&lt;/version&gt;&lt;/dependency&gt;
YAML 配置（主从分离示例）：spring:  datasource:    dynamic:      primary: master # 默认数据源      strict: false # 不严格匹配数据源（不存在时用默认）      datasource:        master:          url: jdbc:mysql://你的数据库url?useSSL=false&amp;serverTimezone=UTC          username: root          password: root        slave1:          url: jdbc:mysql://你的数据库url?useSSL=false&amp;serverTimezone=UTC          username: root          password: 123456

9.2 核心使用方式
注解切换（@DS）：@Service@DS(&quot;slave1&quot;) // 类级别默认数据源public class UserServiceImpl &#123;  @DS(&quot;master&quot;) // 方法级别覆盖（优先级更高）  public void saveUser(User user) &#123; userMapper.insert(user); &#125;&#125;
编程式切换（动态场景）：try &#123;  DynamicDataSourceContextHolder.push(&quot;slave2&quot;); // 切换到slave2  // 执行数据库操作&#125; finally &#123;  DynamicDataSourceContextHolder.clear(); // 必须清理，避免连接泄漏&#125;

9.3 最佳实践
连接池：推荐配合 Druid 或 HikariCP 使用；
事务：跨数据源操作需用 @DSTransactional（而非 @Transactional）；
监控：集成 Actuator 监控各数据源连接状态。

第 10 章：类型处理器（字段转换）10.1 内置 JSON 处理器（常用）
配置步骤：

实体类：@TableName(autoResultMap = true)（必须开启）+@TableField(typeHandler = JacksonTypeHandler.class)；

@Data@TableName(autoResultMap = true)public class User &#123;  @TableField(typeHandler = JacksonTypeHandler.class)  private Map&lt;String, String&gt; contact; // 自动转为JSON存储到数据库&#125;


引入依赖：&lt;dependency&gt;  &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;  &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;  &lt;version&gt;2.13.3&lt;/version&gt;&lt;/dependency&gt;


测试：插入时 contact（Map）自动转 JSON，查询时自动转 Map。


10.2 注意事项
@TableName(autoResultMap = true) 必须加，否则查询时无法反序列化；
字段为 null 时，检查类型处理器是否注册、数据库字段是否允许 NULL。

第 11 章：扩展插件（生产必备）11.1 分页插件（PaginationInnerInterceptor）@Configurationpublic class MybatisPlusConfig &#123;  @Bean  public MybatisPlusInterceptor mybatisPlusInterceptor() &#123;    MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();    // 设置数据库类型（MySQL/Oracle等）    interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));    return interceptor;  &#125;&#125;// 使用：查询第1页，每页10条，条件“status=1”Page&lt;User&gt; page = new Page&lt;&gt;(1, 10);userMapper.selectPage(page, Wrappers.&lt;User&gt;query().eq(&quot;status&quot;, 1));System.out.println(&quot;总记录数：&quot; + page.getTotal());

11.2 乐观锁插件（OptimisticLockerInnerInterceptor）
作用：解决高并发数据冲突（基于版本号）；
配置：
实体类加版本字段：@Version private Integer version；
注册插件（同上MybatisPlusConfig）；


测试：User user1 = userMapper.selectById(1L); // version=1User user2 = userMapper.selectById(1L); // version=1user1.setName(&quot;A&quot;);userMapper.updateById(user1); // 成功，version=2user2.setName(&quot;B&quot;);userMapper.updateById(user2); // 失败，version不匹配

11.3 防全表操作插件（BlockAttackInnerInterceptor）
作用：阻止 delete null&#x2F;update null（避免误删全表）；
配置：注册插件后，执行 userMapper.delete(null) 会抛出 MybatisPlusException。@Bean public MybatisPlusInterceptor mybatisPlusInterceptor() &#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();    interceptor.addInnerInterceptor(new BlockAttackInnerInterceptor()); return interceptor; &#125; // 测试⾮法操作（会抛出异常）userMapper.delete(null); // 抛出MybatisPlusException userMapper.update(new User(), null); // 抛出异常

11.4 动态表名插件（DynamicTableNameInnerInterceptor）
作用：按规则动态切换表名（如分年表 order_2024&#x2F;order_2025）；
配置：interceptor.addInnerInterceptor(new DynamicTableNameInnerInterceptor() &#123;&#123;  setTableNameHandler((sql, tableName) -&gt; &#123;    if (&quot;order&quot;.equals(tableName)) &#123;      return &quot;order_&quot; + LocalDate.now().getYear(); // 动态拼接年份    &#125;    return tableName;  &#125;);&#125;&#125;);

11.5 多租户插件（TenantLineInnerInterceptor）
作用：数据隔离（自动给 SQL 加 tenant_id = ? 条件）；
配置：interceptor.addInnerInterceptor(new TenantLineInnerInterceptor(new TenantLineHandler() &#123;  @Override  public Expression getTenantId() &#123;    return new LongValue(1L); // 从上下文获取当前租户ID（如ThreadLocal）  &#125;  @Override  public String getTenantIdColumn() &#123;    return &quot;tenant_id&quot;; // 租户字段名  &#125;&#125;)); // 实体类需包含tenant_id字段@Data public class User &#123;     private Long tenantId; &#125;
实体类需包含tenant_id 字段。

11.6 插件执行顺序（推荐）
多租户插件（TenantLineInnerInterceptor）
动态表名插件（DynamicTableNameInnerInterceptor）
分页插件（PaginationInnerInterceptor）
乐观锁插件（OptimisticLockerInnerInterceptor）
防全表插件（BlockAttackInnerInterceptor）

interceptor.addInnerInterceptor(new TenantLineInnerInterceptor()); // 多租户第⼀interceptor.addInnerInterceptor(new DynamicTableNameInnerInterceptor()); // 动态表名第⼆interceptor.addInnerInterceptor(new PaginationInnerInterceptor()); // 分⻚第三interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor()); // 乐观锁第四interceptor.addInnerInterceptor(new BlockAttackInnerInterceptor()); // 防全表最后

第 12 章：代码生成（效率提升 200%）12.1 基础配置（FastAutoGenerator）
引入依赖：&lt;dependency&gt;  &lt;groupId&gt;com.baomidou&lt;/groupId&gt;  &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;  &lt;version&gt;3.5.1&lt;/version&gt;&lt;/dependency&gt;
生成器类：public class AutoCodeGenerator &#123;  public static void main(String[] args) throws IOException &#123;    String url = &quot;jdbc:mysql://10.211.55.7:3306/mybatis_plus_demo?useSSL=false&amp;serverTimezone=UTC&quot;;    String username = &quot;root&quot;;    String password = &quot;root&quot;;    String tableName = &quot;test_code_generator&quot;; // 多表用逗号分隔    String projectPath = System.getProperty(&quot;user.dir&quot;);    FastAutoGenerator.create(new DataSourceConfig.Builder(url, username, password))      // 全局配置：作者、输出路径      .globalConfig(builder -&gt; builder.author(&quot;乐哥聊编程&quot;).outputDir(projectPath + &quot;/src/main/java&quot;))      // 包配置：父包名、模块名、各层包名      .packageConfig(builder -&gt; builder        .parent(&quot;com.lglbc&quot;)        .moduleName(&quot;demo&quot;)        .entity(&quot;entity&quot;)        .mapper(&quot;mapper&quot;)        .service(&quot;service&quot;)        .controller(&quot;controller&quot;)      )      // 策略配置：表名、主键策略、命名规则      .strategyConfig(builder -&gt; builder        .addInclude(tableName.split(&quot;,&quot;))        .entityBuilder()        .idType(IdType.AUTO)        .naming(NamingStrategy.underline_to_camel) // 下划线转驼峰        .columnNaming(NamingStrategy.underline_to_camel)        .RestControllerStyle() // Controller加@RestController      )      .templateEngine(new FreemarkerTemplateEngine()) // 模板引擎      .execute();  &#125;&#125;

12.2 生成文件
自动生成：实体类（含@Data&#x2F;@TableName）、Mapper 接口、Service（含 IService&#x2F;ServiceImpl）、Controller（含 CRUD 接口）。

12.3 IDEA 插件（可选）
安装「MyBatisPlus」插件，配置数据库后，选中表即可一键生成代码，支持自定义模板。

三、总结
极简开发：
告别 XML 配置，用 Lambda 写查询，代码量减少 50%；
示例：传统 MyBatis 需写 XML，MP 直接userMapper.selectList(Wrappers.&lt;User&gt;lambdaQuery().eq(User::getName, &quot;张三&quot;))。


企业级插件实战：
分页：5 行代码实现百万级数据分页；
乐观锁：解决高并发冲突；
多租户：一套代码支持多客户数据隔离。


性能优化：
动态表名应对分库分表；
字段加密保护敏感数据；
内置 SQL 注入防御。



]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Mybatis-plus</tag>
      </tags>
  </entry>
  <entry>
    <title>欢迎来到老江湖的世界</title>
    <url>/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E8%80%81%E6%B1%9F%E6%B9%96%E7%9A%84%E4%B8%96%E7%95%8C/index.html</url>
    <content><![CDATA[老江湖进房间门，这故事得从去年说起，说来话长，我们长话短说…
]]></content>
  </entry>
  <entry>
    <title>tag</title>
    <url>/tag/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>category</title>
    <url>/category/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>关于我</title>
    <url>/about/index.html</url>
    <content><![CDATA[我有个可爱的女友，希望我们能够长长久久。
❤️ 老江湖爱房间门。
博客的由来老江湖拿来记录学习情况，以及分享老江湖和房间门的趣事。
]]></content>
  </entry>
  <entry>
    <title>时间线</title>
    <url>/timeLine/index.html</url>
    <content><![CDATA[2024.10.5🎉老江湖和房间门确认关系的日子。
2024.10.12老江湖给房间门过的第一个生日🎂
2024.10.21房间门给老江湖过的第一个生日🎂
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/js/code-copy.js</url>
    <content><![CDATA[document.addEventListener('DOMContentLoaded', () => {
  document.querySelectorAll('figure.highlight').forEach((figure) => {
    if (figure.querySelector('.copy-btn')) return;

    const copyBtn = document.createElement('button');
    copyBtn.className = 'copy-btn';
    copyBtn.title = '复制';

    // 缩小后的复制图标（14*15）
    const copyIcon = `
      
        
      
    `;

    // 成功后显示的勾（14*15）
    const checkIcon = `
      
        
      
    `;

    copyBtn.innerHTML = copyIcon;

    // 按钮样式（浅灰底、缩小）
    Object.assign(copyBtn.style, {
      position: 'absolute',
      top: '8px',
      right: '8px',
      padding: '4px',
      background: '#aaa', 
      border: 'none',
      borderRadius: '4px',
      cursor: 'pointer', 
      opacity: '0.85',
      zIndex: 1000,
      transition: 'opacity 0.2s ease',
      boxShadow: '0 1px 3px rgba(0, 0, 0, 0.15)'
    });

    copyBtn.addEventListener('mouseover', () => copyBtn.style.opacity = '1');
    copyBtn.addEventListener('mouseout', () => copyBtn.style.opacity = '0.85');

    copyBtn.addEventListener('click', () => {
      const code = figure.querySelector('td.code');
      const text = code ? code.innerText : '';
      navigator.clipboard.writeText(text).then(() => {
        copyBtn.innerHTML = checkIcon;
        setTimeout(() => {
          copyBtn.innerHTML = copyIcon;
        }, 1000);
      });
    });

    figure.style.position = 'relative';
    figure.appendChild(copyBtn);
  });
});
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/tongji/index.html</url>
    <content><![CDATA[


]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/%E7%85%A7%E7%89%87%E5%A2%99/index.html</url>
    <content><![CDATA[

  
    
    
    照片墙展示
    
    
    
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              primary: "#3B82F6",
              secondary: "#6B7280",
              accent: "#EC4899",
            },
            fontFamily: {
              sans: ["Inter", "system-ui", "sans-serif"],
            },
          },
        },
      };
    
    
      @layer utilities {
        .content-auto {
          content-visibility: auto;
        }
        .masonry-grid {
          column-count: 1;
          column-gap: 1rem;
        }
        @screen md {
          .masonry-grid {
            column-count: 2;
          }
        }
        @screen lg {
          .masonry-grid {
            column-count: 3;
          }
        }
        @screen xl {
          .masonry-grid {
            column-count: 4;
          }
        }
        .masonry-item {
          break-inside: avoid;
          margin-bottom: 1rem;
        }
        .glass-effect {
          backdrop-filter: blur(8px);
          background-color: rgba(255, 255, 255, 0.15);
        }
        .photo-hover {
          transition: transform 0.3s ease, filter 0.3s ease;
        }
        .photo-info {
          opacity: 0;
          transform: translateY(10px);
          transition: opacity 0.3s ease, transform 0.3s ease;
        }
        .photo-container:hover .photo-hover {
          filter: brightness(0.7);
        }
        .photo-container:hover .photo-info {
          opacity: 1;
          transform: translateY(0);
        }
      }
    
  
  
    
    
      
      
    
    
    
      
      
        
      
      
      
        
      
      
      
        
        
      
    

    
    
      
        老江湖的照片墙
      
      
        记录生活中的美好瞬间，每一张照片都有一个故事
      
    

    

    
    
      
     
            
            
                
                    
                    
                        
                            广州塔和房间门
                            同房间门去广州拍的
                        
                    
                
            
            

    
    
      
      
        
          
        
        
          
            
          
          
            
            
              
              •
              
            
            
              
            
          
        
      
    

        
    
      
      
        
          
            
          
          背景音乐
          是否开启背景音乐以获得更好的浏览体验？ 开启后可以在左上角关闭音乐
          
            
              不开启
            
            
              开启音乐
            
          
        
      
    

    
      // 照片数据
      const photos = [
    {
        id: 0,
        src: "https://oss.itbaima.cn/hub/928/image-20250926zxxyud4i0.jpeg",
        alt: "同房间门去广州拍的",
        title: "广州塔和房间门",
        date: "2024年11月8日",
        location: "广州",
        description: "我和房间门在校运会的三天假期跑去广州玩，在前往广州塔的路上，经过这个公园，我觉得很好的景，就让房间门站那，然后我就拍了。"
    }
];


      // DOM 元素
      const modal = document.getElementById("photoModal");
      const modalContent = document.getElementById("modalContent");
      const modalImage = document.getElementById("modalImage");
      const modalTitle = document.getElementById("modalTitle");
      const modalDate = document.getElementById("modalDate");
      const modalLocation = document.getElementById("modalLocation");
      const modalDescription = document.getElementById("modalDescription");
      const closeModal = document.getElementById("closeModal");
      const modalOverlay = document.getElementById("modalOverlay");
      const photoContainers = document.querySelectorAll(".photo-container");
      const musicToggle = document.getElementById("musicToggle");
      const backgroundMusic = document.getElementById("backgroundMusic");

      // 打开模态框
      function openModal(photo) {
        modalImage.src = photo.src;
        modalImage.alt = photo.alt;
        modalTitle.textContent = photo.title;
        modalDate.innerHTML = `${photo.date}`;
        modalLocation.innerHTML = `${photo.location}`;
        modalDescription.textContent = photo.description;

        modal.classList.remove("opacity-0", "pointer-events-none");
        setTimeout(() => {
          modalContent.classList.remove("scale-95");
          modalContent.classList.add("scale-100");
        }, 10);

        document.body.style.overflow = "hidden";
      }

      // 关闭模态框
      function closeModalFunc() {
        modalContent.classList.remove("scale-100");
        modalContent.classList.add("scale-95");
        setTimeout(() => {
          modal.classList.add("opacity-0", "pointer-events-none");
          document.body.style.overflow = "";
        }, 300);
      }

      // 照片点击事件
      photoContainers.forEach((container) => {
        container.addEventListener("click", () => {
          const index = parseInt(container.dataset.index);
          openModal(photos[index]);
        });

        // 鼠标移动视差效果
        container.addEventListener("mousemove", (e) => {
          const rect = container.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;

          const xPos = (x / rect.width - 0.5) * 10;
          const yPos = (y / rect.height - 0.5) * 10;

          const img = container.querySelector("img");
          img.style.transform = `translate(${xPos}px, ${yPos}px)`;
        });

        // 鼠标离开时恢复
        container.addEventListener("mouseleave", () => {
          const img = container.querySelector("img");
          img.style.transform = "translate(0, 0)";
        });
      });

      // 关闭模态框事件
      closeModal.addEventListener("click", closeModalFunc);
      modalOverlay.addEventListener("click", closeModalFunc);

      // 音乐控制
      musicToggle.addEventListener("click", () => {
        if (backgroundMusic.paused) {
          backgroundMusic.play().catch((e) => {
            console.log("播放失败:", e);
            alert("自动播放被浏览器阻止，请手动点击播放按钮");
          });
          musicToggle.innerHTML = '';
        } else {
          backgroundMusic.pause();
          musicToggle.innerHTML = '';
        }
      });

 // 键盘ESC关闭模态框
      document.addEventListener("keydown", (e) => {
        if (
          e.key === "Escape" &&
          !modal.classList.contains("pointer-events-none")
        ) {
          closeModalFunc();
        }
      });

      // 音乐提示模态框
      const musicModal = document.getElementById("musicModal");
      const confirmMusic = document.getElementById("confirmMusic");
      const cancelMusic = document.getElementById("cancelMusic");

      // 页面加载完成后显示音乐提示
      window.addEventListener('load', () => {
        // 添加一个微小的延迟以确保页面完全加载
        setTimeout(() => {
          musicModal.classList.remove("opacity-0", "pointer-events-none");
          const musicModalContent = musicModal.querySelector('div.relative');
          setTimeout(() => {
            musicModalContent.classList.remove("scale-95");
            musicModalContent.classList.add("scale-100");
          }, 10);
        }, 1000);
      });

      // 确认播放音乐
      confirmMusic.addEventListener("click", () => {
        closeMusicModal();
        backgroundMusic.play().catch((e) => {
          console.log("播放失败:", e);
          // 播放失败时更新按钮状态
          musicToggle.innerHTML = '';
        });
        musicToggle.innerHTML = '';
      });

      // 取消播放音乐
      cancelMusic.addEventListener("click", closeMusicModal);

      // 关闭音乐提示模态框
      function closeMusicModal() {
        const musicModalContent = musicModal.querySelector('div.relative');
        musicModalContent.classList.remove("scale-100");
        musicModalContent.classList.add("scale-95");
        setTimeout(() => {
          musicModal.classList.add("opacity-0", "pointer-events-none");
        }, 300);
      }

    
  

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/manager/photo-manager.html</url>
    <content><![CDATA[


    
    
    照片管理器
    
    
    
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3B82F6',
                        secondary: '#6B7280',
                        accent: '#EC4899',
                    }
                }
            }
        }
    
    
        .glass-effect {
            backdrop-filter: blur(8px);
            background-color: rgba(255, 255, 255, 0.15);
        }
    


    
        
            照片管理器
            添加和管理您的照片墙内容
        

        
            
            
                添加新照片
                
                    
                        照片URL
                        
                    
                    
                        照片描述 (alt)
                        
                    
                    
                        照片标题
                        
                    
                    
                        拍摄日期
                        
                    
                    
                        拍摄地点
                        
                    
                    
                        详细描述
                        
                    
                    
                        
                            重置
                        
                        
                            添加照片
                        
                    
                
            

            
            
                照片列表
                
                    暂无照片
                
                
                生成代码
                
                    
                        生成照片墙代码
                    
                    
                    
                        复制代码
                    
                
            
        
    

    
        // 存储照片的数组
        let photos = [];

        // DOM 元素
        const photoForm = document.getElementById('photoForm');
        const photoList = document.getElementById('photoList');
        const generateCodeBtn = document.getElementById('generateCode');
        const generatedCode = document.getElementById('generatedCode');
        const copyCodeBtn = document.getElementById('copyCode');

        // 添加照片表单提交处理
        photoForm.addEventListener('submit', function(e) {
            e.preventDefault();
            
            // 获取表单数据
            const newPhoto = {
                id: Date.now(), // 使用时间戳作为唯一ID
                src: document.getElementById('photoSrc').value,
                alt: document.getElementById('photoAlt').value,
                title: document.getElementById('photoTitle').value,
                date: document.getElementById('photoDate').value,
                location: document.getElementById('photoLocation').value,
                description: document.getElementById('photoDescription').value
            };
            
            // 添加到照片数组
            photos.push(newPhoto);
            
            // 更新照片列表显示
            updatePhotoList();
            
            // 重置表单
            photoForm.reset();
            
            alert('照片已添加！');
        });

        // 更新照片列表显示
        function updatePhotoList() {
            if (photos.length === 0) {
                photoList.innerHTML = '暂无照片';
                return;
            }
            
            photoList.innerHTML = photos.map(photo => `
                
                    
                    
                        ${photo.title}
                        ${photo.alt}
                        
                            
                                 删除
                            
                        
                    
                
            `).join('');
        }

        // 删除照片
        function removePhoto(id) {
            if (confirm('确定要删除这张照片吗？')) {
                photos = photos.filter(photo => photo.id !== id);
                updatePhotoList();
            }
        }

        // 生成照片墙代码
        generateCodeBtn.addEventListener('click', function() {
            if (photos.length === 0) {
                alert('请先添加一些照片！');
                return;
            }
            
            // 生成照片数据部分
            const photoDataCode = `const photos = [\n${photos.map((photo, index) => `    {
        id: ${index},
        src: "${photo.src}",
        alt: "${photo.alt}",
        title: "${photo.title}",
        date: "${photo.date}",
        location: "${photo.location}",
        description: "${photo.description}"
    }`).join(',\n')}\n];`;
            
            // 生成照片HTML部分
            const photoHTMLCode = photos.map((photo, index) => `            
            
                
                    
                    
                        
                            ${photo.title}
                            ${photo.alt}
                        
                    
                
            `).join('\n\n');
            
            // 组合完整代码
            const fullCode = `// 照片数据\n${photoDataCode}\n\n// 照片墙HTML\n${photoHTMLCode}`;
            
            // 显示生成的代码
            generatedCode.value = fullCode;
            generatedCode.classList.remove('hidden');
            copyCodeBtn.classList.remove('hidden');
        });

        // 复制代码到剪贴板
        copyCodeBtn.addEventListener('click', function() {
            generatedCode.select();
            document.execCommand('copy');
            alert('代码已复制到剪贴板！');
        });
    

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/Timer/index.html</url>
    <content><![CDATA[


    
    
    任务计时器与待办事项
    
    
    
    
   
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3B82F6',
                        secondary: '#10B981',
                        danger: '#EF4444',
                        dark: '#1E293B',
                        light: '#F8FAFC'
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                    },
                }
            },
            darkMode: 'class'
        }
    
 
    @layer utilities {
        .content-auto {
            content-visibility: auto;
        }
        .progress-animation {
            transition: width 1s linear;
        }
        .card-shadow {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .menu-shadow {
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        }
        .btn-hover {
            @apply transition-all duration-300 hover:scale-105 active:scale-95;
        }
        .bg-blur {
            backdrop-filter: blur(8px);
        }
        .todo-complete {
            @apply line-through text-gray-500 dark:text-gray-400;
        }
        #timer-container {
            @apply text-dark dark:text-light;
        }
        #timer-display {
            @apply text-dark dark:text-light;
        }
        #current-task-name {
            @apply text-dark dark:text-light;
        }
        .task-item-text {
            @apply text-dark dark:text-light;
        }
        .todo-item-text {
            @apply text-dark dark:text-light;
        }
        .panel-text {
            @apply text-dark dark:text-light;
        }
        /* 添加触摸设备支持 */
        .touch-device {
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }
    }



    
    
        
    

    
    
        
        
            
                任务管理器
            
            
                
                    
                
                
                    
                    
                
                
                    
                
                
                    
                
            
        

        
        
            
                设置
            
            
                
                
                    背景设置
                    
                        
                            
                            选择本地图片
                            
                        
                        
                            
                            恢复默认背景
                        
                    
                

                
                
                    音效设置
                    
                        
                            
                            启用互动音效
                        
                        
                            
                            
                        
                    
                

                
                
                    数据清理
                    
                        
                            
                                
                                清除计时任务
                            
                            
                        
                        
                            
                                
                                清除待办事项
                            
                            
                        
                        
                            
                                
                                清除背景缓存
                            
                            
                        
                        
                            
                                
                                清除设置数据
                            
                            
                        
                        
                            
                                
                                清除所有数据
                            
                            
                        
                    
                
            
        

        
        
            
            
                
                    
                        未选择任务
                        
                        
                            
                                
                            
                        
                        
                        00:00:00
                        
                        
                            
                                
                                开始
                            
                            
                                
                                暂停
                            
                            
                                
                                重置
                            
                        
                    
                
            
            
            
            
                
                    
                    
                        计时任务
                        待办事项
                    
                    
                    
                    
                        
                            任务管理
                            
                                
                            
                        
                        
                        
                            
                            
                                
                                暂无任务，点击添加按钮创建任务
                            
                        
                    
                    
                    
                    
                        
                            待办事项
                            
                                
                            
                        
                        
                        
                        
                            
                                
                                
                                    
                                
                            
                        
                        
                        
                            
                            
                                
                                暂无待办事项，添加你的第一个待办
                            
                        
                    
                
            
        
    

    
    
        
            
                添加新任务
                
                    
                
            
            
            
                
                
                
                    任务名称
                    
                
                
                
                    任务时长
                    
                        
                            
                            小时
                        
                        
                            
                            分钟
                        
                        
                            
                            秒
                        
                    
                
                
                
                    取消
                    保存
                
            
        
    

    
    
        
            确认操作
            您确定要执行此操作吗？
            
            
                取消
                确认
            
        
    

    
    
        
            
                操作说明
                
                    
                
            
            
            
                
                    计时任务
                    
                        点击"+"按钮添加新计时任务
                        可以设置任务的小时、分钟和秒数
                        点击任务项选择该任务进行计时
                        选择任务后，点击"开始"按钮启动计时器
                        计时器运行中可以点击"暂停"暂停计时，点击"重置"重新开始
                    
                
                
                
                    待办事项
                    
                        点击"待办事项"标签切换到待办事项面板
                        在输入框中输入内容并点击"+"或按回车添加待办事项
                        点击待办事项前的复选框标记为已完成
                        点击删除图标可以删除待办事项
                        已完成的待办事项会显示删除线
                    
                
                
                
                    设置功能
                    
                        点击菜单按钮（三条横线）打开设置面板
                        可以上传本地图片作为背景，也可以恢复默认背景
                        可以开启或关闭互动音效
                        可以清理各类数据（计时任务、待办事项、设置数据或全部数据）
                    
                
                
                
                    其他功能
                    
                        点击月亮/太阳图标切换深色/浅色模式
                        所有数据保存在本地，刷新页面不会丢失
                        计时器支持后台运行，即使不打开页面也会继续计时
                    
                
            
        
    

 
    
        
    
    
        
    
    
        
    
    
        
    
    
        
    

    
         
        // 添加触摸事件支持函数
        function addTouchSupport(element, callback) {
            let touchStartTime = 0;
            
            element.addEventListener('touchstart', (e) => {
                touchStartTime = Date.now();
                // 防止页面滚动
                if (element.classList.contains('no-scroll')) {
                    e.preventDefault();
                }
            }, { passive: false });
            
            element.addEventListener('touchend', (e) => {
                const touchDuration = Date.now() - touchStartTime;
                // 只有当触摸时间少于200ms才触发点击事件，避免与滚动冲突
                if (touchDuration < 200) {
                    callback(e);
                }
            });
            
            // 保持原有的点击事件
            element.addEventListener('click', callback);
        }
        // 音效控制
        const sounds = {
            start: document.getElementById('sound-start'),
            complete: document.getElementById('sound-complete'),
            click: document.getElementById('sound-click'),
            cancel: document.getElementById('sound-cancel'),
            todo: document.getElementById('sound-todo')
        };

        // 播放音效
        function playSound(type) {
            const soundEnabled = localStorage.getItem('soundEnabled') !== 'false';
            if (soundEnabled && sounds[type]) {
                // 先尝试播放音频，如果失败则在用户交互后重试
                const sound = sounds[type];
                sound.volume = 0.3;
                const playPromise = sound.play();
                
                if (playPromise !== undefined) {
                    playPromise.catch(error => {
                        console.log('音效播放失败:', error);
                        // 用户交互后重试
                        const tryPlayAfterUserInteraction = () => {
                            sound.play().catch(e => console.log('音效播放失败:', e));
                            document.removeEventListener('click', tryPlayAfterUserInteraction);
                        };
                        document.addEventListener('click', tryPlayAfterUserInteraction);
                    });
                }
            }
        }
        // 添加全局点击音效函数
        // function playClickSound() {
        //     playSound('click');
        // }

        // 待办事项管理
        class TodoManager {
            constructor() {
                this.todos = JSON.parse(localStorage.getItem('todos')) || [];
                this.init();
            }

            // 初始化
            init() {
                this.renderTodos();
                this.setupEventListeners();
            }

            // 渲染待办事项列表
            renderTodos() {
                const todoList = document.getElementById('todo-list');
                
                if (this.todos.length === 0) {
                    todoList.innerHTML = `
                        
                            
                            暂无待办事项，添加你的第一个待办
                        
                    `;
                    return;
                }
                
                // 按创建时间排序，新的在前面
                const sortedTodos = [...this.todos].sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
                
                todoList.innerHTML = '';
                sortedTodos.forEach(todo => {
                    const todoElement = document.createElement('div');
                    todoElement.className = `p-3 border rounded-lg border-gray-200 dark:border-gray-700 hover:bg-gray-50 dark:hover:bg-gray-700/50 transition-colors flex items-center gap-3`;
                    todoElement.innerHTML = `
                        
                            
                        
                        ${todo.content}
                        
                            
                        
                    `;
                    
                    todoList.appendChild(todoElement);
                });
                
                // 添加事件监听
                document.querySelectorAll('.todo-checkbox').forEach(checkbox => {
                    checkbox.addEventListener('change', (e) => {
                        const todoId = e.target.getAttribute('data-id');
                        this.toggleTodoStatus(todoId);
                    });
                });
                
                document.querySelectorAll('.delete-todo').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const todoId = e.target.closest('.delete-todo').getAttribute('data-id');
                        this.deleteTodo(todoId);
                    });
                });
            }

            // 添加待办事项
            addTodo(content) {
                if (!content.trim()) return; // 不添加空内容
                
                const todo = {
                    id: Date.now().toString(),
                    content: content.trim(),
                    completed: false,
                    createdAt: new Date().toISOString()
                };
                
                this.todos.push(todo);
                this.saveTodos();
                this.renderTodos();
                playSound('todo');
            }

            // 切换待办事项状态
            toggleTodoStatus(id) {
                const todoIndex = this.todos.findIndex(todo => todo.id === id);
                if (todoIndex !== -1) {
                    this.todos[todoIndex].completed = !this.todos[todoIndex].completed;
                    this.saveTodos();
                    this.renderTodos();
                    playSound('click');
                }
            }

            // 删除待办事项
            deleteTodo(id) {
                this.todos = this.todos.filter(todo => todo.id !== id);
                this.saveTodos();
                this.renderTodos();
                playSound('cancel');
            }

            // 清除所有待办事项
            clearAllTodos() {
                this.todos = [];
                this.saveTodos();
                this.renderTodos();
            }

            // 保存待办事项到本地存储
            saveTodos() {
                localStorage.setItem('todos', JSON.stringify(this.todos));
            }

            // 设置事件监听
            setupEventListeners() {
                // 添加待办事项表单提交
                document.getElementById('todo-form').addEventListener('submit', (e) => {
                    e.preventDefault();
                    const todoInput = document.getElementById('todo-input');
                    const content = todoInput.value;
                    
                    if (content.trim()) {
                        this.addTodo(content);
                        todoInput.value = '';
                    }
                });
                
                // 添加待办事项按钮
                document.getElementById('add-todo-btn').addEventListener('click', () => {
                    const todoInput = document.getElementById('todo-input');
                    const content = todoInput.value;
                    
                    if (content.trim()) {
                        this.addTodo(content);
                        todoInput.value = '';
                    } else {
                        todoInput.focus();
                    }
                });
            }
        }

        // 任务数据管理
        class TaskManager {
            constructor() {
                this.tasks = JSON.parse(localStorage.getItem('tasks')) || [];
                this.currentTaskId = localStorage.getItem('currentTaskId') || null;
                this.timerInterval = null;
                this.init();
            }

            // 初始化
            init() {
                this.renderTasks();
                this.loadCurrentTask();
                this.setupEventListeners();
            }

            // 渲染任务列表
            renderTasks() {
                const taskList = document.getElementById('task-list');
                
                if (this.tasks.length === 0) {
                    taskList.innerHTML = `
                        
                            
                            暂无任务，点击添加按钮创建任务
                        
                    `;
                    return;
                }
                
                taskList.innerHTML = '';
                this.tasks.forEach(task => {
                    const isActive = task.id === this.currentTaskId;
                    const progress = task.totalSeconds > 0 ? Math.max(0, Math.min(100, (1 - task.remainingTime / task.totalSeconds) * 100)) : 0;
                    
                    // 格式化显示时长
                    const hours = Math.floor(task.totalSeconds / 3600);
                    const minutes = Math.floor((task.totalSeconds % 3600) / 60);
                    const seconds = task.totalSeconds % 60;
                    let durationText = '';
                    if (hours > 0) durationText += `${hours}小时`;
                    if (minutes > 0) durationText += `${minutes}分钟`;
                    if (seconds > 0 || durationText === '') durationText += `${seconds}秒`;
                    
                    const taskElement = document.createElement('div');
                    taskElement.className = `p-3 border rounded-lg ${isActive ? 'border-primary bg-primary/10' : 'border-gray-200 dark:border-gray-700 hover:bg-gray-50 dark:hover:bg-gray-700/50'} transition-colors cursor-pointer`;
                    taskElement.innerHTML = `
                        
                            ${task.name}
                            
                                
                                    
                                
                                
                                    
                                
                            
                        
                        
                            ${durationText}
                        
                        
                            
                        
                    `;
                    
                    taskElement.addEventListener('click', (e) => {
                        // 防止点击编辑/删除按钮时触发任务选择
                        if (!e.target.closest('.edit-task') && !e.target.closest('.delete-task')) {
                            this.selectTask(task.id);
                        }
                    });
                    
                    taskList.appendChild(taskElement);
                });
                
                // 添加编辑和删除事件监听
                document.querySelectorAll('.edit-task').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const taskId = btn.getAttribute('data-id');
                        this.editTask(taskId);
                    });
                });
                
                document.querySelectorAll('.delete-task').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const taskId = btn.getAttribute('data-id');
                        this.confirmDeleteTask(taskId);
                    });
                });
            }

            // 添加任务
            addTask(name, hours, minutes, seconds) {
                const totalSeconds = hours * 3600 + minutes * 60 + seconds;
                if (totalSeconds  task.id === id);
                if (taskIndex !== -1) {
                    const totalSeconds = hours * 3600 + minutes * 60 + seconds;
                    if (totalSeconds  task.id !== id);
                this.saveTasks();
                this.renderTasks();
                playSound('cancel');
            }

            // 确认删除任务
            confirmDeleteTask(id) {
                const task = this.tasks.find(t => t.id === id);
                if (!task) return;
                
                const confirmTitle = document.getElementById('confirm-title');
                const confirmMessage = document.getElementById('confirm-message');
                
                confirmTitle.textContent = '删除任务';
                confirmMessage.textContent = `您确定要删除任务"${task.name}"吗？此操作不可撤销。`;
                
                showConfirmModal(() => {
                    this.deleteTask(id);
                });
                playSound('click');
            }

            // 选择任务
            selectTask(id) {
                if (this.currentTaskId === id) return;
                
                // 停止当前计时器
                this.stopTimer();
                
                this.currentTaskId = id;
                localStorage.setItem('currentTaskId', id);
                this.loadCurrentTask();
                this.renderTasks();
                playSound('click');
            }

            // 加载当前任务
            loadCurrentTask() {
                const taskNameEl = document.getElementById('current-task-name');
                const startBtn = document.getElementById('start-timer');
                
                if (!this.currentTaskId) {
                    taskNameEl.textContent = '未选择任务';
                    startBtn.disabled = true;
                    this.updateTimerDisplay();
                    return;
                }
                
                const task = this.tasks.find(task => task.id === this.currentTaskId);
                if (task) {
                    taskNameEl.textContent = task.name;
                    startBtn.disabled = false;
                    this.updateTimerDisplay();
                } else {
                    // 如果任务不存在，清除当前任务ID
                    this.currentTaskId = null;
                    localStorage.removeItem('currentTaskId');
                    taskNameEl.textContent = '未选择任务';
                    startBtn.disabled = true;
                }
            }

            // 开始计时器
            startTimer() {
                if (!this.currentTaskId || this.timerInterval) return;
                
                const task = this.tasks.find(task => task.id === this.currentTaskId);
                if (!task) return;
                
                // 如果剩余时间为0，重置
                if (task.remainingTime  {
                    const task = this.tasks.find(task => task.id === this.currentTaskId);
                    if (!task) {
                        this.stopTimer();
                        return;
                    }
                    
                    task.remainingTime--;
                    this.saveTasks();
                    this.updateTimerDisplay();
                    this.renderTasks();
                    
                    // 时间到
                    if (task.remainingTime  {
                                if (permission === 'granted') {
                                    new Notification('任务完成', {
                                        body: `任务"${task.name}"已完成！`,
                                        icon: 'https://cdn-icons-png.flaticon.com/512/1006/1006771.png'
                                    });
                                }
                            });
                        }
                    }
                }, 1000);
            }

            // 暂停计时器
            stopTimer() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                    
                    const startBtn = document.getElementById('start-timer');
                    const pauseBtn = document.getElementById('pause-timer');
                    
                    startBtn.disabled = false;
                    pauseBtn.disabled = true;
                }
            }

             // 重置计时器
            resetTimer() {
                if (!this.currentTaskId) return;
                
                const task = this.tasks.find(task => task.id === this.currentTaskId);
                if (task) {
                    const confirmTitle = document.getElementById('confirm-title');
                    const confirmMessage = document.getElementById('confirm-message');
                    
                    confirmTitle.textContent = '重置计时器';
                    confirmMessage.textContent = `您确定要重置当前任务"${task.name}"的计时器吗？这将丢失当前进度。`;
                    
                    showConfirmModal(() => {
                        task.remainingTime = task.totalSeconds;
                        this.saveTasks();
                        this.updateTimerDisplay();
                        this.renderTasks();
                        playSound('click');
                    });
                }
            }

            // 更新计时器显示
            updateTimerDisplay() {
                const timerDisplay = document.getElementById('timer-display');
                const timerProgress = document.getElementById('timer-progress');
                
                if (!this.currentTaskId) {
                    timerDisplay.textContent = '00:00:00';
                    timerProgress.style.width = '0%';
                    return;
                }
                
                const task = this.tasks.find(task => task.id === this.currentTaskId);
                if (!task) {
                    timerDisplay.textContent = '00:00:00';
                    timerProgress.style.width = '0%';
                    return;
                }
                
                // 计算时分秒
                const totalSeconds = Math.max(0, task.remainingTime);
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;
                
                // 格式化显示
                const formattedTime = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                timerDisplay.textContent = formattedTime;
                
                // 更新进度条
                const progress = task.totalSeconds > 0 ? Math.max(0, Math.min(100, (1 - totalSeconds / task.totalSeconds) * 100)) : 0;
                timerProgress.style.width = `${progress}%`;
            }

            // 保存任务到本地存储
            saveTasks() {
                localStorage.setItem('tasks', JSON.stringify(this.tasks));
            }

            // 编辑任务
            editTask(id) {
                const task = this.tasks.find(task => task.id === id);
                if (!task) return;
                
                // 转换总秒数为时分秒
                const hours = Math.floor(task.totalSeconds / 3600);
                const minutes = Math.floor((task.totalSeconds % 3600) / 60);
                const seconds = task.totalSeconds % 60;
                
                document.getElementById('task-id').value = task.id;
                document.getElementById('task-name').value = task.name;
                document.getElementById('task-hours').value = hours;
                document.getElementById('task-minutes').value = minutes;
                document.getElementById('task-seconds').value = seconds;
                document.getElementById('modal-title').textContent = '编辑任务';
                
                showTaskModal();
            }

            // 清除所有任务
            clearAllTasks() {
                this.stopTimer();
                this.tasks = [];
                this.currentTaskId = null;
                localStorage.removeItem('currentTaskId');
                this.saveTasks();
                this.renderTasks();
                this.loadCurrentTask();
            }

            // 设置事件监听
            setupEventListeners() {
                // 开始计时器
                addTouchSupport(document.getElementById('start-timer'), () => {
                    this.startTimer();
                });
                
                // 暂停计时器
                addTouchSupport(document.getElementById('pause-timer'), () => {
                    this.stopTimer();
                });
                
                // 重置计时器
                addTouchSupport(document.getElementById('reset-timer'), () => {
                    this.resetTimer();
                });
                
                // 添加任务按钮
                addTouchSupport(document.getElementById('add-task-btn'), () => {
                    document.getElementById('task-form').reset();
                    document.getElementById('task-id').value = '';
                    document.getElementById('task-hours').value = 0;
                    document.getElementById('task-minutes').value = 25;
                    document.getElementById('task-seconds').value = 0;
                    document.getElementById('modal-title').textContent = '添加新任务';
                    showTaskModal();
                    playSound('click');
                });
                
                // 任务表单提交
                document.getElementById('task-form').addEventListener('submit', (e) => {
                    e.preventDefault();
                    
                    const taskId = document.getElementById('task-id').value;
                    const taskName = document.getElementById('task-name').value;
                    const hours = parseInt(document.getElementById('task-hours').value) || 0;
                    const minutes = parseInt(document.getElementById('task-minutes').value) || 0;
                    const seconds = parseInt(document.getElementById('task-seconds').value) || 0;
                    
                    // 验证时间有效性
                    if (hours  {
                    if (document.hidden) {
                        // 页面不可见时记录当前时间
                        if (this.timerInterval) {
                            this.backgroundStartTime = Date.now();
                        }
                    } else {
                        // 页面可见时计算后台经过的时间
                        if (this.timerInterval && this.backgroundStartTime) {
                            const elapsedTime = Math.floor((Date.now() - this.backgroundStartTime) / 1000);
                            const task = this.tasks.find(task => task.id === this.currentTaskId);
                            
                            if (task) {
                                task.remainingTime = Math.max(0, task.remainingTime - elapsedTime);
                                this.saveTasks();
                                this.updateTimerDisplay();
                                this.renderTasks();
                                
                                // 如果时间到了，停止计时器
                                if (task.remainingTime  {
                hideConfirmModal();
                onConfirm();
                playSound('click');
            });
            
            newConfirmCancel.addEventListener('click', () => {
                hideConfirmModal();
                playSound('cancel');
            });
        }

        // 隐藏确认对话框
        function hideConfirmModal() {
            const modal = document.getElementById('confirm-modal');
            modal.classList.add('opacity-0', 'pointer-events-none');
            modal.querySelector('div').classList.remove('scale-100');
            modal.querySelector('div').classList.add('scale-95');
        }

        // 显示帮助对话框
        function showHelpModal() {
            const modal = document.getElementById('help-modal');
            modal.classList.remove('opacity-0', 'pointer-events-none');
            modal.querySelector('div').classList.remove('scale-95');
            modal.querySelector('div').classList.add('scale-100');
            playSound('click');
        }

        // 隐藏帮助对话框
        function hideHelpModal() {
            const modal = document.getElementById('help-modal');
            modal.classList.add('opacity-0', 'pointer-events-none');
            modal.querySelector('div').classList.remove('scale-100');
            modal.querySelector('div').classList.add('scale-95');
            playSound('click');
        }

           // 初始化标签切换
        function initTabs() {
            const tasksTab = document.getElementById('tasks-tab');
            const todosTab = document.getElementById('todos-tab');
            const tasksPanel = document.getElementById('tasks-panel');
            const todosPanel = document.getElementById('todos-panel');
            
            // 确保元素存在
            if (!tasksTab || !todosTab || !tasksPanel || !todosPanel) {
                console.warn('Tab elements not found');
                return;
            }
            
            // 移除可能存在的重复事件监听器
            const newTasksTab = tasksTab.cloneNode(true);
            tasksTab.parentNode.replaceChild(newTasksTab, tasksTab);
            
            const newTodosTab = todosTab.cloneNode(true);
            todosTab.parentNode.replaceChild(newTodosTab, todosTab);
            
            // 任务标签切换函数
            function switchToTasks(e) {
                e.preventDefault();
                
                // 激活任务标签
                newTasksTab.classList.add('text-primary', 'border-b-2', 'border-primary');
                newTasksTab.classList.remove('text-gray-500', 'dark:text-gray-400');
                
                // 取消待办标签
                newTodosTab.classList.remove('text-primary', 'border-b-2', 'border-primary');
                newTodosTab.classList.add('text-gray-500', 'dark:text-gray-400');
                
                // 显示任务面板，隐藏待办面板
                tasksPanel.classList.remove('hidden');
                todosPanel.classList.add('hidden');
                
                playSound('click');
            }
            
            // 待办标签切换函数
            function switchToTodos(e) {
                e.preventDefault();
                
                // 激活待办标签
                newTodosTab.classList.add('text-primary', 'border-b-2', 'border-primary');
                newTodosTab.classList.remove('text-gray-500', 'dark:text-gray-400');
                
                // 取消任务标签
                newTasksTab.classList.remove('text-primary', 'border-b-2', 'border-primary');
                newTasksTab.classList.add('text-gray-500', 'dark:text-gray-400');
                
                // 显示待办面板，隐藏任务面板
                todosPanel.classList.remove('hidden');
                tasksPanel.classList.add('hidden');
                
                // 聚焦到待办输入框
                const todoInput = document.getElementById('todo-input');
                if (todoInput) {
                    todoInput.focus();
                }
                
                playSound('click');
            }
            
            // 为标签添加事件监听器（支持鼠标和触摸）
            newTasksTab.addEventListener('click', switchToTasks);
            newTasksTab.addEventListener('touchstart', switchToTasks);
            
            newTodosTab.addEventListener('click', switchToTodos);
            newTodosTab.addEventListener('touchstart', switchToTodos);
        }
        


        // 初始化背景
        function initBackground() {
            const bgImageData = localStorage.getItem('bgImageData');
            const bgContainer = document.getElementById('background-container');
            const bgImage = document.getElementById('background-image');
            
            // 默认背景图片URL
            const defaultBgUrl = 'https://oss.itbaima.cn/hub/928/image-202509276f4i3vi5a.png';
            
            if (bgImageData) {
                bgImage.src = bgImageData;
                // 添加图片加载失败的处理
                bgImage.onerror = function() {
                    console.log('背景图片加载失败，使用默认背景');
                    bgImage.src = defaultBgUrl;
                    // 从localStorage中移除无效的背景图片数据
                    localStorage.removeItem('bgImageData');
                };
                bgContainer.style.display = 'block';
            } else {
                // 默认背景
                bgImage.src = defaultBgUrl;
                bgContainer.style.display = 'block';
            }
            
            // 上传背景图片
            document.getElementById('bg-image-upload').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file && file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        localStorage.setItem('bgImageData', event.target.result);
                        bgImage.src = event.target.result;
                        // 移除可能存在的错误处理
                        bgImage.onerror = null;
                        playSound('click');
                    };
                    reader.readAsDataURL(file);
                }
            });
            
            // 重置背景
            document.getElementById('reset-bg-btn').addEventListener('click', () => {
                localStorage.removeItem('bgImageData');
                bgImage.src = defaultBgUrl;
                // 移除可能存在的错误处理
                bgImage.onerror = null;
                playSound('click');
            });
        }

          // 初始化主题
        function initTheme() {
            // 检查用户偏好
            const isDarkMode = localStorage.getItem('darkMode') === 'true' || 
                              (localStorage.getItem('darkMode') === null && 
                               window.matchMedia('(prefers-color-scheme: dark)').matches);
            
            console.log('Initializing theme. Dark mode preference:', isDarkMode);
            
            // 根据偏好设置dark类
            if (isDarkMode) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
            
            // 更新主题切换按钮的图标状态
            updateThemeButtonIcons(isDarkMode);
            
            // 主题切换按钮
            const themeToggle = document.getElementById('theme-toggle');
            if (themeToggle) {
                // 清理所有可能的事件监听器
                const newThemeToggle = themeToggle.cloneNode(true);
                themeToggle.parentNode.replaceChild(newThemeToggle, themeToggle);
                
                // 添加新的事件监听器
                newThemeToggle.addEventListener('click', toggleTheme);
                newThemeToggle.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    toggleTheme();
                });
            } else {
                console.warn('Theme toggle button not found');
            }
        }

 // 主题切换处理函数
        function toggleTheme(e) {
            if (e) e.preventDefault();
            
            // 切换dark类
            const isDark = document.documentElement.classList.toggle('dark');
            localStorage.setItem('darkMode', isDark);
            
            // 强制更新按钮图标
            updateThemeButtonIcons(isDark);
            
            playSound('click');
            
            // 调试信息
            console.log('Theme toggled. Dark mode:', isDark);
        }
        
        // 更新主题按钮图标
        function updateThemeButtonIcons(isDark) {
            const themeToggle = document.getElementById('theme-toggle');
            if (themeToggle) {
                const moonIcon = themeToggle.querySelector('.fa-moon-o');
                const sunIcon = themeToggle.querySelector('.fa-sun-o');
                
                if (isDark) {
                    // 显示太阳图标（暗色模式）
                    if (moonIcon) moonIcon.classList.add('hidden');
                    if (sunIcon) sunIcon.classList.remove('hidden');
                } else {
                    // 显示月亮图标（亮色模式）
                    if (moonIcon) moonIcon.classList.remove('hidden');
                    if (sunIcon) sunIcon.classList.add('hidden');
                }
            }
        }


        // 初始化音效设置
        function initSoundSettings() {
            const soundToggle = document.getElementById('sound-toggle');
            const soundEnabled = localStorage.getItem('soundEnabled') !== 'false';
            
            soundToggle.checked = soundEnabled;
            
            soundToggle.addEventListener('change', () => {
                localStorage.setItem('soundEnabled', soundToggle.checked);
                playSound('click');
            });
        }
 // 初始化菜单
        function initMenu() {
            const menuBtn = document.getElementById('menu-btn');
            const menuPanel = document.getElementById('menu-panel');
            
            // 确保菜单按钮存在
            if (!menuBtn || !menuPanel) {
                console.warn('Menu button or panel not found');
                return;
            }
            
            // 移除可能存在的重复事件监听器
            menuBtn.removeEventListener('click', toggleMenuHandler);
            menuBtn.removeEventListener('touchstart', toggleMenuHandler);
            
            // 菜单切换函数
            function toggleMenuHandler(e) {
                e.preventDefault();
                e.stopPropagation();
                
                const isOpen = menuPanel.classList.contains('translate-x-0');
                
                if (isOpen) {
                    menuPanel.classList.remove('translate-x-0');
                    menuPanel.classList.add('translate-x-full');
                } else {
                    menuPanel.classList.remove('translate-x-full');
                    menuPanel.classList.add('translate-x-0');
                }
                
                playSound('click');
            }
            
            // 同时支持鼠标点击和触摸
            menuBtn.addEventListener('click', toggleMenuHandler);
            menuBtn.addEventListener('touchstart', toggleMenuHandler);
            
            // 点击外部关闭菜单
            function closeMenu(e) {
                // 检查菜单是否打开
                if (menuPanel.classList.contains('translate-x-0')) {
                    // 检查点击目标是否在菜单外部
                    if (!menuPanel.contains(e.target) && e.target !== menuBtn && !menuBtn.contains(e.target)) {
                        menuPanel.classList.remove('translate-x-0');
                        menuPanel.classList.add('translate-x-full');
                    }
                }
            }
            
            // 同时监听鼠标和触摸事件
            document.removeEventListener('click', closeMenu);
            document.removeEventListener('touchstart', closeMenu);
            document.addEventListener('click', closeMenu);
            document.addEventListener('touchstart', closeMenu, { passive: true });
        }
           

         // 初始化数据清理功能
        function initDataCleaning(taskManager, todoManager) {
            // 清除计时任务数据
            addTouchSupport(document.getElementById('clear-tasks-btn'), () => {
                const confirmTitle = document.getElementById('confirm-title');
                const confirmMessage = document.getElementById('confirm-message');
                
                confirmTitle.textContent = '清除计时任务';
                confirmMessage.textContent = '您确定要清除所有计时任务吗？此操作不可撤销。';
                
                showConfirmModal(() => {
                    taskManager.clearAllTasks();
                });
            });
            
            // 清除待办事项数据
            addTouchSupport(document.getElementById('clear-todos-btn'), () => {
                const confirmTitle = document.getElementById('confirm-title');
                const confirmMessage = document.getElementById('confirm-message');
                
                confirmTitle.textContent = '清除待办事项';
                confirmMessage.textContent = '您确定要清除所有待办事项吗？此操作不可撤销。';
                
                showConfirmModal(() => {
                    todoManager.clearAllTodos();
                });
            });
            
            // 清除背景缓存
            addTouchSupport(document.getElementById('clear-bg-cache-btn'), () => {
                const confirmTitle = document.getElementById('confirm-title');
                const confirmMessage = document.getElementById('confirm-message');
                
                confirmTitle.textContent = '清除背景缓存';
                confirmMessage.textContent = '您确定要清除背景图片缓存吗？将恢复为默认背景。';
                
                showConfirmModal(() => {
                    localStorage.removeItem('bgImageData');
                    // 重新初始化背景
                    initBackground();
                    playSound('click');
                });
            });
            
          // 清除设置数据
            addTouchSupport(document.getElementById('clear-settings-btn'), () => {
                const confirmTitle = document.getElementById('confirm-title');
                const confirmMessage = document.getElementById('confirm-message');
                
                confirmTitle.textContent = '清除设置数据';
                confirmMessage.textContent = '您确定要清除所有设置数据吗？包括主题、音效等设置将恢复为默认值。';
                
                showConfirmModal(() => {
                    localStorage.removeItem('darkMode');
                    localStorage.removeItem('soundEnabled');
                    localStorage.removeItem('bgImageData');
                    
                    // 重新初始化设置
                    setTimeout(() => {
                        initTheme();
                        initSoundSettings();
                        initBackground();
                    }, 0);
                    
                    // 关闭菜单
                    document.getElementById('menu-panel').classList.remove('translate-x-0');
                    document.getElementById('menu-panel').classList.add('translate-x-full');
                });
            });
            
             // 清除所有数据
            addTouchSupport(document.getElementById('clear-all-btn'), () => {
                const confirmTitle = document.getElementById('confirm-title');
                const confirmMessage = document.getElementById('confirm-message');
                
                confirmTitle.textContent = '清除所有数据';
                confirmMessage.textContent = '⚠️ 警告：您确定要清除所有数据吗？这将包括所有任务、待办事项和设置，且不可撤销！';
                
                showConfirmModal(() => {
                    // 清除所有本地存储
                    localStorage.clear();
                    
                    // 重新初始化应用
                    setTimeout(() => {
                        const taskManager = new TaskManager();
                        const todoManager = new TodoManager();
                        initTheme();
                        initSoundSettings();
                        initBackground();
                    }, 0);
                    
                    // 关闭菜单
                    document.getElementById('menu-panel').classList.remove('translate-x-0');
                    document.getElementById('menu-panel').classList.add('translate-x-full');
                });
            });
        }

        // 初始化帮助按钮
        function initHelpButton() {
            addTouchSupport(document.getElementById('help-btn'), showHelpModal);
            addTouchSupport(document.getElementById('close-help'), hideHelpModal);
        }

        // 初始化主页按钮
        function initHomeButton() {
            addTouchSupport(document.getElementById('Home'), () => {
                window.location.href = '/';
            });
        }

        // 请求通知权限
        function requestNotificationPermission() {
            if (Notification && Notification.permission !== 'granted' && Notification.permission !== 'denied') {
                Notification.requestPermission();
            }
        }

         // 初始化应用
        document.addEventListener('DOMContentLoaded', () => {
            initTheme();
            initBackground();
            initSoundSettings();
            initMenu();
            initHelpButton();
            initTabs();
            requestNotificationPermission();
            initHomeButton() 
            const taskManager = new TaskManager();
            const todoManager = new TodoManager();
            initDataCleaning(taskManager, todoManager);
            
            // 为所有按钮添加触摸支持
            const buttons = document.querySelectorAll('button');
            buttons.forEach(button => {
                button.classList.add('touch-device');
            });
        });
    


]]></content>
  </entry>
</search>
