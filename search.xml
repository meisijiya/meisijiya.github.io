<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>老江湖来咯</title>
    <url>/2025/09/16/%E8%80%81%E6%B1%9F%E6%B9%96%E6%9D%A5%E5%92%AF/</url>
    <content><![CDATA[老江湖来咯，哈哈哈哈哈哈哈哈哈哈
]]></content>
      <categories>
        <category>碎碎念</category>
      </categories>
      <tags>
        <tag>开心</tag>
      </tags>
  </entry>
  <entry>
    <title>02-短信登录-基于session方案</title>
    <url>/2025/09/20/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/02-%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95-%E5%9F%BA%E4%BA%8Esession%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[
前置：基于Session实现登录HttpSession 对象HttpSession_百度百科 Servlet Session 跟踪 | 菜鸟教程
Servlet提供了HttpSession接口，该接口中提供了一种跨多个页面请求或访问网站时识别用户以及存储有关用户信息的方式。Servlet 容器使用这个接口来创建一个 HTTP 客户端和 HTTP 服务器之间的 session 会话。会话持续一个指定的时间段，跨多个连接或页面请求。
@RestController结合了 @Controller 和 @ResponseBody。被被标记的类中，每个方法的返回值都会以JSON或XML的形式直接写入HTTP响应体中（@ResponseBody）。@Controller处理客户端发起的请求，并负责返回适当的视图（View）作为响应，搭配上@ResponseBody，使得以方法的返回值作为响应的主题内容，而不是解析为视图。
Spring中处理HTTP请求映射的注解@RestController@RequestMapping(&quot;/users&quot;)public class UserController&#123; @PostMapping(&quot;/create&quot;)/@GetMapping(&quot;list&quot;)public XXX  xxx&#123;        ...    &#125;&#125;

@RequestMapping
将web请求映射到具体方法上，标注在方法上。也可标注在类上，标注在类上时，表示类中所有响应请求的方法都是以该路径为父路径。
@PostMapping
组合注解。是@RequestMapping(method=RequestMethod.POST)的缩写。它用于处理HTTP POST请求的方法，只能标注在方法上。使用@PostMapping注解的方法将仅响应POST请求。
@GetMapping
组合注解。是@RequestMapping(method = RequestMethod.GET)的缩写。它用于处理HTTP GET请求的方法，也只能标注在方法上。使用@GetMapping注解的方法将仅响应GET请求。
SpringMVC接收前端传递的参数的注解@RequestParam 和 @RequestBody 都是从 HttpServletRequest request 中取参的，而 @PathVariable 是映射 URI 请求参数中的占位符到目标方法的参数中的.

@RequestParam  请求格式为：http://...?...=...&amp;...=...接收参数如下

defaultValue 如果本次请求没有携带这个参数，或者参数为空，那么就会启用默认值
name 绑定本次参数的名称，要跟URL上面的一样
required 这个参数不是必须的，如果为 true，不传参数会报错
value 跟name一样的作用，是name属性的一个别名


@RequestBody  两种接收方式： 一种是建立与 JSON 数据与之对应的实体，二是直接使用 Map&lt;String,Object&gt; 对象接收。使用需要满足如下条件：

Content-Type 为 application&#x2F;json，确保传递是 JSON 数据；
参数转化的配置必须统一，否则无法接收数据，比如 json、request 混用等


@PathVariable     请求格式：.../&#123;&#125;/&#123;&#125;同.../&#123;&#125;?...=... 接收参数如下

name 绑定参数的名称，默认不传递时，绑定为同名的形参。 赋值但名称不一致时则报错
value 跟name一样的作用，是name属性的一个别名
required 这个参数不是必须的，如果为 true，不传参数会报错

需要注意两点：

参数接收类型使用基本类型
如果@PathVariable标明参数名称，则参数名称必须和URL中参数名称一致



1、在 GET 请求中可以使用 @RequestParam，不能使用 @RequestBody，@RequestBody 是用来获取请求体中的参数，因为 GET 请求没有请求体，所以不能使用。
2.在post请求中

@RequestParam 适用于获取键值对形式的请求参数，来源包括 URL 查询字符串、application&#x2F;x-www-form-urlencoded 格式的请求体（表单默认格式）、multipart&#x2F;form-data 格式中的普通字段（非文件类型）。
@RequestBody 用于接收请求体中的完整数据，适用于非键值对形式的结构化数据（如 application&#x2F;json、application&#x2F;xml 等），通过消息转换器将请求体内容解析为目标 Java 对象。
特殊场景：multipart&#x2F;form-data 格式中的文件上传需用 @RequestPart；application&#x2F;x-www-form-urlencoded 格式为键值对结构，不适合用 @RequestBody 接收（会得到原始字符串，非推荐用法）。

3、一个方法中，可以同时使用多个 @RequestParam ，但是只能使用一个 @RequestBody，否则会报错。
4、@PathVariable 起到的作用就是 URI 请求参数中的占位符到目标方法参数的映射。
5、前端请求的  Content-Type ，默认值为 application/x-www-form-urlencoded，在这种格式下，后端直接使用 @RequestParam 就可以直接获取指定的参数，但是一旦前端传递的是 JSON 数据，也就是 Content-Type 的值为 application/json，那么使用 @RequestParam 是取不到值的，不但取不到值还报错。
Mybatis-plus优秀的 ORM 框架，致力于简化和提高 Java 应用程序对数据库访问的效率。
@Transactional只能应用到接口方法、类、还有public方法上。一般在@service标记的类上添加，可以将整个service类纳入Spring事务管理，采用统一的事务管理方式。
常用属性总结：

propagation：控制事务传播行为（如是否复用父事务），默认REQUIRED；
isolation：设置事务隔离级别（解决并发问题），默认用数据库默认值；
rollbackFor&#x2F;noRollbackFor：指定需要 &#x2F; 不需要回滚的异常类型；
readOnly：标记只读事务（优化查询性能），默认false；
timeout：设置事务超时时间（防止长事务，单位秒），默认无限制。

BaseMapper、IService和ServiceImpl在典型的三层架构中：

Controller 层：接收请求、返回结果
Service 层：业务逻辑编排
DAO 层 (Mapper)：直接操作数据库

MyBatis-Plus 提供了 BaseMapper 简化了 DAO 层的 CRUD，而在 Service 层，通常需要编写一堆相似的增删改查逻辑。为此，MyBatis-Plus 提供了 IService 接口 + ServiceImpl 实现类，将通用逻辑抽象出来。
IService&lt;T&gt;   ←——  通用 Service 接口（定义通用方法）   ↑ServiceImpl&lt;M extends BaseMapper&lt;T&gt;, T&gt;   ←——  通用 Service 实现类   ↑自定义 Service 实现类（继承 ServiceImpl）

常见问题
必须继承 ServiceImpl 吗？


不是必须。你也可以只用 BaseMapper，在 Controller 里直接调用。但这样会让业务层缺失，代码耦合度较高，推荐通过 ServiceImpl 来隔离业务逻辑与持久化。


如果要写自定义方法怎么办？


直接在 Service 接口和实现类中新增即可


与 Mapper 的关系？


Mapper：最贴近数据库，负责 SQL 层
ServiceImpl：封装 Mapper，并为业务提供统一接口

最佳实践：
接口分离：定义 Service 接口，避免直接在 Controller 注入 ServiceImpl
扩展业务逻辑：在继承的 ServiceImpl 上增加自己的方法，不要随意修改通用方法
批量操作：使用 saveBatch、updateBatchById 提升性能
LambdaQueryWrapper：结合 ServiceImpl 的查询方法，写法更简洁安全

BaseMapper主要作用是定义 DAO 层的数据库操作方法，例如数据的增删改查等。
通过智能的SQL生成机制，只要继承并指定对应的实体类，即可直接使用这些通用方法，无需手动编写 SQL 语句，从而减少了代码量和重复劳动。
// 定义一个继承 BaseMapper 的自定义 Mapper 接口public interface XXXMapper extends BaseMapper&lt;xxx&gt; &#123;    // 无需手写SQL，Mybatis-Plus 根据命名规范自动生成SQL&#125;

IService将常见的业务操作抽象化，包括保存、删除、更新、查询等。通过继承 IService 接口，并指定对应的实体类，即可直接使用这些通用方法，无需手动编写业务逻辑代码，使得代码更加简洁和易于维护。
封装的方法分为七类：save、remove、update、get、list、count、page（分页查询）
// 定义一个继承 IService 的自定义 Service 接口public interface XXXService extends IService&lt;xxx&gt; &#123;    // 定义常用的业务逻辑方法&#125;

ServiceImpl是 IService 接口的默认实现。是针对业务逻辑层的实现，并调用 BaseMapper 来操作数据库。还额外赋予了一些更加高级的查询操作，如 lambdaQuery、page 等
//源码public class ServiceImpl&lt;M extends BaseMapper&lt;T&gt;, T&gt; implements IService&lt;T&gt; &#123;    @Autowired    protected M baseMapper;        //...方法&#125;

常见方法如下：

新增


save(T entity)
saveBatch(Collection entityList)
saveOrUpdate(T entity)


删除


removeById(Serializable id)
removeByIds(Collection&lt;? extends Serializable&gt; idList)
remove(Wrapper queryWrapper)


修改


updateById(T entity)
update(T entity, Wrapper updateWrapper)
updateBatchById(Collection entityList)


查询


getById(Serializable id)
listByIds(Collection&lt;? extends Serializable&gt; idList)
list(Wrapper queryWrapper)
page(Page page, Wrapper queryWrapper)
getOne(Wrapper queryWrapper)


统计与判断


count()
exists(Wrapper queryWrapper)

ServiceImpl 对事务管理提供了支持。通过 @Transactional 注解，能够轻松地实现事务的控制。
实践代码：
// 在业务逻辑实现中继承 ServiceImpl，轻松构建业务方法@Service@Transactionalpublic class XXXServiceImpl extends ServiceImpl&lt;M, T&gt; implements XXXService &#123;    ...&#125;

传入的参数为 M 和 T：

M：Mapper 接口类型
T：对应实体类的类型

Wrapper
不直接关联 Mapper 接口，需手动传递给 Mapper 方法执行查询。
需调用 Mapper 方法（如 selectList(wrapper)）
分两步：先构建条件，再调用 Mapper
运用于复杂逻辑（如条件复用、动态判断）

QueryWrapper查询构造器，通过链式调用，灵活直观地进行复杂SQL查询，而无需手动编写SQL语句。不直接关联 Mapper 接口，需手动传递给 Mapper 方法执行查询。
操作流程：

创建QueryWrapper实例QueryWrapper&lt;实体类（代表数据库中的一张表）&gt; wrapper = new QueryWrapper&lt;&gt;()
添加查询条件（方法），支持链式调用
eq：等于  ne：不等于
gt：大于  ge：大于等于
lt：小于  le：小于等于
(not)like(left/right)：模糊匹配 (not)between 区间
(not)in：(不)在某个集合中
and   or
nested - 嵌套条件
orderby 排序
select
last在 SQL 末尾追加自定义片段  apply添加动态SQL片段


执行查询构造好的QueryWrapper，通过传递给Mybatis-Plus的Mapper接口方法来执行查询。返回值  x = xxxMapper.xxx方法(wrapper)

QueryWrapper与其他Wrapper的区别
QueryWrapper：专注于构建 SELECT 查询的条件。

UpdateWrapper：用于构建 UPDATE 语句，支持条件和 SET 子句。（set）

LambdaQueryWrapper：QueryWrapper 的 Lambda 版本，使用 Lambda 表达式指定字段。
// 效果同QueryWrapper示例，但用Lambda引用字段LambdaQueryWrapper&lt;User&gt; lambdaQuery = new LambdaQueryWrapper&lt;&gt;();lambdaQuery.gt(User::getAge, 18)  // 用Lambda表达式引用字段，编译期检查           .like(User::getUsername, &quot;张&quot;);List&lt;User&gt; userList = userMapper.selectList(lambdaQuery);

LambdaUpdateWrapper：UpdateWrapper 的 Lambda 版本。
// 效果同UpdateWrapper示例，用Lambda引用字段LambdaUpdateWrapper&lt;User&gt; lambdaUpdate = new LambdaUpdateWrapper&lt;&gt;();lambdaUpdate.set(User::getAge, 20)            .set(User::getStatus, 1)            .eq(User::getId, 1)            .eq(User::getUsername, &quot;张三&quot;);userMapper.update(null, lambdaUpdate);

ChainWrapper
内置 Mapper，创建时绑定
自带执行方法（如 list()、update()）
链式调用，一步完成条件 + 执行
简单查询 &#x2F; 更新，追求代码简洁

QueryChainWrapperquery() 方法是 BaseMapper 接口提供的一个默认方法

快速创建 QueryChainWrapper 实例（自动绑定当前 Mapper）；
支持直接链式调用查询条件方法（eq、like 等）和执行方法（list、one 等）；
让代码更简洁，减少手动创建包装器的模板代码。

// 简化方式：通过 mapper.query() 获取 QueryChainWrapperList&lt;User&gt; users = userMapper.query()  // 直接获取链式查询包装器    .eq(&quot;status&quot;, 1)    .list();

query() 方法与 Service 层的结合
在 Service 实现类中（通常继承 ServiceImpl&lt;M extends BaseMapper&lt;T&gt;, T&gt;），调用 BaseMapper 提供的 query() 方法，获取 QueryChainWrapper&lt;User&gt; 实例，进一步简化代码。
User user=query().eq(&quot;phone&quot;,phone).one();

若不用链式查询，等价代码如下
QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();queryWrapper.eq(&quot;phone&quot;, phone);User user = userMapper.selectOne(queryWrapper); // 手动调用 Mapper 方法

QueryChainWrapper：

作用：用于构建查询条件（WHERE、ORDER BY 等），并直接执行查询操作（如查询列表、单条数据、数量等）。

核心方法：

条件方法：eq()（等于）、like()（模糊查询）、orderBy()（排序）等（与 QueryWrapper 一致）。
执行方法：list()（查询列表）、one()（查询单条）、count()（查询数量）等。


// 常规方法，链式查询：查询name为&quot;张三&quot;且age≥18的用户列表
List&lt;User&gt; users = new QueryChainWrapper&lt;&gt;(userMapper)
    .eq(&quot;name&quot;, &quot;张三&quot;)
    .ge(&quot;age&quot;, 18)
    .orderByDesc(&quot;create_time&quot;)
    .list(); // 直接执行查询
#### UpdateChainWrapper- **作用**：用于构建更新条件（`SET` 字段值 + `WHERE` 条件），并直接执行更新操作。- 核心方法：  - 字段方法：`set()`（设置更新字段）、`setSql()`（直接写 SQL 片段）等。  - 条件方法：`eq()`、`in()` 等（与 `UpdateWrapper` 一致）。  - 执行方法：`update()`（执行更新）。- ```java  // 链式更新：将name为&quot;张三&quot;的用户age改为20  boolean success = new UpdateChainWrapper&lt;&gt;(userMapper)      .set(&quot;age&quot;, 20)      .eq(&quot;name&quot;, &quot;张三&quot;)      .update(); // 直接执行更新



ThreadLocal在 Tomcat 处理 HTTP 请求的流程中，每个用户请求都会由 Tomcat 线程池中的「独立线程」处理（线程从池内取出 → 处理请求 → 用完回收）。由于不同用户的请求由不同线程执行，且线程会经过 Controller、Service、DAO 等多层组件调用，此时需要一种机制，让 “当前请求的专属数据” 能在线程内的各组件间共享，同时又不与其他线程的请求数据冲突 —— 这正是 ThreadLocal 的核心价值。
ThreadLocal的作用与适配性：
ThreadLocal 的原理是 为每个线程维护一份「独立的变量副本」：
当 Tomcat 的工作线程开始处理请求时，会把「当前请求的上下文数据」（比如用户身份信息、事务管理器、自定义的请求作用域数据等）存入 ThreadLocal；
之后，在该线程执行过程中（从 Controller 接收参数，到 Service 处理业务，再到 DAO 操作数据库），所有组件都能从 ThreadLocal 中获取 “当前请求专属” 的数据，且不会与其他线程（其他用户的请求）的数据产生冲突。
总结：
因为 “每个用户请求对应独立线程” 的特性，ThreadLocal 能让每个线程只操作自己的那份数据，既保证了 “同一请求内多组件共享数据”，又天然实现了 “线程隔离”，完美适配 Web 应用中 “请求 - 线程 - 多组件协作” 的场景。
拦截器HandlerInterceptorSpring MVC 的 HandlerInterceptor 是贯彻 AOP 思想、用于拦截 Spring MVC 请求的核心组件，仅作用于 Spring MVC 处理的请求，生命周期由 Spring 管理，可在请求到 Controller 前、Controller 执行后、视图渲染完成后三个阶段插入自定义逻辑，实现权限验证、日志记录、资源清理等横切需求。
其核心有 3 个方法：

preHandle（正序执行）：请求前置处理，返回true则继续请求，false则中断，常用于登录校验；
postHandle（逆序执行）：Controller 执行后、视图渲染前处理，可修改ModelAndView，如加全局数据；
afterCompletion（逆序执行）：请求全流程结束后执行（无论成败），用于资源清理，如关连接、清ThreadLocal。

拦截器通过HandlerExecutionChain封装成链，执行规则为 “preHandle 正序、后两个方法逆序”；与 Servlet Filter 相比，它对 Spring MVC 请求控制更精细，配置依赖WebMvcConfigurer，还可通过Ordered&#x2F;@Order排序、MappedInterceptor动态匹配路径，优化时需避免耗时操作、控制作用范围。
要使拦截器生效，需要配置拦截器需要在实现了WebMvcConfigurer的配置类（@Configuration），编写addInterceptors(InterceptroRegistry registry)方法，使用注册器registry通过addInterceptor方法来配置拦截路径。
import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;// 拦截器配置类（@Configuration 标记为Spring配置类）@Configurationpublic class MvcInterceptorConfig implements WebMvcConfigurer &#123;    /**     * 注册拦截器，并配置拦截/排除路径     */    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        // 1. 注册自定义的LoginInterceptor        registry.addInterceptor(new LoginInterceptor())                // 2. 配置「需要拦截」的路径（Ant风格，/** 表示所有请求）                .addPathPatterns(&quot;/**&quot;)                 // 3. 配置「不需要拦截」的路径（排除登录、静态资源等）                .excludePathPatterns(                        &quot;/login&quot;,          // 登录接口（未登录时需访问，不拦截）                        &quot;/register&quot;,       // 注册接口（同理不拦截）                        &quot;/static/**&quot;,      // 静态资源（CSS、JS、图片等，不拦截）                        &quot;/error&quot;           // 错误页面（如404、500，不拦截）                );    &#125;&#125;

若需注册多个拦截器（如 “登录拦截器”+“日志拦截器”），可在 addInterceptors 中多次调用
使用Hutool工具类进行对象属性拷贝Hutool 提供了 BeanUtil 和 CollUtil 工具类，可简洁实现实体类对象及 List 集合的属性拷贝（相同属性值复制），无需手动编写 set&#x2F;get 代码。
以下是具体实现方式：

实体类对象拷贝（单个对象）
使用 BeanUtil.copyProperties 方法，自动复制两个对象间名称和类型相同的属性。

List 集合拷贝（批量对象）
通过 BeanUtil.copyProperties 结合流处理，批量拷贝集合中所有对象的属性。


拷贝规则：

仅复制名称和类型均相同的属性（类型需兼容，如 int 与 Integer 可互转）。
目标对象中独有的属性（如 UserDTO 的 extra）会被忽略，源对象中独有的属性也不会影响目标对象。

注意事项：

若属性名不同，可通过 BeanUtil.copyProperties 的重载方法自定义映射规则（如 CopyOptions）。

隐藏用户信息前后端数据交互的标准最佳实践：
通过DTO对象类进行前后端传递数据。entity类负责跟数据库交换数据。

Entity 类（与数据库交互，含敏感字段）
DTO 类（前后端传输，隐藏敏感信息）

代码实现发送验证码IUserService声明，UserServiceImpl实现
@Overridepublic Result sendCode(String phone, HttpSession session) &#123;    // 1.校验手机号    if (RegexUtils.isPhoneInvalid(phone)) &#123;        // 2.如果不符合，返回错误信息        return Result.fail(&quot;手机号格式错误！&quot;);    &#125;    // 3.符合，生成验证码    String code = RandomUtil.randomNumbers(6);    // 4.保存验证码到 session    session.setAttribute(&quot;code&quot;,code);    // 5.发送验证码    log.debug(&quot;发送短信验证码成功，验证码：&#123;&#125;&quot;, code);    // 返回ok    return Result.ok();&#125;

登录 @Override   public Result login(LoginFormDTO loginForm, HttpSession session) &#123;       // 1.校验手机号       String phone = loginForm.getPhone();       if (RegexUtils.isPhoneInvalid(phone)) &#123;           // 2.如果不符合，返回错误信息           return Result.fail(&quot;手机号格式错误！&quot;);       &#125;       // 3.校验验证码       Object cacheCode = session.getAttribute(&quot;code&quot;);       String code = loginForm.getCode();       if(cacheCode == null || !cacheCode.toString().equals(code))&#123;           //3.不一致，报错           return Result.fail(&quot;验证码错误&quot;);       &#125;       // 4.验证码一致，查询用户       User user=query().eq(&quot;phone&quot;,phone).one();       if(user == null)&#123;           // 5.用户不存在，创建           user =  createUserWithPhone(phone);       &#125;       //6.保护用户信息到session       session.setAttribute(&quot;user&quot;,user);       //7.返回ok       return Result.ok();   &#125;   private User createUserWithPhone(String phone) &#123;       User user = new User();       user.setPhone(phone);       return user;&#125;

登录校验拦截器拦截器代码，在utils包下创建
public class LoginInterceptor implements HandlerInterceptor &#123;    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;    &#125;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        //1.获取session        HttpSession session = request.getSession();        //2.获取session中的用户        Object user = session.getAttribute(&quot;user&quot;);        //3.判断用户是否存在        if(user != null) &#123;            //4.不存在就拦截，返回401状态码            response.setStatus(401);            return false;        &#125;        //5.存在,保存用户信息到ThreadLocal        UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class);        UserHolder.saveUser(userDTO);        //6.放行        return true;    &#125;&#125;

添加拦截器，配置类
public class MvcConfig implements WebMvcConfigurer &#123;    @Resource    private StringRedisTemplate stringRedisTemplate;    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        // 登录拦截器        registry.addInterceptor(new LoginInterceptor())                .excludePathPatterns(                        &quot;/shop/**&quot;,                        &quot;/voucher/**&quot;,                        &quot;/shop-type/**&quot;,                        &quot;/upload/**&quot;,                        &quot;/blog/hot&quot;,                        &quot;/user/code&quot;,                        &quot;/user/login&quot;                ).order(1);    &#125;&#125;

]]></content>
      <categories>
        <category>黑马点评笔记</category>
      </categories>
      <tags>
        <tag>session</tag>
        <tag>Hutool工具</tag>
        <tag>Mybatis-plus</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>01-总览</title>
    <url>/2025/09/20/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/01-%E6%80%BB%E8%A7%88/</url>
    <content><![CDATA[
黑马点评的收获概览极大的提高基础编程能力
Java8新特性
stream流的用法
函数式编程


深化mybatis plus
mp的高级用法，sql与api穿插解决问题
mp框架的一些小问题（比如，list查id的时候，是乱序的），能够如何去优化


模型转换概念（pojo、entity、vo、dto、requires）
线程池的实际使用
java阻塞队列初识

深度学习redis所有数据结构用法，深度理解缓存概念
8种数据结构，每种都匹配了实际的开发需求功能
对于缓存的知识讲解全面，cache aside等业界常用缓存方案
深度练习springboot中的redis的api

对具体业务理解能力的提高提高编程效率，更加高效的使用工具类，编写工具类
使用hutool工具包
结合泛型高级应用与函数式编程，手搓适合自己的工具类

面试能力的提升
能够掌握分布式锁、缓存击穿、缓存穿透、缓存雪崩等面试必考点
redisson源码解读，掌握redis的高级用法，看门狗机制，muti-lock机制等面试加分亮点

进阶技能拓展
redis秒杀场景教学
原子性的深度理解与应用
多种秒杀方案讲解，针对单体和微服务并发情况展开。


学会lua脚本的基本编写，了解lua脚本的使用场景。lua脚本就是做原子性的业务，也可以做在nginx服务器的脚本去调redis。
学会nginx轻量服务器的搭建以及各种使用场景
多级缓存的的搭建，本地缓存caffine的使用
feed流的两种模式

希望我能够做到
提升业务熟练度⬆
提升写sql的熟练度⬆

如何转化到自己的简历上
更换内容
技术点嵌套
缓存解决方案
秒杀-分布式锁
多级缓存



]]></content>
      <categories>
        <category>黑马点评笔记</category>
      </categories>
      <tags>
        <tag>学习大纲</tag>
      </tags>
  </entry>
  <entry>
    <title>00-idea操作git</title>
    <url>/2025/09/20/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/00-idea%E6%93%8D%E4%BD%9Cgit/</url>
    <content><![CDATA[
常见指令
IDEA中的git菜单选项详解
以下是对该 Git 相关菜单中各选项的详细解释（以常见 IDE 如 IntelliJ IDEA 的 Git 集成为例）：
1. 提交 (I)…（Ctrl+K）
功能：将本地工作区的修改提交到本地 Git 仓库。
操作：点击后弹出 “提交” 窗口，可选择要提交的文件、填写提交信息（如功能更新、问题修复的描述），最终在本地仓库生成一条新的提交记录（但不影响远程仓库）。

2. 推送…（Ctrl+Shift+K）
功能：将本地仓库的提交推送到远程仓库（如 GitHub、GitLab 等）。
场景：本地多次commit后，通过 “推送” 一次性把这些提交同步到远程，远程仓库会完整保留本地的多条提交记录（每条提交的哈希、信息、时间都会记录）。

3. 更新项目 (U)…（Ctrl+T）
功能：拉取远程仓库的最新更新，并自动合并到本地当前分支（相当于 “拉取 + 合并” 的组合操作）。
作用：确保本地代码与远程仓库的最新状态同步，常用于多人协作时更新他人的提交。

4. 拉取…
功能：从远程仓库拉取最新提交到本地仓库，但不自动合并到当前工作分支。
特点：仅更新本地的 “远程分支引用”，如需合并到当前工作分支，需后续手动执行 “合并” 操作（或用 “更新项目”）。

5. 提取
功能：类似git fetch，从远程仓库获取提交对象、分支信息等，但完全不影响本地工作分支（更偏向 “底层数据同步”，一般用于精细控制或调试，普通开发更常用 “拉取” 或 “更新项目”）。

6. 合并…
功能：将指定分支的提交合并到当前分支。
场景：比如在feature分支开发后，要把master分支的最新代码合并进来，或把feature分支合并到master准备发布。合并时会自动处理（或提示解决）冲突。

7. 变基…
功能：执行git rebase操作，将当前分支的提交 “变基” 到目标分支的最新提交上，使提交历史更线性整洁。
对比 “合并”：合并会产生 “合并提交”，而变基会重写提交历史（把当前分支的提交 “接” 在目标分支最新提交之后），更适合多人协作时保持分支历史清晰。
git多次提交到本地仓库,然后一次性提交到远程仓库,远程仓库会记录到多次提交要消除历史提交，只保留合并后的单一提交记录，可以使用变基

8. 分支 (B)…（Ctrl+Shift+）
功能：分支的综合管理，包括查看所有分支、切换分支、删除分支等。
操作：点击后可浏览本地 &#x2F; 远程分支列表，快速切换工作分支（如从master切到feature/login）。

9. 新建分支…
功能：基于当前分支或指定提交，创建一个新的分支。
场景：开发新功能时，从master分支新建feature/xxx分支，实现 “分支隔离开发”。

10. 新建标记…
功能：创建 Git标签（Tag），用于标记重要版本（如发布版本v1.0.0）。
作用：标签是 “不可变的提交引用”，方便后续快速定位到某个版本（如回退到发布版本、生成版本包）。

11. 重置 HEAD…
功能：重置HEAD指针的位置（HEAD是当前分支的 “当前提交” 引用），用于撤销提交。
选项：
--soft：保留修改到 “暂存区”（可重新提交）；
--mixed（默认）：保留修改到 “工作区”（未暂存，需重新添加）；
--hard：直接丢弃修改（慎用，会丢失未提交的变更）。



12. 显示 Git 日志
功能：查看当前分支的提交历史，包括每个提交的哈希值、作者、时间、提交信息等。
作用：用于追溯代码变更记录（如谁在什么时候改了哪部分代码）。

13. 补丁文件
功能：生成 &#x2F; 应用 ** 补丁（Patch）** 文件，将提交的变更导出为文本文件，或从补丁文件导入变更。
场景：无直接远程连接时，通过补丁分享代码变更（如给第三方提交代码时，先导出补丁再发送）。

14. 未提交的更改 (U)
功能：查看工作区中尚未提交的修改（包括新增、修改、删除的文件）。
作用：提交前确认变更内容，避免误提交无关文件。

15. 选定目录
功能：对指定目录执行 Git 操作（如仅提交该目录下的修改、查看该目录的版本历史）。
场景：大型项目中，聚焦某个模块的变更管理。

16. GitHub
功能：与GitHub 平台集成的操作（如登录 GitHub 账号、创建远程仓库、将本地仓库关联到 GitHub 等）。
作用：简化与 GitHub 的交互（如一键 “推送到 GitHub”）。

17. 管理远程…
功能：配置远程仓库的信息（如添加、删除、修改远程仓库的 URL）。
示例：本地仓库关联远程时，可通过这里设置origin的地址为https://github.com/xxx/repo.git。

18. 克隆…
功能：从远程仓库克隆一个完整的仓库到本地（包括所有分支、提交历史）。
场景：首次获取他人 &#x2F; 团队的项目时使用。

19. VCS 操作弹出窗口…（Alt+）
功能：打开综合 VCS 操作面板，聚合更多 Git（或其他版本控制）的精细操作，方便快速访问。

这些选项覆盖了 Git“本地提交、远程同步、分支管理、版本追溯” 等核心流程，帮助开发者在 IDE 中高效完成版本控制。
Git 提交历史右键菜单
以下是对该 Git 提交历史右键菜单各选项的详细解释（基于 IDE 如 IntelliJ IDEA 的 Git 集成）：
1. 复制修订号（Ctrl+Alt+Shift+C）
作用：复制当前提交的哈希值（Git 提交的唯一标识，形如 a1b2c3...）。
场景：需在命令行引用该提交（如 git show &lt;哈希&gt;）、分享特定提交时，快速获取标识。

2. 创建补丁…
作用：将当前提交的代码变更导出为「补丁文件（.patch）」。
场景：无直接 Git 远程连接时，通过补丁文件传递代码变更（他人可执行 git apply &lt;补丁文件&gt; 应用变更）。

3. 优选（对应 git cherry-pick）
作用：将当前提交（不属于当前分支）复制到当前分支，生成新提交。
场景：把其他分支的 “单个有用提交”（如feature分支的某个修复）合并到当前分支，无需拉取整个分支。

4. 签出修订
作用：将工作区 &#x2F; 暂存区切换到当前提交的代码状态（即 “检出” 该提交）。
场景：查看历史版本代码，或基于旧提交新建分支（如 git checkout &lt;哈希&gt; -b new-branch）。

5. 在修订中显示仓库
作用：以当前提交为视角，展示仓库整体的文件结构与内容。
场景：查看该提交时仓库的完整状态（哪些文件被改 &#x2F; 增 &#x2F; 删）。

6. 与本地比较
作用：对比当前提交的代码与本地工作区的代码差异。
场景：确认本地变更与历史提交是否冲突，或查看本地对历史版本的修改。

7. 将当前分支重置到此处…
作用：把当前分支的HEAD 指针移动到当前提交，并可选择重置模式（–soft&#x2F;–mixed&#x2F;–hard
）：

--soft：仅移动HEAD，变更保留在暂存区；
--mixed（默认）：移动HEAD，暂存区重置，变更保留在工作区；
--hard：移动HEAD，暂存区 &#x2F; 工作区均重置（丢弃本地未提交变更，慎用）。


场景：回退分支到历史提交，按需保留 &#x2F; 丢弃后续变更。


8. 还原提交（对应 git revert）
作用：创建新提交，抵消当前提交的变更（不删除历史提交，而是 “反向修正”）。
场景：已推送到远程的提交需回退时，避免改写历史（不影响协作）。

9. 撤销提交…（对应 git reset 交互）
作用：回退当前分支到该提交之前，并交互选择如何处理后续变更（类似 “重置分支” 的友好界面）。

10. 编辑提交消息…（F2）
作用：修改当前提交的提交信息（commit message）。
场景：提交后发现消息写错，若未推送到远程可直接修改；已推送则需强制推送（慎用于协作分支）。

11. Fixup…（对应 git rebase -i 的 fixup）
作用：将当前提交合并到前一个提交，并丢弃当前提交的消息。
场景：修复前一个提交的小问题，无需保留 “修复提交” 的独立记录，让历史更整洁。

12. 压缩到…
作用：将当前提交合并到指定提交，可选择是否保留提交消息（比Fixup更灵活的合并）。

13. 删除提交
作用：从提交历史中移除当前提交（通常通过「交互式变基」实现）。
注意：若提交已推送到远程，删除后需强制推送，可能影响协作。

14. 从这里进行交互式变基…（对应 git rebase -i）
作用：启动交互式变基，可对 “当前提交之后的所有提交” 进行编辑（合并、拆分、改消息等）。
场景：整理提交历史（如把多个小提交合并为一个有意义的大提交），让分支历史更线性。

15. 推送此前所有提交…
作用：将当前提交及之前所有本地未推送的提交推送到远程仓库。
场景：同步本地积累的多次提交到远程。

16. 新建分支…
作用：基于当前提交创建新分支。
场景：从历史版本开始开发新功能，或保存当前提交的状态到独立分支。

17. 新建标记…（对应 git tag）
作用：为当前提交创建Git 标签（如v1.0.0），标记重要版本。
场景：标记发布版本、里程碑，方便后续快速定位。

18. 转到子提交（向左箭头）
作用：在提交历史的 “父子关系” 中，切换到当前提交的子提交（即基于当前提交后续创建的提交）。
场景：浏览提交历史的 “后续发展”。

19. 转到父提交（向右箭头）
作用：切换到当前提交的父提交（即当前提交基于哪个提交创建）。
场景：回溯提交历史的 “来源”。

20. 在 GitHub 上打开
作用：若项目托管在 GitHub，在浏览器中打开当前提交的 GitHub 网页详情。
场景：快速查看该提交在 GitHub 上的变更、讨论等信息。

这些选项覆盖了 Git“提交管理、历史编辑、分支 &#x2F; 标签操作” 等核心场景，帮助在 IDE 中高效操作版本控制。]]></content>
      <categories>
        <category>黑马点评笔记</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>新增代码复制按钮功能</title>
    <url>/2025/09/21/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE/%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81%E5%A4%8D%E5%88%B6%E6%8C%89%E9%92%AE%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[
参考文章Add Copy Button to Code Blocks in Hexo | Hexo
照着大佬来就好了！祝大家幸福美满。
]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>博客功能</tag>
      </tags>
  </entry>
  <entry>
    <title>改善黑暗模式中的代码显示</title>
    <url>/2025/09/21/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE/%E6%94%B9%E5%96%84%E9%BB%91%E6%9A%97%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[
参考文章：Sync Code Block Theme with Dark Mode in Hexo Chic | Hexo
没什么好说的，照着来就行。祝大家生活愉快，心想事成。
]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>博客功能</tag>
      </tags>
  </entry>
  <entry>
    <title>新增评论功能</title>
    <url>/2025/09/17/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE/%E6%96%B0%E5%A2%9E%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[使用giscus增加博客评论功能利用 GitHub Discussions 实现的评论系统

开源。🌏
无跟踪，无广告，永久免费。📡 🚫
无需数据库。所有数据均储存在 GitHub Discussions 中。:octocat:
支持自定义主题！🌗
支持多种语言。🌐
高可配置性。🔧
自动从 GitHub 拉取新评论与编辑。🔃
可自建服务！🤳

不同主题不同配置方法
以下是大佬的文章：
hexo 博客添加评论系统 | Jachin’s Blog
附上适合本主题的大佬链接Hexo and Chic themes add Giscus comment system | Hexo
]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title>记录搭建博客流程😗</title>
    <url>/2025/09/16/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE/%E8%AE%B0%E5%BD%95%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%B5%81%E7%A8%8B%F0%9F%98%97/</url>
    <content><![CDATA[说明记录一下博客搭建流程，为了能够以后更好的复现。
框架及工具
前端框架：hexo
后台管理系统插件：hexo pro
静态网站托管：github page
免费的 CDN 加速站点：cloudflare

准备需要准备 node 环境和 git
可以使用到 node 的版本管理工具****nvm 来下载 node。
# 访问 nvm 的 GitHub 仓库页面：https://github.com/nvm-sh/nvm# 可以在 Releases 页面（https://github.com/coreybutler/nvm-windows/releases）找到 nvm-setup.zip 安装文件并下载。# 解压并运行安装程序，按照提示进行安装。# nvm -v可以检查是否安装成功#NVM换源将如下代码加入settings.txt文件中。node_mirror: https://npmmirror.com/mirrors/nodenpm_mirror: https://npmmirror.com/mirrors/npm#NVM命令nvm version                # 查看NVM版本，是否安装成功nvm list available         # 查看可安装的node版本nvm list                   # 查看已安装的node版本nvm install 版本号          # 安装nodenvm uninstall 版本号        # 卸载nodenvm use 版本号              # 切换使用node版本nvm current                # 当前使用node版本nvm node_mirror [url]      # 切换node镜像[https://npm.taobao.org/mirrors/node/]nvm npm_mirror [url]       # 切换npm镜像[https://npm.taobao.org/mirrors/npm/]nvm alias default version  # 设置默认版本 #其他npm install -g yarn           # 全局安装yarnnpm install -g gitbook-cli   # 全局安装gitbook

通过 nvm 下载前需要把已经安装的 node 卸载
可以通过 Geek 卸载Geek Uninstaller - Download
通过 nvm 来下载：
1.打开终端（Windows 上是命令提示符或 PowerShell）
2.nvm list available 这个可以列出可以安装的 node 所有的版本
3.选择您想要安装的版本，例如安装 Node.js 版本 16.18.0 ，输入以下命令：nvm install 16.18.0
4.然后可以使用 nvm list 查看自己下载的版本
5.nvm use 16.18.0 安装完成后，可以使用命令切换到已安装的版本
6.再次 node -v 就可以看到安装的版本了
开始初始化 hexo 项目先安装 Hexo文档 | Hexo
npm install -g hexo-cli
创建文件夹，并进入到该文件夹的命令提示符（cmd）
输入hexo init 项目就会初始化
出现Start blogging with Hexo!表示成功
紧接着执行npm install
初始化后，您的项目文件夹将如下所示：
.├── _config.yml   #hexo的主配置文件├── package.json    #项目的依赖管理文件├── scaffolds   #模板文件夹├── source  #资源文件夹|   ├── _drafts #存放草稿文章|   └── _posts  #存放已经发布的文章└── themes  #主题文件夹

本地部署指令：hexo server 或 hexo s

访问 🔗，即可看到刚刚部署的网页了。
安装 hexo pro 插件wuzheng228&#x2F;hexo-pro
接下来安装 hexo pro 插件
# 1. 安装 Hexo Pro 插件npm install --save hexo-pro# 2. 启动 Hexo 服务器hexo server# 3. 访问后台管理页面http://localhost:4000/pro/

界面如下：

接下来我们就可以在这个系统里轻松地上传内容、更改配置、部署。
更改 hexo 配置更改_config.yml 的配置内容的操作自行根据官网文档来改。这边不多赘述。
配置 | Hexo
配置 github pagesGitHub Pages 文档 - GitHub 文档
首先默认大家有 GitHub 账户。
创建仓库（官网非常详细，我就粘下来啦）
在任何页面的右上角，选择 ，然后单击“新建存储库”。
**输入 **username.github.io 作为存储库名称。 将 username 替换为你的 GitHub 用户名。 例如，如果用户名为 octocat，则存储库名称应为 octocat.github.io。
选择仓库可见性。 有关详细信息，请参阅“关于仓库”。（默认 public）
选择“使用 README 初始化此存储库”。****（可选）
单击“创建存储库”。

部署代码连接 GitHub 的两种方式第一种使用 HTTPS 连接复制 GitHub 链接

第二种使用 SSH 连接如果选择 SSH 则需要通过 SSH 连接到 GitHub - GitHub 文档

执行以下命令生成 ssh 公钥，此公钥用于你的计算机连接 Github
ssh-keygen -t rsa -C &quot;你的邮箱&quot;

如下：

之后打开 C 盘下用户文件夹下的.ssh 的文件夹，会看到 id_rsa.pub
用记事本打开上述图片中的公钥（id_rsa.pub），复制里面的内容，然后开始在 github 中配置 ssh 密钥。

将 SSH KEY 配置到 GitHub 进入 github，点击右上角头像 选择settings，进入设置页后选择 SSH and GPG keys，名字随便起，公钥填到 Key 那一栏。

测试连接，输入以下命令
ssh -T git@github.com


出现连接到账户的信息，说明已经大功告成。


配置连接方式注意：通过Hexo Pro部署目前只能通过HTTPS的链接。
接下来只需要修改_config.yml 中最后一行的 deploy 的属性
deploy:  type: git   repo: #粘贴刚才所复制的HTTPS链接  branch: main #注意是main，不是master  message: &#x27;Site updated: &#123;&#123; now(&quot;YYYY-MM-DD HH:mm:ss&quot;) &#125;&#125;&#x27;

注意： yml 格式的文件，对应低一级的字段要在上级字段前至少空两格
现在我们在部署这栏中填写我们的仓库地址

仓库地址格式: username&#x2F;repository
紧接着点击执行部署即可。
然后就可以访问啦。😁
使用ssh部署，只能通过命令行也是先把仓库链接填上
deploy:  type: git  repo: git@github.com:meisijiya/meisijiya.github.io.git  branch: main  message: &#x27;Site updated: &#123;&#123; now(&quot;YYYY-MM-DD HH:mm:ss&quot;) &#125;&#125;&#x27;

部署的命令如下：

hexo clean：删除之前生成的文件，若未生成过静态文件，可忽略此命令。
hexo generate：生成静态文章，可以用 hexo g 缩写
hexo deploy：部署文章，可以用 hexo d 缩写

以下内容备用（一般执行完上面的步骤就可以了）
在存储库名称下，单击 “设置”。 如果看不到“设置”选项卡，请选择“”下拉菜单，然后单击“设置”。

在边栏的“代码和自动化”部分中，单击“ Pages”。

在“生成和部署”的“源”下，选择“从分支进行部署”。

在“生成和部署”的“分支”下，使用分支下拉菜单并选择发布源。8、9 的操作如下：


（可选）打开存储库的README.md 文件。 README.md 文件是你将为站点编写内容的位置。 您可以编辑文件或暂时保留默认内容。

访问 username.github.io 以查看新网站。 请注意，对站点的更改在推送到 GitHub 后，最长可能需要 10 分钟才会发布。


更改标题和说明（粘自官网）默认情况下，站点的标题为 username.github.io。 可通过编辑存储库中的 _config.yml 文件来更改标题。 您还可以为您的网站添加说明。

单击存储库的“代码”选项卡。
在文件列表中，单击 _config.yml 以打开该文件。
单击 编辑文件。
_config.yml 文件已包含指定站点主题的行。 添加一个新行，其中 title: 后跟所需的标题。 添加一个新行，其中 description: 后跟所需的描述。 例如：theme: jekyll-theme-minimaltitle: Octocat&#x27;s homepagedescription: Bookmark this to keep an eye on my project updates!
编辑完文件后，单击“提交更改”。

购买域名并更换域名域名购买参考如下：全网最全的域名解析和网站备案-CSDN 博客
替换域名
每次 deploy 的时候这里都会被重置为空
解决方法是在你博客项目下的****public 文件夹中创建一个名为 CNAME 的文件,注意，该文件无后缀。
用文本编辑器打开并填入你的域名（注意，不需要加入 https:&#x2F;&#x2F;，只需要域名）
这样就不用每部署一次就来填写一次自己的域名了。
此时访问你的域名，就会直接跳转到你的 github page 项目中。
使用 cloudflare 做 cdn 加速当然也有别的选择如，Vercel、Netlify、Railway、Render、Fleek、Zeabur
**这里我选择 cloudflare  **https://dash.cloudflare.com/
在账户主页 那一栏，点击 加入域

添加域名，然后点继续，接着选择免费计划即可。
接下来添加 DNS 记录
点击添加记录
名称一栏填 @，地址填下面出现的四个 ip 地址


使域名指向 github 的 IPv4 地址，这四个 IP（185.199.108.153、185.199.109.153、185.199.110.153、185.199.111.153）是 GitHub Pages 官方指定的用于内容分发的 IP，配置后域名会指向 GitHub 的服务器，从而能访问部署在 GitHub Pages 上的内容。
**保持后等待即可，因为 **DNS 解析依赖 “缓存” 和 “全球节点同步”，这两个机制决定了配置变更不会立即生效。
进阶–使用 Chic 主题Themes | Hexo
选择喜欢的主题，点击进入开发者产品的 readme 来一步一步配置即可。
我选择 Chic 这个主题，因为简单哈哈哈，当然也简洁美。🥰
hexo-theme-Chic&#x2F;README-CN.md at master · Siricee&#x2F;hexo-theme-Chic
操作步骤
cd your-blog/themes #进入到themes文件夹中git clone https://github.com/Siricee/hexo-theme-Chic.git Chic #打开cmd，然后输入该指令克隆即可// Modify theme setting in _config.yml to Chic.###需要我们在主配置文件_config.yml中，修改theme的值为Chic

然后我们可以看到&#x2F;theme&#x2F;Chic 这个文件夹中有_config.yml 配置文件，修改值来改变样式即可
添加 Tag、Category 页面
Hexo 初始化没有 tag、category 页面，需要自行添加，本主题请按以下步骤进行:
执行命令
hexo new page taghexo new page category

进入页面目录
cd source/tag

增加 layout 字段
// source\tag\index.md---title: Taglayout: tag---

category 页面同理，layout 字段键值为 category。
剩下的内容再更新吧，谢谢观看]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title>新增本地搜索</title>
    <url>/2025/09/21/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE/%E6%96%B0%E5%A2%9E%E6%9C%AC%E5%9C%B0%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[
参考原文Custom Search Integration for Hexo Chic | Hexo
tip：改了改，感觉我的有点屎山（不太会前端，得恶补一下js）
1.基于hexo-generator-searchdb实现的本地搜索npm install hexo-generator-searchdb #安装插件依赖

2.配置根目录的_config.ymlsearch:  path: search.xml   field: all  content: true   format: striptags 


path - 生成的数据库文件的路径。支持.json和.xml格式。如果未提供文件扩展名，默认将使用JSON格式。 
field - 你想要搜索的范围，你可以选择： post（默认）- 仅涵盖你博客的所有文章。 page - 仅涵盖你博客的所有页面。 all - 涵盖你博客的所有文章和页面。 
content - 是否包含每篇文章的完整内容。如果为false，生成的结果仅包含标题和其他元信息，不包含正文。默认值为true。
format - 页面内容的形式，选项有： striptags（默认）- 原始html字符串被压缩，并移除所有标签。 html - 原始html字符串被压缩。 raw - 每个文章或页面的markdown文本。

3.新建 search.css建议路径: themes/hexo-theme-Chic/source/css/search.css
/* 搜索框容器 */.search-container &#123;  position: relative;  display: inline-block;  vertical-align: middle;  margin-right: 10px;&#125;.search-container a &#123;  padding-right: 6px;  cursor: pointer;  font-size: 1.1em;&#125;.nav-search-input &#123;  display: none;  padding: 6px 10px;  border: 1px solid #ccc;  border-radius: 4px;  width: 260px;  transition: all 0.3s ease;  vertical-align: middle;&#125;.nav-search-input.active &#123;  display: inline-block;&#125;.nav-search-result &#123;  position: absolute;  top: 100%;  left: 0;  background: white;  border: 1px solid #ccc;  border-radius: 6px;  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);  margin-top: 6px;  padding: 0.4em;  min-width: 260px;  max-height: 360px;  overflow-y: auto;  display: none;  z-index: 999;&#125;/* 搜索卡片 */.search-card &#123;  padding: 4px 6px;  margin-bottom: 3px;  border-bottom: 1px solid #eee;  transition: background 0.2s;&#125;.search-card:last-child &#123;  border-bottom: none;  margin-bottom: 0;&#125;.search-card:hover &#123;  background: #f9f9f9;&#125;.search-card-title &#123;  display: block;  font-weight: bold;  color: #1a0dab;  font-size: 1em;  line-height: 1.2em;  text-decoration: none;  margin: 0;  padding: 0;  text-align: left;&#125;.search-card-title:hover &#123;  text-decoration: underline;&#125;.search-card-snippet &#123;  font-size: 0.88em;  color: #444;  margin-top: 2px;  line-height: 1.3em;  display: -webkit-box;  -webkit-line-clamp: 2;  -webkit-box-orient: vertical;  overflow: hidden;&#125;/* 🌙 暗色主题适配 */.dark-theme .nav-search-input &#123;  background-color: #1e1e1e;  color: #eee;  border: 1px solid #555;&#125;.dark-theme .nav-search-result &#123;  background-color: #2a2a2a;  color: #eee;  border: 1px solid #555;&#125;.dark-theme .search-card &#123;  border-bottom: 1px solid #444;&#125;.dark-theme .search-card:hover &#123;  background: #333;&#125;.dark-theme .search-card-title &#123;  color: #4ea1ff;&#125;.dark-theme .search-card-snippet &#123;  color: #ccc;&#125;/* 移动端适配 *//* iPadmini适配 */@media (min-width: 481px) and (max-width: 767px) &#123;  .search-container a &#123;    display: none;  &#125;&#125;@media (max-width: 768px) &#123;  .nav-search-input &#123;    width: 90%;    display: block;    margin: 10px auto;  &#125;  /* 暗色主题下的移动端结果容器 */  .dark-theme .nav-search-result &#123;    background-color: #2a2a2a;  &#125;&#125;/* 全局定位的移动端搜索结果 */@media (max-width: 768px) &#123;  .nav-search-result &#123;    position: fixed;           /* 相对于视窗定位 */    top: 20%;                  /* 距离顶部20% */    left: 5%;    right: 5%;    z-index: 9999;             /* 更高的层级 */    max-height: 60vh;          /* 更大的最大高度 */    margin: 0;    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);  &#125;&#125;

4.修改主题配置打开theme/Chic/_config.yml ，在 stylesheets 下增加一行 search.css 确保加载样式文件：
stylesheets:  - /css/style.css  - /css/search.css

5.修改 header.ejs&lt;header&gt;  &lt;nav class=&quot;navbar&quot;&gt;    &lt;div class=&quot;container&quot;&gt;      &lt;div class=&quot;navbar-header header-logo&quot;&gt;        &lt;a href=&quot;&lt;%- config.root %&gt;&quot;&gt;&lt;%= theme.navname %&gt;&lt;/a&gt;      &lt;/div&gt;      &lt;div class=&quot;menu navbar-right&quot;&gt;        &lt;!-- 在电脑端的导航链接区域添加搜索功能 --&gt;        &lt;div class=&quot;search-container&quot;&gt;          &lt;a href=&quot;javascript:;&quot; onclick=&quot;toggleSearchInput()&quot;&gt;🔍&lt;/a&gt;          &lt;input            type=&quot;text&quot;            id=&quot;nav-search-input-desktop&quot;            class=&quot;nav-search-input&quot;            placeholder=&quot;想知道我什么秘密呢，搜搜看吧&quot;            oninput=&quot;navSearch(this)&quot;          /&gt;          &lt;div id=&quot;nav-search-result-desktop&quot; class=&quot;nav-search-result&quot;&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;% for (var i in theme.nav)&#123; %&gt;        &lt;a class=&quot;menu-item&quot; href=&quot;&lt;%- url_for(theme.nav[i]) %&gt;&quot;&gt;&lt;%= i %&gt;&lt;/a&gt;        &lt;% &#125; %&gt;        &lt;input id=&quot;switch_default&quot; type=&quot;checkbox&quot; class=&quot;switch_default&quot; /&gt;        &lt;label for=&quot;switch_default&quot; class=&quot;toggleBtn&quot;&gt;&lt;/label&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/nav&gt;  &lt;%# mobile %&gt;  &lt;nav class=&quot;navbar-mobile&quot; id=&quot;nav-mobile&quot;&gt;    &lt;div class=&quot;container&quot;&gt;      &lt;div class=&quot;navbar-header&quot;&gt;        &lt;div&gt;          &lt;a href=&quot;&lt;%- config.root %&gt;&quot;&gt;&lt;%= theme.navname %&gt;&lt;/a          &gt;&lt;a id=&quot;mobile-toggle-theme&quot;&gt;·&amp;nbsp;Light&lt;/a&gt;        &lt;/div&gt;        &lt;div class=&quot;menu-toggle&quot; onclick=&quot;mobileBtn()&quot;&gt;          &lt;svg            class=&quot;menu-icon&quot;            xmlns=&quot;http://www.w3.org/2000/svg&quot;            width=&quot;32&quot;            height=&quot;32&quot;            viewBox=&quot;0 0 24 24&quot;          &gt;            &lt;path              fill=&quot;currentColor&quot;              d=&quot;M4.5 17.27q-.213 0-.356-.145T4 16.768t.144-.356t.356-.143h15q.213 0 .356.144q.144.144.144.357t-.144.356t-.356.143zm0-4.77q-.213 0-.356-.144T4 11.999t.144-.356t.356-.143h15q.213 0 .356.144t.144.357t-.144.356t-.356.143zm0-4.77q-.213 0-.356-.143Q4 7.443 4 7.23t.144-.356t.356-.143h15q.213 0 .356.144T20 7.23t-.144.356t-.356.144z&quot;            /&gt;          &lt;/svg&gt;          &lt;svg            class=&quot;close-icon&quot;            xmlns=&quot;http://www.w3.org/2000/svg&quot;            width=&quot;32&quot;            height=&quot;32&quot;            viewBox=&quot;0 0 24 24&quot;          &gt;            &lt;!-- Icon from Material Symbols Light by Google - https://github.com/google/material-design-icons/blob/master/LICENSE --&gt;            &lt;path              fill=&quot;currentColor&quot;              d=&quot;m12 12.708l-5.246 5.246q-.14.14-.344.15t-.364-.15t-.16-.354t.16-.354L11.292 12L6.046 6.754q-.14-.14-.15-.344t.15-.364t.354-.16t.354.16L12 11.292l5.246-5.246q.14-.14.345-.15q.203-.01.363.15t.16.354t-.16.354L12.708 12l5.246 5.246q.14.14.15.345q.01.203-.15.363t-.354.16t-.354-.16z&quot;            /&gt;          &lt;/svg&gt;        &lt;/div&gt;      &lt;/div&gt;      &lt;div class=&quot;menu&quot; id=&quot;mobile-menu&quot;&gt;        &lt;% for (var i in theme.nav)&#123; %&gt;        &lt;a class=&quot;menu-item&quot; href=&quot;&lt;%- url_for(theme.nav[i]) %&gt;&quot;&gt;&lt;%= i %&gt;&lt;/a&gt;        &lt;% &#125; %&gt;        &lt;!-- 手机模式搜索框 --&gt;        &lt;div class=&quot;search-container mobile-container&quot;&gt;          &lt;a class=&quot;menu-item&quot; href=&quot;javascript:;&quot; onclick=&quot;toggleSearchInput()&quot;            &gt;🔍&lt;/a          &gt;          &lt;input            type=&quot;text&quot;            id=&quot;nav-search-input-mobile&quot;            class=&quot;nav-search-input&quot;            placeholder=&quot;想知道我什么秘密呢，搜搜看吧&quot;            oninput=&quot;navSearch(this)&quot;          /&gt;          &lt;div id=&quot;nav-search-result-mobile&quot; class=&quot;nav-search-result&quot;&gt;&lt;/div&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/nav&gt;&lt;/header&gt;&lt;script&gt;  var mobileBtn = function f() &#123;    var toggleMenu = document.getElementsByClassName(&quot;menu-toggle&quot;)[0];    var mobileMenu = document.getElementById(&quot;mobile-menu&quot;);    if (toggleMenu.classList.contains(&quot;active&quot;)) &#123;      toggleMenu.classList.remove(&quot;active&quot;);      mobileMenu.classList.remove(&quot;active&quot;);    &#125; else &#123;      toggleMenu.classList.add(&quot;active&quot;);      mobileMenu.classList.add(&quot;active&quot;);    &#125;  &#125;;  function toggleSearchInput() &#123;    const inputs = document.querySelectorAll(&quot;.nav-search-input&quot;);    const results = document.querySelectorAll(&quot;.nav-search-result&quot;);    inputs.forEach((input) =&gt; &#123;      input.classList.toggle(&quot;active&quot;);      if (input.classList.contains(&quot;active&quot;)) input.focus();    &#125;);    results.forEach((r) =&gt; (r.style.display = &quot;none&quot;));  &#125;  // 点击外部区域隐藏搜索框和结果容器的函数  function handleClickOutsideSearch(event) &#123;    const searchContainers = document.querySelectorAll(&quot;.search-container&quot;);    searchContainers.forEach((container) =&gt; &#123;      const searchInput = container.querySelector(&quot;.nav-search-input&quot;);      const searchIcon = container.querySelector(&quot;a&quot;);      // 如果点击的元素不是搜索输入框或搜索图标，则隐藏搜索框和结果容器      if (        !searchInput.contains(event.target) &amp;&amp;        !searchIcon.contains(event.target)      ) &#123;        searchInput.classList.remove(&quot;active&quot;);        searchInput.value = &quot;&quot;        // 根据输入框ID确定对应的结果容器        let resultContainer;        if (searchInput.id === &quot;nav-search-input-mobile&quot;) &#123;          // 移动端结果容器          resultContainer = document.querySelector(            &quot;.navbar-mobile .nav-search-result&quot;          );        &#125; else &#123;          // 桌面端结果容器          resultContainer = document.getElementById(            &quot;nav-search-result-desktop&quot;          );        &#125;        if (resultContainer) &#123;          resultContainer.style.display = &quot;none&quot;;          resultContainer.innerHTML = &quot;&quot;; // 清空结果容器内容        &#125;      &#125;    &#125;);  &#125;  // 添加全局点击事件监听器  document.addEventListener(&quot;click&quot;, function (event) &#123;    handleClickOutsideSearch(event);  &#125;);  // 新增：搜索功能实现  let searchData = []; // 全局变量存储搜索数据  // 页面加载完成后获取搜索数据  document.addEventListener(&quot;DOMContentLoaded&quot;, function () &#123;    fetch(&quot;&lt;%- config.root %&gt;search.xml&quot;)      .then((res) =&gt; res.text())      .then((xmlText) =&gt; &#123;        const parser = new DOMParser();        const xml = parser.parseFromString(xmlText, &quot;text/xml&quot;);        const entries = xml.getElementsByTagName(&quot;entry&quot;);        for (let entry of entries) &#123;          searchData.push(&#123;            title: entry.getElementsByTagName(&quot;title&quot;)[0]?.textContent || &quot;&quot;,            content:              entry.getElementsByTagName(&quot;content&quot;)[0]?.textContent || &quot;&quot;,            url: entry.getElementsByTagName(&quot;url&quot;)[0]?.textContent || &quot;&quot;,          &#125;);        &#125;      &#125;)      .catch((err) =&gt; &#123;        console.error(&quot;Failed to load search data:&quot;, err);      &#125;);  &#125;);  // 新增：导航搜索方法  function navSearch(inputElement) &#123;    const keyword = inputElement.value.trim().toLowerCase();    // 查找对应的搜索结果容器    let resultContainer;    if (inputElement.id === &quot;nav-search-input-desktop&quot;) &#123;      // 桌面端      resultContainer = document.getElementById(&quot;nav-search-result-desktop&quot;);    &#125; else if (inputElement.id === &quot;nav-search-input-mobile&quot;) &#123;      // 移动端      resultContainer =        inputElement.parentNode.querySelector(&quot;.nav-search-result&quot;);    &#125;    if (!resultContainer) return;    resultContainer.innerHTML = &quot;&quot;;    if (!keyword) &#123;      resultContainer.style.display = &quot;none&quot;;      return;    &#125;    // 显示结果容器    resultContainer.style.display = &quot;block&quot;;    // 过滤搜索数据    const results = searchData.filter(      (data) =&gt;        (data.title &amp;&amp; data.title.toLowerCase().includes(keyword)) ||        (data.content &amp;&amp; data.content.toLowerCase().includes(keyword))    );    if (results.length === 0) &#123;      resultContainer.innerHTML =        &#x27;&lt;p class=&quot;no-result&quot;&gt;没有结果哟，换个关键词试试吧&lt;/p&gt;&#x27;;      return;    &#125;    // 限制显示结果数量    const maxResults = 10;    const limitedResults = results.slice(0, maxResults);    // 构建结果HTML    const html = limitedResults      .map((item) =&gt; &#123;        // 提取包含关键字的内容片段        let contentSnippet = &quot;&quot;;        if (item.content) &#123;          // 找到包含关键字的内容片段          const contentLower = item.content.toLowerCase();          const keywordIndex = contentLower.indexOf(keyword);          // 提取关键字前后的内容          const start = Math.max(0, keywordIndex - 3 * keyword.length);          const end = Math.min(            item.content.length,            keywordIndex + 3 * keyword.length          );          contentSnippet = item.content.substring(start, end);        // 高亮关键字      const keywordRegex = new RegExp(`($&#123;keyword.replace(/[.*+?^$&#123;&#125;()|[\]\\]/g, &#x27;\\$&amp;&#x27;)&#125;)`, &#x27;gi&#x27;);      contentSnippet = contentSnippet.replace(        keywordRegex,        &quot;&lt;mark&gt;$1&lt;/mark&gt;&quot;      );        &#125;        return `&lt;div class=&quot;search-result-item&quot;&gt;  &lt;a href=&quot;$&#123;item.url&#125;&quot;&gt;    &lt;div&gt;标题：$&#123;item.title&#125;&lt;/div&gt;    &lt;div&gt;内容：$&#123;contentSnippet&#125;&lt;/div&gt;  &lt;/a&gt;&lt;/div&gt;`;      &#125;)      .join(&quot;&quot;);    resultContainer.innerHTML = html;  &#125;&lt;/script&gt;&lt;style&gt;  /* 手机端使用flexbox布局搜索容器 */  .mobile-container &#123;    display: flex;    align-items: center;    flex-direction: row;    margin-bottom: 10px;    margin-left: 10px;    flex-grow: 1;    max-width: calc(100% - 40px);  &#125;  .search-result-item &#123;  border: 1px solid #ddd; /* 边框 */  margin: 4px 0; /* 外层间距 */  padding: 0; /* 无内边距 */  background: #fff; /* 背景色 */&#125;.search-result-item a &#123;  display: block;  text-decoration: none;  color: inherit;&#125;.search-result-item div &#123;  padding: 3px 8px; /* 紧凑的内边距 */  margin: 0; /* 无外边距 */  line-height: 1.3; /* 紧凑的行高 */  word-wrap: break-word; /* 允许长单词换行 */  white-space: normal; /* 允许正常换行 */&#125;.search-result-item div:first-child &#123;  border-bottom: 1px solid #eee; /* 标题和内容之间的分隔线 */&#125;&lt;/style&gt;

6.实现效果
点击图标展示搜索框
实时匹配文章标题&#x2F;内容
结果以卡片形式展示
黑色模式样式自动选择
点击空白地方隐藏结果 + 清空文本
移动端页面适配

7. 新生成并运行 Hexo需要通过hexo g生成本地数据库
hexo cleanhexo ghexo s

]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>博客功能</tag>
      </tags>
  </entry>
  <entry>
    <title>改良代码块，过长则滚动展示</title>
    <url>/2025/09/21/%E6%94%B9%E8%89%AF%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%8C%E8%BF%87%E9%95%BF%E5%88%99%E6%BB%9A%E5%8A%A8%E5%B1%95%E7%A4%BA/</url>
    <content><![CDATA[在/themes/Chic/source/css/style.styl文件中添加如下
// 代码块滚动功能：限制高度并显示滚动条.highlight  // 核心：限制最大高度，超出部分滚动  max-height: 400px !important  overflow-y: auto !important  // 垂直滚动  overflow-x: auto !important  // 水平滚动（防止代码过长溢出）  white-space: pre !important  // 保留代码格式，不自动换行  height: auto !important      // 避免固定高度覆盖滚动逻辑  // 优化代码块内边距和视觉效果（可选，根据主题调整）  padding: 15px !important  border-radius: 6px !important// 暗色模式适配（如果主题支持暗色模式）.dark-theme  .highlight    background-color: #1e1e1e !important  // 暗色背景    border: 1px solid #333 !important     // 暗色边框// 响应式适配：移动端降低最大高度@media (max-width: 768px)  .highlight    max-height: 300px !important  // 手机端显示更少内容，避免占满屏幕

搭配改善在黑暗模式中的代码背景显示以及滚动条视觉优化的代码/themes/Chic/source/css/custom.css
pre,code,pre code,.highlight &#123;    background: inherit !important;    color: inherit !important;    box-shadow: none !important;    border: none !important;  &#125;body.dark-theme pre,body.dark-theme code,body.dark-theme .highlight &#123;    background: #0d1117 !important;  /* 暗色背景 */    color: #c9d1d9 !important;       /* 暗色文字 */    box-shadow: none !important;    border: none !important;&#125;body.dark-theme pre::-webkit-scrollbar-track,body.dark-theme code::-webkit-scrollbar-track &#123;    background: #0d1117 !important;  /* 修复滚动条白边 */&#125;
]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>博客功能</tag>
      </tags>
  </entry>
  <entry>
    <title>欢迎来到老江湖的世界</title>
    <url>/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E8%80%81%E6%B1%9F%E6%B9%96%E7%9A%84%E4%B8%96%E7%95%8C/index.html</url>
    <content><![CDATA[老江湖进房间门，这故事得从去年说起，说来话长，我们长话短说…
]]></content>
  </entry>
  <entry>
    <title>tag</title>
    <url>/tag/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>category</title>
    <url>/category/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>关于我</title>
    <url>/about/index.html</url>
    <content><![CDATA[我有个可爱的女友，希望我们能够长长久久。
❤️ 老江湖爱房间门。
博客的由来老江湖拿来记录学习情况，以及分享老江湖和房间门的趣事。
]]></content>
  </entry>
  <entry>
    <title>照片墙</title>
    <url>/%E7%85%A7%E7%89%87%E5%A2%99/index.html</url>
    <content><![CDATA[开发中ing…
]]></content>
  </entry>
  <entry>
    <title>时间线</title>
    <url>/timeLine/index.html</url>
    <content><![CDATA[2024.10.5🎉老江湖和房间门确认关系的日子。
2024.10.12老江湖给房间门过的第一个生日🎂
2024.10.21房间门给老江湖过的第一个生日🎂
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/js/code-copy.js</url>
    <content><![CDATA[document.addEventListener('DOMContentLoaded', () => {
  document.querySelectorAll('figure.highlight').forEach((figure) => {
    if (figure.querySelector('.copy-btn')) return;

    const copyBtn = document.createElement('button');
    copyBtn.className = 'copy-btn';
    copyBtn.title = '复制';

    // 缩小后的复制图标（14*15）
    const copyIcon = `
      
        
      
    `;

    // 成功后显示的勾（14*15）
    const checkIcon = `
      
        
      
    `;

    copyBtn.innerHTML = copyIcon;

    // 按钮样式（浅灰底、缩小）
    Object.assign(copyBtn.style, {
      position: 'absolute',
      top: '8px',
      right: '8px',
      padding: '4px',
      background: '#aaa', 
      border: 'none',
      borderRadius: '4px',
      cursor: 'pointer',
      opacity: '0.85',
      zIndex: 1000,
      transition: 'opacity 0.2s ease',
      boxShadow: '0 1px 3px rgba(0, 0, 0, 0.15)'
    });

    copyBtn.addEventListener('mouseover', () => copyBtn.style.opacity = '1');
    copyBtn.addEventListener('mouseout', () => copyBtn.style.opacity = '0.85');

    copyBtn.addEventListener('click', () => {
      const code = figure.querySelector('td.code');
      const text = code ? code.innerText : '';
      navigator.clipboard.writeText(text).then(() => {
        copyBtn.innerHTML = checkIcon;
        setTimeout(() => {
          copyBtn.innerHTML = copyIcon;
        }, 1000);
      });
    });

    figure.style.position = 'relative';
    figure.appendChild(copyBtn);
  });
});
]]></content>
  </entry>
</search>
