<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="老江湖">


    <meta name="subtitle" content="记录进入房间门后的美好">


    <meta name="description" content="一年前，孤苦伶仃的老江湖，偶然间发现一处房间门，推门而入，从此进入了充满幸福的世界。">


    <meta name="keywords" content="老江湖,博客,房间门">


<title>07-分布式锁-redission | 欢迎来到老江湖的博客</title>



    <link rel="icon" href="/images/%E9%87%91%E6%AF%9B.png?_t=1758006391547">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    
    <link rel="stylesheet" href="/css/search.css">
    

<!-- highlight.js 样式（默认亮色） -->
<link id="hljs-theme" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/github.css">
<!-- highlight.js 自动上色功能 -->
<script src="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/lib/highlight.min.js"></script>
<script>hljs.highlightAll();</script>

<link rel="stylesheet" href="/css/custom.css">



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 7.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const pagebody = document.getElementsByTagName('body')[0]

            function setTheme(status) {

                if (status === 'dark') {
                    window.sessionStorage.theme = 'dark'
                    pagebody.classList.add('dark-theme');

                } else if (status === 'light') {
                    window.sessionStorage.theme = 'light'
                    pagebody.classList.remove('dark-theme');
                }
            };

            setTheme(window.sessionStorage.theme)
        })();
    </script>

    <div class="wrapper">
        <header>
  <nav class="navbar">
    <div class="container">
      <div class="navbar-header header-logo">
        <a href="/">老江湖的博客</a>
      </div>
      <div class="menu navbar-right">
        <!-- 在电脑端的导航链接区域添加搜索功能 -->
        <div class="search-container">
          <a href="javascript:;" onclick="toggleSearchInput()">🔍</a>
          <input
            type="text"
            id="nav-search-input-desktop"
            class="nav-search-input"
            placeholder="想知道我什么秘密呢，搜搜看吧"
            oninput="navSearch(this)"
          />
          <div id="nav-search-result-desktop" class="nav-search-result"></div>
        </div>

        
        <a class="menu-item" href="/archives">归档</a>
        
        <a class="menu-item" href="/category">分类</a>
        
        <a class="menu-item" href="/tag">标签</a>
        
        <a class="menu-item" href="/Timer">任务计时器</a>
        
        <a class="menu-item" href="/timeLine">时间线</a>
        
        <a class="menu-item" href="/tongji">网站统计</a>
        
        <a class="menu-item" href="/about">关于</a>
        

        <input id="switch_default" type="checkbox" class="switch_default" />
        <label for="switch_default" class="toggleBtn"></label>
      </div>
    </div>
  </nav>

  
  <nav class="navbar-mobile" id="nav-mobile">
    <div class="container">
      <div class="navbar-header">
        <div>
          <a href="/">老江湖的博客</a
          ><a id="mobile-toggle-theme">·&nbsp;Light</a>
        </div>

        <div class="menu-toggle" onclick="mobileBtn()">
          <svg
            class="menu-icon"
            xmlns="http://www.w3.org/2000/svg"
            width="32"
            height="32"
            viewBox="0 0 24 24"
          >
            <path
              fill="currentColor"
              d="M4.5 17.27q-.213 0-.356-.145T4 16.768t.144-.356t.356-.143h15q.213 0 .356.144q.144.144.144.357t-.144.356t-.356.143zm0-4.77q-.213 0-.356-.144T4 11.999t.144-.356t.356-.143h15q.213 0 .356.144t.144.357t-.144.356t-.356.143zm0-4.77q-.213 0-.356-.143Q4 7.443 4 7.23t.144-.356t.356-.143h15q.213 0 .356.144T20 7.23t-.144.356t-.356.144z"
            />
          </svg>
          <svg
            class="close-icon"
            xmlns="http://www.w3.org/2000/svg"
            width="32"
            height="32"
            viewBox="0 0 24 24"
          >
            <!-- Icon from Material Symbols Light by Google - https://github.com/google/material-design-icons/blob/master/LICENSE -->
            <path
              fill="currentColor"
              d="m12 12.708l-5.246 5.246q-.14.14-.344.15t-.364-.15t-.16-.354t.16-.354L11.292 12L6.046 6.754q-.14-.14-.15-.344t.15-.364t.354-.16t.354.16L12 11.292l5.246-5.246q.14-.14.345-.15q.203-.01.363.15t.16.354t-.16.354L12.708 12l5.246 5.246q.14.14.15.345q.01.203-.15.363t-.354.16t-.354-.16z"
            />
          </svg>
        </div>
      </div>

      <div class="menu" id="mobile-menu">
        
        <a class="menu-item" href="/archives">归档</a>
        
        <a class="menu-item" href="/category">分类</a>
        
        <a class="menu-item" href="/tag">标签</a>
        
        <a class="menu-item" href="/Timer">任务计时器</a>
        
        <a class="menu-item" href="/timeLine">时间线</a>
        
        <a class="menu-item" href="/tongji">网站统计</a>
        
        <a class="menu-item" href="/about">关于</a>
        
        <!-- 手机模式搜索框 -->
        <div class="search-container mobile-container">
          <a class="menu-item" href="javascript:;" onclick="toggleSearchInput()"
            >🔍</a
          >
          <input
            type="text"
            id="nav-search-input-mobile"
            class="nav-search-input"
            placeholder="想知道我什么秘密呢，搜搜看吧"
            oninput="navSearch(this)"
          />
          <div id="nav-search-result-mobile" class="nav-search-result"></div>
        </div>
      </div>
    </div>
  </nav>
</header>
<script>
  var mobileBtn = function f() {
    var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
    var mobileMenu = document.getElementById("mobile-menu");
    if (toggleMenu.classList.contains("active")) {
      toggleMenu.classList.remove("active");
      mobileMenu.classList.remove("active");
    } else {
      toggleMenu.classList.add("active");
      mobileMenu.classList.add("active");
    }
  };

  function toggleSearchInput() {
    const inputs = document.querySelectorAll(".nav-search-input");
    const results = document.querySelectorAll(".nav-search-result");
    inputs.forEach((input) => {
      input.classList.toggle("active");
      if (input.classList.contains("active")) input.focus();
    });
    results.forEach((r) => (r.style.display = "none"));
  }

  // 点击外部区域隐藏搜索框和结果容器的函数
  function handleClickOutsideSearch(event) {
    const searchContainers = document.querySelectorAll(".search-container");
    searchContainers.forEach((container) => {
      const searchInput = container.querySelector(".nav-search-input");
      const searchIcon = container.querySelector("a");

      // 如果点击的元素不是搜索输入框或搜索图标，则隐藏搜索框和结果容器
      if (
        !searchInput.contains(event.target) &&
        !searchIcon.contains(event.target)
      ) {
        searchInput.classList.remove("active");
        searchInput.value = ""
        // 根据输入框ID确定对应的结果容器
        let resultContainer;
        if (searchInput.id === "nav-search-input-mobile") {
          // 移动端结果容器
          resultContainer = document.querySelector(
            ".navbar-mobile .nav-search-result"
          );
        } else {
          // 桌面端结果容器
          resultContainer = document.getElementById(
            "nav-search-result-desktop"
          );
        }

        if (resultContainer) {
          resultContainer.style.display = "none";
          resultContainer.innerHTML = ""; // 清空结果容器内容
        }
      }
    });
  }

  // 添加全局点击事件监听器
  document.addEventListener("click", function (event) {
    handleClickOutsideSearch(event);
  });

  // 新增：搜索功能实现
  let searchData = []; // 全局变量存储搜索数据

  // 页面加载完成后获取搜索数据
  document.addEventListener("DOMContentLoaded", function () {
    fetch("/search.xml")
      .then((res) => res.text())
      .then((xmlText) => {
        const parser = new DOMParser();
        const xml = parser.parseFromString(xmlText, "text/xml");
        const entries = xml.getElementsByTagName("entry");
        for (let entry of entries) {
          searchData.push({
            title: entry.getElementsByTagName("title")[0]?.textContent || "",
            content:
              entry.getElementsByTagName("content")[0]?.textContent || "",
            url: entry.getElementsByTagName("url")[0]?.textContent || "",
          });
        }
      })
      .catch((err) => {
        console.error("Failed to load search data:", err);
      });
  });

  // 新增：导航搜索方法
  function navSearch(inputElement) {
    const keyword = inputElement.value.trim().toLowerCase();
    // 查找对应的搜索结果容器
    let resultContainer;

    if (inputElement.id === "nav-search-input-desktop") {
      // 桌面端
      resultContainer = document.getElementById("nav-search-result-desktop");
    } else if (inputElement.id === "nav-search-input-mobile") {
      // 移动端
      resultContainer =
        inputElement.parentNode.querySelector(".nav-search-result");
    }

    if (!resultContainer) return;

    resultContainer.innerHTML = "";

    if (!keyword) {
      resultContainer.style.display = "none";
      return;
    }

    // 显示结果容器
    resultContainer.style.display = "block";

    // 过滤搜索数据
    const results = searchData.filter(
      (data) =>
        (data.title && data.title.toLowerCase().includes(keyword)) ||
        (data.content && data.content.toLowerCase().includes(keyword))
    );

    if (results.length === 0) {
      resultContainer.innerHTML =
        '<p class="no-result">没有结果哟，换个关键词试试吧</p>';
      return;
    }

    // 限制显示结果数量
    const maxResults = 10;
    const limitedResults = results.slice(0, maxResults);

    // 构建结果HTML
    const html = limitedResults
      .map((item) => {
        // 提取包含关键字的内容片段
        let contentSnippet = "";
        if (item.content) {
          // 找到包含关键字的内容片段
          const contentLower = item.content.toLowerCase();
          const keywordIndex = contentLower.indexOf(keyword);

          // 提取关键字前后的内容
          const start = Math.max(0, keywordIndex - 3 * keyword.length);
          const end = Math.min(
            item.content.length,
            keywordIndex + 3 * keyword.length
          );
          contentSnippet = item.content.substring(start, end);
        // 高亮关键字
      const keywordRegex = new RegExp(`(${keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
      contentSnippet = contentSnippet.replace(
        keywordRegex,
        "<mark>$1</mark>"
      );
        }

        return `<div class="search-result-item">
  <a href="${item.url}">
    <div>标题：${item.title}</div>
    <div>内容：${contentSnippet}</div>
  </a>
</div>`;
      })
      .join("");
    resultContainer.innerHTML = html;
  }
</script>
<style>
  /* 手机端使用flexbox布局搜索容器 */
  .mobile-container {
    display: flex;
    align-items: center;
    flex-direction: row;
    margin-bottom: 10px;
    margin-left: 10px;
    flex-grow: 1;
    max-width: calc(100% - 40px);
  }


  .search-result-item {
  border: 1px solid #ddd; /* 边框 */
  margin: 4px 0; /* 外层间距 */
  padding: 0; /* 无内边距 */
  background: #fff; /* 背景色 */
}

.search-result-item a {
  display: block;
  text-decoration: none;
  color: inherit;
}

.search-result-item div {
  padding: 3px 8px; /* 紧凑的内边距 */
  margin: 0; /* 无外边距 */
  line-height: 1.3; /* 紧凑的行高 */
  word-wrap: break-word; /* 允许长单词换行 */
  white-space: normal; /* 允许正常换行 */
}

.search-result-item div:first-child {
  border-bottom: 1px solid #eee; /* 标题和内容之间的分隔线 */
}


</style>

            <div class="main">
                <div class="container">
    <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">展开所有</a>
        <a onclick="go_top()">返回顶部</a>
        <a onclick="go_bottom()">返回底部</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? '展开所有' : '折叠所有';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>  
  <article class="post-wrap">
    <header class="post-header">
      <h1 class="post-title">07-分布式锁-redission</h1>
      
      <div class="post-meta">
         作者:
        <a itemprop="author" rel="author" href="/">老江湖</a>
         
        <span class="post-time">
          <br />日期:
          <a href="#"
            >十月 12, 2025&nbsp;&nbsp;0:00:00</a
          >
        </span>
         
        <span class="post-category"
          ><br />
          分类: 
          <a href="/categories/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/">黑马点评</a>
          
        </span>
        
      </div>
      
    </header>

    <div class="post-content"><h1 id="分布式锁-redission功能介绍和快速入门"><a href="#分布式锁-redission功能介绍和快速入门" class="headerlink" title="分布式锁-redission功能介绍和快速入门"></a>分布式锁-redission功能介绍和快速入门</h1><h4 id="一、引入背景：手动-Redis-锁的局限性"><a href="#一、引入背景：手动-Redis-锁的局限性" class="headerlink" title="一、引入背景：手动 Redis 锁的局限性"></a>一、引入背景：手动 Redis 锁的局限性</h4><p>基于 Redis <code>SETNX</code>手动实现的分布式锁，存在以下核心缺陷：</p>
<ul>
<li><strong>不可重入</strong>：同一线程无法多次获取同一把锁（如方法嵌套调用时，易导致死锁）。</li>
<li><strong>不可重试</strong>：获取锁失败后直接返回，无重试机制，高并发下成功率低。</li>
<li><strong>超时释放隐患</strong>：锁超时时间固定，若业务执行超时时长，锁会提前释放，引发并发安全问题。</li>
<li><strong>主从一致性问题</strong>：Redis 主从同步有延迟，主机宕机后从机升主，锁数据可能丢失，导致锁失效。</li>
</ul>
<h4 id="二、Redisson-是什么？"><a href="#二、Redisson-是什么？" class="headerlink" title="二、Redisson 是什么？"></a>二、Redisson 是什么？</h4><p>Redisson 是<strong>基于 Redis 的 Java 驻内存数据网格（In-Memory Data Grid）</strong>，不仅封装了 Redis 的基础操作，还提供丰富的<strong>分布式服务</strong>（如分布式锁、集合、对象等）。其中，<strong>分布式锁的增强实现</strong>解决了手动锁的缺陷，支持可重入、可重试、自动续期等企业级特性。</p>
<h4 id="三、Redisson-快速使用（以-“秒杀一人一单”-为例）"><a href="#三、Redisson-快速使用（以-“秒杀一人一单”-为例）" class="headerlink" title="三、Redisson 快速使用（以 “秒杀一人一单” 为例）"></a>三、Redisson 快速使用（以 “秒杀一人一单” 为例）</h4><h5 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.13.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 版本按需选择 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="2-配置-Redisson-客户端"><a href="#2-配置-Redisson-客户端" class="headerlink" title="2. 配置 Redisson 客户端"></a>2. 配置 Redisson 客户端</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">         <span class="comment">// 单节点配置（生产环境可替换为集群/哨兵配置）</span></span><br><span class="line">        config.useSingleServer()</span><br><span class="line">              .setAddress(<span class="string">&quot;redis://127.0.0.1:6379&quot;</span>) <span class="comment">// Redis地址</span></span><br><span class="line">              .setPassword(<span class="string">&quot;your-redis-password&quot;</span>) <span class="comment">// 若有密码</span></span><br><span class="line">              .setDatabase(<span class="number">0</span>); <span class="comment">// 数据库索引</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-业务中集成分布式锁"><a href="#3-业务中集成分布式锁" class="headerlink" title="3. 业务中集成分布式锁"></a>3. 业务中集成分布式锁</h5><p>以 “秒杀下单，限制一人一单” 为例，用 Redisson 锁替换手动锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IVoucherOrderService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.查询优惠券</span></span><br><span class="line">        <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">        <span class="comment">// 2.判断秒杀是否开始</span></span><br><span class="line">        <span class="keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">// 尚未开始</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.判断秒杀是否已经结束</span></span><br><span class="line">        <span class="keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">// 尚未开始</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.判断库存是否充足</span></span><br><span class="line">        <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 库存不足</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="comment">//创建锁对象 这个代码不用了，因为我们现在要使用分布式锁</span></span><br><span class="line">        <span class="comment">//SimpleRedisLock lock = new SimpleRedisLock(&quot;order:&quot; + userId, stringRedisTemplate);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取“用户维度”的分布式锁（锁Key：lock:order:用户ID）</span></span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:order:&quot;</span> + userId);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 尝试加锁：最多等待1秒，锁自动释放时间10秒</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;不允许重复下单&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 通过AOP代理执行事务方法（保证事务在锁的范围内）</span></span><br><span class="line">            <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">            <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 最终释放锁（无论业务成功/失败，避免锁泄漏）</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事务方法：创建订单（省略具体逻辑）</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="comment">// ...查询订单、扣减库存、创建订单等逻辑...</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">	<span class="keyword">synchronized</span>(userId.toString().intern())&#123;</span><br><span class="line">         <span class="comment">// 5.1.查询订单</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">        <span class="comment">// 5.2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 用户已经购买过了</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户已经购买过一次！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>) <span class="comment">// set stock = stock - 1</span></span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>) <span class="comment">// where id = ? and stock &gt; 0</span></span><br><span class="line">                .update();</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">// 扣减失败</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.创建订单</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">// 7.1.订单id</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        <span class="comment">// 7.2.用户id</span></span><br><span class="line">        voucherOrder.setUserId(userId);</span><br><span class="line">        <span class="comment">// 7.3.代金券id</span></span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        save(voucherOrder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.返回订单id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="四、Redisson-锁的核心优势"><a href="#四、Redisson-锁的核心优势" class="headerlink" title="四、Redisson 锁的核心优势"></a>四、Redisson 锁的核心优势</h4><ol>
<li><strong>可重入</strong>：支持同一线程多次获取同一把锁（内部通过 “线程 ID + 重入次数” 记录，避免方法嵌套导致的死锁）。</li>
<li><strong>可重试</strong>：<code>tryLock</code>支持 “等待时间”，期间自动重试获取锁，提升高并发下的成功率。</li>
<li><strong>自动续期（看门狗机制）</strong>：若业务执行时间超过锁的超时时间，Redisson 会<strong>自动延长锁的过期时间</strong>（默认每隔 30 秒续期一次，续期至 30 秒），保证业务执行期间锁不提前释放。</li>
<li><strong>主从一致性优化</strong>：通过 “红锁（RedLock）” 机制，应对 Redis 主从同步延迟问题（多节点加锁，多数节点成功才算加锁成功）。</li>
<li><strong>丰富的锁类型</strong>：除基础可重入锁，还支持公平锁、联锁、红锁、读写锁等，满足不同场景需求（如读多写少场景用<code>ReadWriteLock</code>提升并发）。</li>
</ol>
<h4 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h4><p>Redisson 是企业级分布式锁的优选方案，解决了手动基于 Redis 实现分布式锁的诸多缺陷。通过封装 “可重入、可重试、自动续期” 等完善的锁机制，为秒杀、订单等高并发场景提供了安全、高效的并发控制能力。</p>
<h1 id="可重入锁、锁重试、看门狗机制、MutiLock"><a href="#可重入锁、锁重试、看门狗机制、MutiLock" class="headerlink" title="可重入锁、锁重试、看门狗机制、MutiLock"></a>可重入锁、锁重试、看门狗机制、MutiLock</h1><h4 id="一、可重入锁原理"><a href="#一、可重入锁原理" class="headerlink" title="一、可重入锁原理"></a>一、可重入锁原理</h4><p>Redisson 通过 <strong>Redis Hash 结构</strong> 实现分布式可重入锁：</p>
<ul>
<li><p><strong>存储结构</strong>：以 “锁名称” 为大 Key，“<code>线程ID + 标识</code>” 为小 Key，<code>Value</code>为<strong>重入次数</strong>。</p>
<ul>
<li><table>
<thead>
<tr>
<th align="center">KEY</th>
<th align="center">VALUE</th>
</tr>
</thead>
<tbody><tr>
<td align="center">KEY(大key)</td>
<td align="center">field (小key)                    |                       value(重入次数)</td>
</tr>
<tr>
<td align="center">lock</td>
<td align="center">thread1                                                             1</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>加锁逻辑（Lua 脚本原子执行）：</p>
<ol>
<li>若锁不存在（大 Key 不存在），则创建 Hash 并设置<code>重入次数=1</code>，同时设置锁超时时间；</li>
<li>若锁已存在且小 Key 匹配（当前线程持有），则<code>重入次数+1</code>，并重置锁超时时间；</li>
<li>若锁已存在但小 Key 不匹配（其他线程持有），则返回锁的剩余超时时间，触发重试逻辑。</li>
</ol>
</li>
<li><p><strong>作用</strong>：支持线程在分布式场景下 “嵌套获取同一把锁”，避免嵌套调用导致的死锁，与<code>ReentrantLock</code>的可重入特性一致。</p>
</li>
</ul>
<h5 id="可重入锁示例（解决嵌套加锁问题）"><a href="#可重入锁示例（解决嵌套加锁问题）" class="headerlink" title="可重入锁示例（解决嵌套加锁问题）"></a>可重入锁示例（解决嵌套加锁问题）</h5><p><strong>场景</strong>：同一线程在嵌套方法中多次获取同一把锁，不会死锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLockDemo</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外层方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取锁（锁名称：&quot;reentrant:lock&quot;）</span></span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;reentrant:lock&quot;</span>);</span><br><span class="line">        lock.lock(); <span class="comment">// 加锁（默认启用看门狗机制，超时30秒自动续期）</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;外层方法获取锁成功&quot;</span>);</span><br><span class="line">            innerMethod(); <span class="comment">// 调用内层方法（会再次获取同一把锁）</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 释放锁（重入次数-1，最终减为0时真正释放）</span></span><br><span class="line">            System.out.println(<span class="string">&quot;外层方法释放锁&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内层方法（嵌套加锁）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">innerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;reentrant:lock&quot;</span>);</span><br><span class="line">        lock.lock(); <span class="comment">// 再次获取同一把锁（重入次数+1）</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;内层方法获取锁成功（可重入特性）&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 释放锁（重入次数-1）</span></span><br><span class="line">            System.out.println(<span class="string">&quot;内层方法释放锁&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>核心点</strong>：Redisson 通过 Hash 结构记录 “线程标识” 和 “重入次数”，支持同一线程多次加锁，避免死锁。</p>
<h4 id="二、重试、看门狗（WatchDog）机制"><a href="#二、重试、看门狗（WatchDog）机制" class="headerlink" title="二、重试、看门狗（WatchDog）机制"></a>二、重试、看门狗（WatchDog）机制</h4><h5 id="一、源码解析-抢锁与重试机制"><a href="#一、源码解析-抢锁与重试机制" class="headerlink" title="一、源码解析 抢锁与重试机制"></a>一、<u>源码</u>解析 抢锁与重试机制</h5><p><code>lock()</code>方法的核心逻辑是<strong>不断尝试获取锁，直到成功为止</strong>，具体流程如下：</p>
<ol>
<li><p><strong>初始抢锁判断</strong></p>
<p>首先通过<code>tryAcquire()</code>方法尝试获取锁，内部通过 Redis 命令判断锁的状态：</p>
<ul>
<li>若锁不存在：直接创建锁（记录当前线程 ID 和重入次数），返回<code>null</code>表示抢锁成功。</li>
<li>若锁已存在且属于当前线程：执行重入逻辑（增加重入次数），返回<code>null</code>表示重入成功。</li>
<li>若锁已存在且属于其他线程：返回锁的剩余过期时间（TTL），表示抢锁失败。</li>
</ul>
</li>
<li><p><strong>循环重试机制</strong></p>
<p>当<code>tryAcquire()</code>返回 TTL（抢锁失败）时，<code>lock()</code>方法会进入<code>while(true)</code>循环，不断重复调用<code>tryAcquire()</code>重试抢锁。</p>
<ul>
<li>重试间隔会根据锁的剩余 TTL 动态调整（避免无效自旋浪费资源）。</li>
<li>直到成功获取锁（返回<code>null</code>）才会退出循环，保证最终一定能拿到锁（只要持有锁的线程最终会释放）。</li>
</ul>
</li>
</ol>
<h5 id="二、源码解析-WatchDog（看门狗）机制"><a href="#二、源码解析-WatchDog（看门狗）机制" class="headerlink" title="二、源码解析 WatchDog（看门狗）机制"></a>二、<u>源码</u>解析 WatchDog（看门狗）机制</h5><p>WatchDog解决 “<strong>业务执行时间 &gt; 锁超时时间</strong>” 导致的锁提前释放问题，Redisson 提供自动续期机制：</p>
<ul>
<li><p><strong>触发条件</strong></p>
<p>仅当使用<strong>无参<code>lock()</code>方法</strong>时启用（此时<code>leaseTime = -1</code>）。若调用带参<code>lock(leaseTime)</code>（指定过期时间），则不启用 WatchDog，锁会在<code>leaseTime</code>后自动释放。</p>
</li>
<li><p><strong>默认配置</strong></p>
<p>看门狗的默认超时时间为 30 秒（可通过<code>lockWatchdogTimeout</code>配置），即初始锁的过期时间为 30 秒。</p>
</li>
<li><p><strong>续约逻辑</strong></p>
<p>当抢锁成功后，通过<code>scheduleExpirationRenewal()</code>开启续约任务，核心是<code>renewExpiration()</code>方法：</p>
<ul>
<li>启动一个定时任务，每隔<code>internalLockLeaseTime / 3</code>（即 10 秒）执行一次。</li>
<li>任务逻辑：调用<code>renewExpirationAsync()</code>通过 Redis 命令将锁的过期时间重新设置为 30 秒。</li>
<li>若续约成功，递归调用<code>renewExpiration()</code>，继续设置下一个 10 秒后的定时任务，形成 “无限续约”。</li>
</ul>
</li>
<li><p><strong>自动终止条件</strong></p>
<ul>
<li>当线程释放锁（调用<code>unlock()</code>）时，会从<code>EXPIRATION_RENEWAL_MAP</code>中移除对应的续约任务，停止续约。</li>
<li>若持有锁的线程宕机，定时任务无法继续执行，续约终止，锁会在 30 秒后自动过期释放，避免死锁</li>
</ul>
</li>
</ul>
<h5 id="三、核心逻辑总结"><a href="#三、核心逻辑总结" class="headerlink" title="三、核心逻辑总结"></a>三、核心逻辑总结</h5><ol>
<li><strong>抢锁与重试</strong>：通过<code>while(true)</code>循环不断调用<code>tryAcquire()</code>，直到成功获取锁，确保最终能拿到锁。</li>
<li><strong>WatchDog 续约</strong>：无参<code>lock()</code>时，默认 30 秒过期，每 10 秒自动续约一次，保证业务未完成时锁不会提前释放。</li>
<li><strong>安全性保障</strong>：线程宕机后续约终止，锁自动过期；显式释放锁时终止续约，避免资源泄露</li>
</ol>
<h5 id="四、看门狗机制示例（自动续期，防止锁提前释放）"><a href="#四、看门狗机制示例（自动续期，防止锁提前释放）" class="headerlink" title="四、看门狗机制示例（自动续期，防止锁提前释放）"></a>四、看门狗机制示例（自动续期，防止锁提前释放）</h5><p><strong>场景</strong>：业务执行时间较长（超过初始锁超时时间），锁会自动续期，保证业务完成前不释放。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WatchDogDemo</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">longTimeBusiness</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;watchdog:lock&quot;</span>);</span><br><span class="line">        <span class="comment">// 无参lock()：默认启用看门狗，初始超时30秒，每10秒自动续期</span></span><br><span class="line">        lock.lock(); </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;获取锁成功，开始执行长时间业务...&quot;</span>);</span><br><span class="line">            <span class="comment">// 模拟业务执行40秒（超过初始30秒超时）</span></span><br><span class="line">            Thread.sleep(<span class="number">40000</span>); </span><br><span class="line">            System.out.println(<span class="string">&quot;业务执行完毕&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 业务完成后手动释放锁</span></span><br><span class="line">            System.out.println(<span class="string">&quot;释放锁&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>核心点</strong>：</p>
<ul>
<li>若业务未执行完，Redisson 会每隔 10 秒自动将锁超时时间重置为 30 秒（无需手动续期）；</li>
<li>若线程宕机，看门狗线程也会终止，锁最终会超时释放（避免死锁）。</li>
</ul>
<h4 id="三、MultiLock（红锁）原理"><a href="#三、MultiLock（红锁）原理" class="headerlink" title="三、MultiLock（红锁）原理"></a>三、MultiLock（红锁）原理</h4><p>为解决 Redis<strong>主从同步延迟</strong>导致的锁丢失问题（如主机宕机后，从机升主但未同步锁数据），Redisson 提供多节点加锁的<code>MultiLock</code>：</p>
<ul>
<li><strong>核心逻辑</strong>：要求在<strong>多个独立的 Redis 节点</strong>（非主从架构）上同时加锁，只有<strong>超过半数节点加锁成功</strong>，才算整体加锁成功；释放时，所有节点的锁都会被释放。</li>
<li><strong>可靠性保证</strong>：即使部分 Redis 节点故障，只要多数节点正常，就能保证锁的安全性（类似 “分布式共识”）。</li>
<li><strong>适用场景</strong>：对锁可靠性要求极高的场景（如金融交易），通过多节点冗余提升锁的容错性。</li>
</ul>
<h5 id="MultiLock-示例（解决主从一致性问题）"><a href="#MultiLock-示例（解决主从一致性问题）" class="headerlink" title="MultiLock 示例（解决主从一致性问题）"></a>MultiLock 示例（解决主从一致性问题）</h5><p><strong>场景</strong>：通过多节点加锁，确保 Redis 主从切换时锁不丢失（需部署多个独立 Redis 节点）。</p>
<p><strong>1. 配置多节点 Redisson 客户端</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RedissonClient <span class="title function_">redissonMultiNodeClient</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">    <span class="comment">// 配置3个独立的Redis节点（非主从关系）</span></span><br><span class="line">    config.useClusterServers()</span><br><span class="line">          .addNodeAddress(</span><br><span class="line">              <span class="string">&quot;redis://127.0.0.1:6379&quot;</span>,</span><br><span class="line">              <span class="string">&quot;redis://127.0.0.1:6380&quot;</span>,</span><br><span class="line">              <span class="string">&quot;redis://127.0.0.1:6381&quot;</span></span><br><span class="line">          );</span><br><span class="line">    <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 使用 MultiLock</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiLockDemo</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonMultiNodeClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">multiLockBusiness</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取3个节点的锁（锁名称需一致）</span></span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock1</span> <span class="operator">=</span> redissonMultiNodeClient.getLock(<span class="string">&quot;multi:lock&quot;</span>);</span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock2</span> <span class="operator">=</span> redissonMultiNodeClient.getLock(<span class="string">&quot;multi:lock&quot;</span>);</span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock3</span> <span class="operator">=</span> redissonMultiNodeClient.getLock(<span class="string">&quot;multi:lock&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建MultiLock（组合3个节点的锁）</span></span><br><span class="line">        <span class="type">RedissonMultiLock</span> <span class="variable">multiLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedissonMultiLock</span>(lock1, lock2, lock3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加锁：需所有节点加锁成功才算成功（默认超时30秒，启用看门狗）</span></span><br><span class="line">        multiLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MultiLock加锁成功，执行核心业务...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            multiLock.unlock(); <span class="comment">// 释放所有节点的锁</span></span><br><span class="line">            System.out.println(<span class="string">&quot;MultiLock释放锁&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>核心点</strong>：</p>
<ul>
<li>MultiLock 要求<strong>所有节点加锁成功</strong>才算整体加锁成功；</li>
<li>即使某一节点宕机，其他节点仍持有锁，避免锁丢失（适合高可靠性场景）。</li>
</ul>
<h3 id="常用-API-说明"><a href="#常用-API-说明" class="headerlink" title="常用 API 说明"></a>常用 API 说明</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>lock()</code></td>
<td>加锁（默认 30 秒超时，自动续期）</td>
<td><code>lock.lock();</code></td>
</tr>
<tr>
<td><code>lock(long leaseTime, TimeUnit unit)</code></td>
<td>加锁（指定超时时间，不自动续期）</td>
<td><code>lock.lock(10, TimeUnit.SECONDS);</code></td>
</tr>
<tr>
<td><code>tryLock(long waitTime, long leaseTime, TimeUnit unit)</code></td>
<td>尝试加锁（最多等待 waitTime，超时释放）</td>
<td><code>boolean success = lock.tryLock(5, 10, TimeUnit.SECONDS);</code></td>
</tr>
<tr>
<td><code>unlock()</code></td>
<td>释放锁</td>
<td><code>lock.unlock();</code></td>
</tr>
</tbody></table>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Redisson 通过<strong>可重入结构、看门狗续期、MultiLock 多节点共识</strong>，解决了手动 Redis 锁的 “不可重入、超时失控、主从一致性” 等缺陷，是企业级分布式锁的成熟解决方案。</p>
</div>

    
    <section class="post-copyright">
      
      <p class="copyright-item">
        <span>作者:</span>
        <span>老江湖</span>
      </p>
        
      <p class="copyright-item">
        <span>许可证:</span>
        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
      </p>
       
      <p class="copyright-item">
        <span>口号:</span>
        <span><strong>代码是开源的,我们只是它的搬运工。</strong></span>
      </p>
       
        <p class="copyright-item">
        <span>如果觉得我的文章对你有所帮助，请随意转载，感谢支持！</span>
      </p>
      
             
        <p class="copyright-item">
        <span>如有侵权请告知删除🙏</span>
      </p>
             
        <p class="copyright-item">
        <span>如果你有很好的想法💡，请务必联系我。 </span>
        <br>
         <span>2292360909@qq.com</span>
      </p>
    </section>
    
    <section class="post-tags">
      <div>
        <span>标签:</span>
        <span class="tag">
          
        </span>
      </div>
      <div>
        <a href="javascript:window.history.back();">返回</a>
        <span>· </span>
        <a href="/">首页</a>
      </div>
    </section>
    <section class="post-nav">
      
      <a class="prev" rel="prev" href="/2025/10/12/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/05-%E4%BC%98%E6%83%A0%E5%8D%B7%E7%A7%92%E6%9D%80/"
        >05-优惠卷秒杀</a
      >
       
      <a class="next" rel="next" href="/2025/10/12/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/09-Redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"
        >09-Redis消息队列</a
      >
      
    </section>

    <!-- Giscus 评论区挂载点 -->
<div id="giscus-container" style="margin-top: 2.5rem;"></div>

<!-- Giscus 动态加载脚本：初始加载 + 明暗主题切换 -->
<script>
  function createGiscus(theme) {
    const giscusContainer = document.getElementById('giscus-container');
    if (!giscusContainer) return;

    // 清除旧的评论 iframe
    giscusContainer.innerHTML = '';

    const script = document.createElement('script');
    script.src = 'https://giscus.app/client.js';

    // 替换为你的 GitHub 仓库信息（格式：username/repo）
    script.setAttribute('data-repo', 'meisijiya/meisijiya.github.io');

   // 替换为你的 repo-id 和 category-id（在 giscus.app 配置页面生成）
    script.setAttribute('data-repo-id', 'R_kgDOPwTrpQ');
    script.setAttribute('data-category', 'Announcements');
    script.setAttribute('data-category-id', 'DIC_kwDOPwTrpc4CviGR');

    // 其他常规推荐设置
    script.setAttribute('data-mapping', 'pathname');           // 用页面路径匹配评论帖
    script.setAttribute('data-strict', '0');                   // 若无匹配帖则创建新帖
    script.setAttribute('data-reactions-enabled', '1');        // 启用表情反应
    script.setAttribute('data-emit-metadata', '0');            // 不输出元数据
    script.setAttribute('data-input-position', 'top');         // 输入框在评论上方
    script.setAttribute('data-theme', theme);                
    script.setAttribute('data-lang', 'zh-CN');                 // 中文界面
    script.setAttribute('crossorigin', 'anonymous');           // 跨域资源安全
    script.async = true;                                       
     
    giscusContainer.appendChild(script);
  }

  function getCurrentTheme() {
    return document.body.classList.contains('dark-theme') ? 'dark' : 'light';
  }

  document.addEventListener('DOMContentLoaded', () => {
    // 页面首次加载，根据当前主题挂载评论
    createGiscus(getCurrentTheme());

    // 监听按钮点击切换主题 → 重载评论区
    const buttons = [
      document.querySelector('.toggleBtn'),
      document.getElementById('mobile-toggle-theme')
    ];
    buttons.forEach(btn => {
      if (!btn) return;
      btn.addEventListener('click', () => {
        setTimeout(() => {
          createGiscus(getCurrentTheme());
        }, 400); // 稍作延迟，确保 class 切换完毕
      });
    });

    // 监听 body class 改变（保险方案）
    const observer = new MutationObserver(() => {
      createGiscus(getCurrentTheme());
    });
    observer.observe(document.body, { attributes: true, attributeFilter: ['class'] });
  });
</script>

  </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 老江湖 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>
<script src="/js/code-copy.js"></script>


    </div>
</body>
<!-- umami -->
<script defer src="https://cloud.umami.is/script.js" data-website-id="91b923f2-ff2d-43d0-ba5f-bc348d82426a"></script>
</html>