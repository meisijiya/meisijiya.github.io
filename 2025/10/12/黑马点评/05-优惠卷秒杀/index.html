<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="老江湖">


    <meta name="subtitle" content="记录进入房间门后的美好">


    <meta name="description" content="一年前，孤苦伶仃的老江湖，偶然间发现一处房间门，推门而入，从此进入了充满幸福的世界。">


    <meta name="keywords" content="老江湖,博客,房间门">


<title>05-优惠卷秒杀 | 欢迎来到老江湖的博客</title>



    <link rel="icon" href="/images/%E9%87%91%E6%AF%9B.png?_t=1758006391547">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    
    <link rel="stylesheet" href="/css/search.css">
    

<!-- highlight.js 样式（默认亮色） -->
<link id="hljs-theme" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/github.css">
<!-- highlight.js 自动上色功能 -->
<script src="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/lib/highlight.min.js"></script>
<script>hljs.highlightAll();</script>

<link rel="stylesheet" href="/css/custom.css">



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 7.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const pagebody = document.getElementsByTagName('body')[0]

            function setTheme(status) {

                if (status === 'dark') {
                    window.sessionStorage.theme = 'dark'
                    pagebody.classList.add('dark-theme');

                } else if (status === 'light') {
                    window.sessionStorage.theme = 'light'
                    pagebody.classList.remove('dark-theme');
                }
            };

            setTheme(window.sessionStorage.theme)
        })();
    </script>

    <div class="wrapper">
        <header>
  <nav class="navbar">
    <div class="container">
      <div class="navbar-header header-logo">
        <a href="/">老江湖的博客</a>
      </div>
      <div class="menu navbar-right">
        <!-- 在电脑端的导航链接区域添加搜索功能 -->
        <div class="search-container">
          <a href="javascript:;" onclick="toggleSearchInput()">🔍</a>
          <input
            type="text"
            id="nav-search-input-desktop"
            class="nav-search-input"
            placeholder="想知道我什么秘密呢，搜搜看吧"
            oninput="navSearch(this)"
          />
          <div id="nav-search-result-desktop" class="nav-search-result"></div>
        </div>

        
        <a class="menu-item" href="/archives">归档</a>
        
        <a class="menu-item" href="/category">分类</a>
        
        <a class="menu-item" href="/tag">标签</a>
        
        <a class="menu-item" href="/Timer">任务计时器</a>
        
        <a class="menu-item" href="/timeLine">时间线</a>
        
        <a class="menu-item" href="/tongji">网站统计</a>
        
        <a class="menu-item" href="/about">关于</a>
        

        <input id="switch_default" type="checkbox" class="switch_default" />
        <label for="switch_default" class="toggleBtn"></label>
      </div>
    </div>
  </nav>

  
  <nav class="navbar-mobile" id="nav-mobile">
    <div class="container">
      <div class="navbar-header">
        <div>
          <a href="/">老江湖的博客</a
          ><a id="mobile-toggle-theme">·&nbsp;Light</a>
        </div>

        <div class="menu-toggle" onclick="mobileBtn()">
          <svg
            class="menu-icon"
            xmlns="http://www.w3.org/2000/svg"
            width="32"
            height="32"
            viewBox="0 0 24 24"
          >
            <path
              fill="currentColor"
              d="M4.5 17.27q-.213 0-.356-.145T4 16.768t.144-.356t.356-.143h15q.213 0 .356.144q.144.144.144.357t-.144.356t-.356.143zm0-4.77q-.213 0-.356-.144T4 11.999t.144-.356t.356-.143h15q.213 0 .356.144t.144.357t-.144.356t-.356.143zm0-4.77q-.213 0-.356-.143Q4 7.443 4 7.23t.144-.356t.356-.143h15q.213 0 .356.144T20 7.23t-.144.356t-.356.144z"
            />
          </svg>
          <svg
            class="close-icon"
            xmlns="http://www.w3.org/2000/svg"
            width="32"
            height="32"
            viewBox="0 0 24 24"
          >
            <!-- Icon from Material Symbols Light by Google - https://github.com/google/material-design-icons/blob/master/LICENSE -->
            <path
              fill="currentColor"
              d="m12 12.708l-5.246 5.246q-.14.14-.344.15t-.364-.15t-.16-.354t.16-.354L11.292 12L6.046 6.754q-.14-.14-.15-.344t.15-.364t.354-.16t.354.16L12 11.292l5.246-5.246q.14-.14.345-.15q.203-.01.363.15t.16.354t-.16.354L12.708 12l5.246 5.246q.14.14.15.345q.01.203-.15.363t-.354.16t-.354-.16z"
            />
          </svg>
        </div>
      </div>

      <div class="menu" id="mobile-menu">
        
        <a class="menu-item" href="/archives">归档</a>
        
        <a class="menu-item" href="/category">分类</a>
        
        <a class="menu-item" href="/tag">标签</a>
        
        <a class="menu-item" href="/Timer">任务计时器</a>
        
        <a class="menu-item" href="/timeLine">时间线</a>
        
        <a class="menu-item" href="/tongji">网站统计</a>
        
        <a class="menu-item" href="/about">关于</a>
        
        <!-- 手机模式搜索框 -->
        <div class="search-container mobile-container">
          <a class="menu-item" href="javascript:;" onclick="toggleSearchInput()"
            >🔍</a
          >
          <input
            type="text"
            id="nav-search-input-mobile"
            class="nav-search-input"
            placeholder="想知道我什么秘密呢，搜搜看吧"
            oninput="navSearch(this)"
          />
          <div id="nav-search-result-mobile" class="nav-search-result"></div>
        </div>
      </div>
    </div>
  </nav>
</header>
<script>
  var mobileBtn = function f() {
    var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
    var mobileMenu = document.getElementById("mobile-menu");
    if (toggleMenu.classList.contains("active")) {
      toggleMenu.classList.remove("active");
      mobileMenu.classList.remove("active");
    } else {
      toggleMenu.classList.add("active");
      mobileMenu.classList.add("active");
    }
  };

  function toggleSearchInput() {
    const inputs = document.querySelectorAll(".nav-search-input");
    const results = document.querySelectorAll(".nav-search-result");
    inputs.forEach((input) => {
      input.classList.toggle("active");
      if (input.classList.contains("active")) input.focus();
    });
    results.forEach((r) => (r.style.display = "none"));
  }

  // 点击外部区域隐藏搜索框和结果容器的函数
  function handleClickOutsideSearch(event) {
    const searchContainers = document.querySelectorAll(".search-container");
    searchContainers.forEach((container) => {
      const searchInput = container.querySelector(".nav-search-input");
      const searchIcon = container.querySelector("a");

      // 如果点击的元素不是搜索输入框或搜索图标，则隐藏搜索框和结果容器
      if (
        !searchInput.contains(event.target) &&
        !searchIcon.contains(event.target)
      ) {
        searchInput.classList.remove("active");
        searchInput.value = ""
        // 根据输入框ID确定对应的结果容器
        let resultContainer;
        if (searchInput.id === "nav-search-input-mobile") {
          // 移动端结果容器
          resultContainer = document.querySelector(
            ".navbar-mobile .nav-search-result"
          );
        } else {
          // 桌面端结果容器
          resultContainer = document.getElementById(
            "nav-search-result-desktop"
          );
        }

        if (resultContainer) {
          resultContainer.style.display = "none";
          resultContainer.innerHTML = ""; // 清空结果容器内容
        }
      }
    });
  }

  // 添加全局点击事件监听器
  document.addEventListener("click", function (event) {
    handleClickOutsideSearch(event);
  });

  // 新增：搜索功能实现
  let searchData = []; // 全局变量存储搜索数据

  // 页面加载完成后获取搜索数据
  document.addEventListener("DOMContentLoaded", function () {
    fetch("/search.xml")
      .then((res) => res.text())
      .then((xmlText) => {
        const parser = new DOMParser();
        const xml = parser.parseFromString(xmlText, "text/xml");
        const entries = xml.getElementsByTagName("entry");
        for (let entry of entries) {
          searchData.push({
            title: entry.getElementsByTagName("title")[0]?.textContent || "",
            content:
              entry.getElementsByTagName("content")[0]?.textContent || "",
            url: entry.getElementsByTagName("url")[0]?.textContent || "",
          });
        }
      })
      .catch((err) => {
        console.error("Failed to load search data:", err);
      });
  });

  // 新增：导航搜索方法
  function navSearch(inputElement) {
    const keyword = inputElement.value.trim().toLowerCase();
    // 查找对应的搜索结果容器
    let resultContainer;

    if (inputElement.id === "nav-search-input-desktop") {
      // 桌面端
      resultContainer = document.getElementById("nav-search-result-desktop");
    } else if (inputElement.id === "nav-search-input-mobile") {
      // 移动端
      resultContainer =
        inputElement.parentNode.querySelector(".nav-search-result");
    }

    if (!resultContainer) return;

    resultContainer.innerHTML = "";

    if (!keyword) {
      resultContainer.style.display = "none";
      return;
    }

    // 显示结果容器
    resultContainer.style.display = "block";

    // 过滤搜索数据
    const results = searchData.filter(
      (data) =>
        (data.title && data.title.toLowerCase().includes(keyword)) ||
        (data.content && data.content.toLowerCase().includes(keyword))
    );

    if (results.length === 0) {
      resultContainer.innerHTML =
        '<p class="no-result">没有结果哟，换个关键词试试吧</p>';
      return;
    }

    // 限制显示结果数量
    const maxResults = 10;
    const limitedResults = results.slice(0, maxResults);

    // 构建结果HTML
    const html = limitedResults
      .map((item) => {
        // 提取包含关键字的内容片段
        let contentSnippet = "";
        if (item.content) {
          // 找到包含关键字的内容片段
          const contentLower = item.content.toLowerCase();
          const keywordIndex = contentLower.indexOf(keyword);

          // 提取关键字前后的内容
          const start = Math.max(0, keywordIndex - 3 * keyword.length);
          const end = Math.min(
            item.content.length,
            keywordIndex + 3 * keyword.length
          );
          contentSnippet = item.content.substring(start, end);
        // 高亮关键字
      const keywordRegex = new RegExp(`(${keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
      contentSnippet = contentSnippet.replace(
        keywordRegex,
        "<mark>$1</mark>"
      );
        }

        return `<div class="search-result-item">
  <a href="${item.url}">
    <div>标题：${item.title}</div>
    <div>内容：${contentSnippet}</div>
  </a>
</div>`;
      })
      .join("");
    resultContainer.innerHTML = html;
  }
</script>
<style>
  /* 手机端使用flexbox布局搜索容器 */
  .mobile-container {
    display: flex;
    align-items: center;
    flex-direction: row;
    margin-bottom: 10px;
    margin-left: 10px;
    flex-grow: 1;
    max-width: calc(100% - 40px);
  }


  .search-result-item {
  border: 1px solid #ddd; /* 边框 */
  margin: 4px 0; /* 外层间距 */
  padding: 0; /* 无内边距 */
  background: #fff; /* 背景色 */
}

.search-result-item a {
  display: block;
  text-decoration: none;
  color: inherit;
}

.search-result-item div {
  padding: 3px 8px; /* 紧凑的内边距 */
  margin: 0; /* 无外边距 */
  line-height: 1.3; /* 紧凑的行高 */
  word-wrap: break-word; /* 允许长单词换行 */
  white-space: normal; /* 允许正常换行 */
}

.search-result-item div:first-child {
  border-bottom: 1px solid #eee; /* 标题和内容之间的分隔线 */
}


</style>

            <div class="main">
                <div class="container">
    <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">展开所有</a>
        <a onclick="go_top()">返回顶部</a>
        <a onclick="go_bottom()">返回底部</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? '展开所有' : '折叠所有';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>  
  <article class="post-wrap">
    <header class="post-header">
      <h1 class="post-title">05-优惠卷秒杀</h1>
      
      <div class="post-meta">
         作者:
        <a itemprop="author" rel="author" href="/">老江湖</a>
         
        <span class="post-time">
          <br />日期:
          <a href="#"
            >十月 12, 2025&nbsp;&nbsp;0:00:00</a
          >
        </span>
         
        <span class="post-category"
          ><br />
          分类: 
          <a href="/categories/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/">黑马点评</a>
          
        </span>
        
      </div>
      
    </header>

    <div class="post-content"><h1 id="基于Redis的全局唯一ID生成器"><a href="#基于Redis的全局唯一ID生成器" class="headerlink" title="基于Redis的全局唯一ID生成器"></a>基于Redis的全局唯一ID生成器</h1><h3 id="一、业务背景：为什么需要全局唯一-ID？"><a href="#一、业务背景：为什么需要全局唯一-ID？" class="headerlink" title="一、业务背景：为什么需要全局唯一 ID？"></a>一、业务背景：为什么需要全局唯一 ID？</h3><p>在黑马点评的<strong>优惠券订单业务</strong>中，订单表若使用 MySQL 自增 ID，会面临两大问题：</p>
<ol>
<li><strong>安全性不足</strong>：自增 ID 规律性强，易被猜测出业务信息（如单日订单量）。</li>
<li><strong>扩展性不足</strong>：MySQL 单表容量建议不超过 500 万，分库分表后，自增 ID 无法保证<strong>全局唯一性</strong>。</li>
</ol>
<h3 id="二、全局唯一-ID-生成器的核心特性"><a href="#二、全局唯一-ID-生成器的核心特性" class="headerlink" title="二、全局唯一 ID 生成器的核心特性"></a>二、全局唯一 ID 生成器的核心特性</h3><p>一个可靠的全局 ID 生成器需满足以下特性：</p>
<ul>
<li><strong>唯一性</strong>：分布式系统中 ID 绝对不重复。</li>
<li><strong>高可用</strong>：生成 ID 的服务 &#x2F; 组件稳定，不影响业务流程。</li>
<li><strong>高性能</strong>：支撑高并发场景，生成 ID 的速度足够快。</li>
<li><strong>递增性</strong>：ID 尽量递增（利于数据库索引，如 MySQL B + 树的写入性能）。</li>
<li><strong>安全性</strong>：ID 无明显规律，避免泄露业务信息。</li>
</ul>
<h3 id="三、基于-Redis-的全局-ID-结构设计"><a href="#三、基于-Redis-的全局-ID-结构设计" class="headerlink" title="三、基于 Redis 的全局 ID 结构设计"></a>三、基于 Redis 的全局 ID 结构设计</h3><p>为兼顾 “递增性” 和 “安全性”，采用 <strong>“时间戳 + 序列号”</strong> 的组合结构：</p>
<ul>
<li><strong>符号位（1bit）</strong>：固定为 0，保证 ID 为正数。</li>
<li><strong>时间戳（31bit）</strong>：以<strong>秒</strong>为单位的相对时间（减去起始时间戳<code>1640995200L</code>，即 2022-01-01 00:00:00），可使用约 69 年。</li>
<li><strong>序列号（32bit）</strong>：秒内的计数器，由 Redis 原子自增生成，每秒可生成 (2^{32})（约 42 亿）个 ID，支撑超高并发。</li>
</ul>
<h3 id="四、Redis-实现全局唯一-ID-的代码剖析"><a href="#四、Redis-实现全局唯一-ID-的代码剖析" class="headerlink" title="四、Redis 实现全局唯一 ID 的代码剖析"></a>四、Redis 实现全局唯一 ID 的代码剖析</h3><p>核心类 <code>RedisIdWorker</code> 利用 Redis 的<strong>原子自增</strong>保证序列号唯一性，结合时间戳实现递增：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisIdWorker</span> &#123;</span><br><span class="line">    <span class="comment">// 起始时间戳（2022-01-01 00:00:00的秒数）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">BEGIN_TIMESTAMP</span> <span class="operator">=</span> <span class="number">1640995200L</span>;</span><br><span class="line">    <span class="comment">// 序列号的位数（32位，决定每秒最大生成量）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisIdWorker</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">(String keyPrefix)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 生成时间戳（相对起始时间的秒数，缩短位数）</span></span><br><span class="line">        <span class="comment">//LocalDateTime.now() 返回当前日期和时间（精确到纳秒）</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="comment">//toEpochSecond(ZoneOffset.UTC) 将当前时间转换为 UTC 时区的秒级时间戳（即从 1970 年 1 月 1 日至当前时间的总秒数）。</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">nowSecond</span> <span class="operator">=</span> now.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> nowSecond - BEGIN_TIMESTAMP;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 生成序列号（按“年:月:日”分键，保证每天的序列号独立自增）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy:MM:dd&quot;</span>));</span><br><span class="line">        <span class="comment">// Redis increment是原子操作，保证同一秒内序列号唯一</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="string">&quot;icr:&quot;</span> + keyPrefix + <span class="string">&quot;:&quot;</span> + date);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 拼接时间戳和序列号（位运算：时间戳左移32位，与序列号按位或）</span></span><br><span class="line">        <span class="keyword">return</span> timestamp &lt;&lt; COUNT_BITS | count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代码关键逻辑解析："><a href="#代码关键逻辑解析：" class="headerlink" title="代码关键逻辑解析："></a>代码关键逻辑解析：</h4><ul>
<li><strong>时间戳处理</strong>：通过 “当前秒数 - 起始秒数”，将时间戳范围缩短，减少位数占用，同时保证递增性。</li>
<li><strong>序列号生成</strong>：利用 Redis <code>INCR</code> 原子性，按 “日期” 分键，确保<strong>同一秒内</strong>序列号唯一且递增；跨天自动重置，避免序列号溢出。</li>
<li><strong>位运算拼接</strong>：<code>timestamp &lt;&lt; COUNT_BITS</code> 将时间戳左移 32 位，空出低 32 位给序列号；再通过<code>|</code>（按位或）将两者合并为一个<code>long</code>型 ID，保证结构紧凑。</li>
</ul>
<h3 id="五、高并发测试与CountDownLatch的作用"><a href="#五、高并发测试与CountDownLatch的作用" class="headerlink" title="五、高并发测试与CountDownLatch的作用"></a>五、高并发测试与<code>CountDownLatch</code>的作用</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_844085127/article/details/149069677">多线程之CountDownLatch详解_多线程 countdownlatch-CSDN博客</a></p>
<p>测试代码用于验证<strong>高并发下 ID 生成的性能与唯一性</strong>，其中<code>CountDownLatch</code>是关键：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testIdWorker</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 初始化计数器为300（表示需要300个线程完成后，才解除阻塞）</span></span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">300</span>);</span><br><span class="line">    <span class="comment">// 每个线程生成100个ID</span></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;id = &quot;</span> + id);</span><br><span class="line">        &#125;</span><br><span class="line">        latch.countDown(); <span class="comment">// 线程完成，计数器减1</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 启动300个线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;</span><br><span class="line">        es.submit(task);</span><br><span class="line">    &#125;</span><br><span class="line">    latch.await(); <span class="comment">// 主线程阻塞，直到计数器为0</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;总耗时 = &quot;</span> + (end - begin));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CountDownLatch的作用："><a href="#CountDownLatch的作用：" class="headerlink" title="CountDownLatch的作用："></a><code>CountDownLatch</code>的作用：</h4><ul>
<li>同步多线程执行：让<strong>所有子线程（300 个）都生成完 ID 后</strong>，主线程再统计总耗时，从而准确评估高并发性能。</li>
<li>核心方法：<ul>
<li><code>countDown()</code>：子线程完成任务后调用，计数器减 1。</li>
<li><code>await()</code>：主线程调用，阻塞直到计数器为 0，再继续执行。</li>
</ul>
</li>
</ul>
<h3 id="六、知识点拓展与对比"><a href="#六、知识点拓展与对比" class="headerlink" title="六、知识点拓展与对比"></a>六、知识点拓展与对比</h3><h4 id="1-Redis-方案的优势"><a href="#1-Redis-方案的优势" class="headerlink" title="1. Redis 方案的优势"></a>1. Redis 方案的优势</h4><ul>
<li><strong>高性能</strong>：Redis 单实例 QPS 可达 10 万级，<code>INCR</code>原子操作足够快。</li>
<li><strong>高可用</strong>：可通过 Redis 集群（如主从、哨兵、Cluster）保证服务不宕机。</li>
<li><strong>防重复 &#x2F; 时钟问题</strong>：依赖 Redis 原子自增，无 “雪花算法” 的时钟回拨风险。</li>
</ul>
<h4 id="2-其他全局-ID-方案对比"><a href="#2-其他全局-ID-方案对比" class="headerlink" title="2. 其他全局 ID 方案对比"></a>2. 其他全局 ID 方案对比</h4><table>
<thead>
<tr>
<th>方案</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>MySQL 自增</td>
<td>简单易实现</td>
<td>规律性强、分库分表后不唯一</td>
</tr>
<tr>
<td>UUID</td>
<td>全局唯一</td>
<td>无递增性、存储占空间、索引差</td>
</tr>
<tr>
<td>雪花算法（Snowflake）</td>
<td>递增、性能高</td>
<td>依赖机器时钟，时钟回拨会重复</td>
</tr>
<tr>
<td>分布式中间件（如 Leaf）</td>
<td>功能完善、性能稳定</td>
<td>架构复杂，需额外维护中间件</td>
</tr>
</tbody></table>
<p>综上，黑马点评选择<strong>Redis 实现全局唯一 ID</strong>，是兼顾 “轻量、高性能、高可用、唯一性” 的折中方案，特别适合优惠券、订单等高并发场景。</p>
<h1 id="优惠卷类型、秒杀下单业务及其超卖问题"><a href="#优惠卷类型、秒杀下单业务及其超卖问题" class="headerlink" title="优惠卷类型、秒杀下单业务及其超卖问题"></a>优惠卷类型、秒杀下单业务及其超卖问题</h1><h3 id="一、优惠券的类型与新增逻辑"><a href="#一、优惠券的类型与新增逻辑" class="headerlink" title="一、优惠券的类型与新增逻辑"></a>一、优惠券的类型与新增逻辑</h3><p>黑马点评的优惠券分为<strong>普通券</strong>和<strong>秒杀券</strong>，对应不同表结构与新增逻辑：</p>
<table>
<thead>
<tr>
<th>优惠券类型</th>
<th>表结构</th>
<th>新增逻辑</th>
</tr>
</thead>
<tbody><tr>
<td>普通券</td>
<td><code>tb_voucher</code>（存基础优惠信息）</td>
<td>直接调用<code>save</code>方法，持久化到数据库即可。</td>
</tr>
<tr>
<td>秒杀券</td>
<td><code>tb_voucher</code> + <code>tb_seckill_voucher</code>（额外存库存、秒杀时间）</td>
<td>需<strong>事务性</strong>完成 3 步：1. 保存基础优惠信息到<code>tb_voucher</code>；2. 保存秒杀专属信息（库存、时间等）到<code>tb_seckill_voucher</code>；3. <strong>库存预热到 Redis</strong>（将库存值写入 Redis，为后续秒杀做准备）。</td>
</tr>
</tbody></table>
<p>**新增普通卷代码：  **VoucherController</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">addVoucher</span><span class="params">(<span class="meta">@RequestBody</span> Voucher voucher)</span> &#123;</span><br><span class="line">    voucherService.save(voucher);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(voucher.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>新增秒杀卷代码：</strong></p>
<p><strong>VoucherController</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;seckill&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">addSeckillVoucher</span><span class="params">(<span class="meta">@RequestBody</span> Voucher voucher)</span> &#123;</span><br><span class="line">    voucherService.addSeckillVoucher(voucher);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(voucher.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>VoucherServiceImpl</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSeckillVoucher</span><span class="params">(Voucher voucher)</span> &#123;</span><br><span class="line">    <span class="comment">// 保存优惠券</span></span><br><span class="line">    save(voucher);</span><br><span class="line">    <span class="comment">// 保存秒杀信息</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeckillVoucher</span>();</span><br><span class="line">    seckillVoucher.setVoucherId(voucher.getId());</span><br><span class="line">    seckillVoucher.setStock(voucher.getStock());</span><br><span class="line">    seckillVoucher.setBeginTime(voucher.getBeginTime());</span><br><span class="line">    seckillVoucher.setEndTime(voucher.getEndTime());</span><br><span class="line">    seckillVoucherService.save(seckillVoucher);</span><br><span class="line">    <span class="comment">// 保存秒杀库存到Redis中</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二、秒杀下单的核心业务流程"><a href="#二、秒杀下单的核心业务流程" class="headerlink" title="二、秒杀下单的核心业务流程"></a>二、秒杀下单的核心业务流程</h3><p>用户点击 “秒杀抢购” 时，后端执行以下步骤：</p>
<ol>
<li><strong>校验秒杀时间</strong>：判断当前时间是否在秒杀的<code>beginTime</code>和<code>endTime</code>之间，否则返回 “秒杀未开始 &#x2F; 已结束”。</li>
<li><strong>校验库存</strong>：查询<code>tb_seckill_voucher</code>中的库存，若库存不足则返回 “库存不足”。</li>
<li><strong>扣减库存</strong>：通过数据库更新操作扣减库存（此环节是 “库存超卖问题” 的核心场景）。</li>
<li><strong>创建订单</strong>：用 Redis 全局 ID 生成器生成唯一订单 ID，将订单信息（用户 ID、优惠券 ID 等）持久化到<code>tb_voucher_order</code>。</li>
</ol>
<p>VoucherOrderServiceImpl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询优惠券</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">    <span class="comment">// 2.判断秒杀是否开始</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.判断秒杀是否已经结束</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.判断库存是否充足</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 库存不足</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5，扣减库存</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock= stock -1&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update();</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="comment">//扣减库存</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.创建订单</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    <span class="comment">// 6.1.订单id</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line">    <span class="comment">// 6.2.用户id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    voucherOrder.setUserId(userId);</span><br><span class="line">    <span class="comment">// 6.3.代金券id</span></span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    save(voucherOrder);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、库存超卖问题与解决方案"><a href="#三、库存超卖问题与解决方案" class="headerlink" title="三、库存超卖问题与解决方案"></a>三、库存超卖问题与解决方案</h3><h4 id="1-问题分析"><a href="#1-问题分析" class="headerlink" title="1. 问题分析"></a>1. 问题分析</h4><p>高并发下，多个线程同时执行 “<strong>查询库存 → 扣减库存</strong>” 流程，会导致 “库存被重复扣减”，最终库存为负（超卖）。</p>
<p>示例：线程 1 查询库存为 1（未扣减），线程 2 也查询到库存为 1，随后两线程都执行扣减，最终库存变成 - 1，违反业务规则。</p>
<h4 id="2-解决方案：悲观锁-vs-乐观锁"><a href="#2-解决方案：悲观锁-vs-乐观锁" class="headerlink" title="2. 解决方案：悲观锁 vs 乐观锁"></a>2. 解决方案：悲观锁 vs 乐观锁</h4><table>
<thead>
<tr>
<th>锁类型</th>
<th>思路</th>
<th>优缺点</th>
</tr>
</thead>
<tbody><tr>
<td>悲观锁</td>
<td>认为线程安全问题一定会发生，操作前先加锁（如<code>synchronized</code>、<code>Lock</code>），强制线程<strong>串行执行</strong>。</td>
<td>优点：逻辑简单，绝对保证数据安全；缺点：串行执行导致<strong>性能大幅下降</strong>，高并发下吞吐量极低。</td>
</tr>
<tr>
<td>乐观锁</td>
<td>认为线程安全问题不一定发生，<strong>不加锁</strong>，而是通过 “版本控制” 或 “条件校验”，在<strong>更新时验证数据是否被篡改</strong>。</td>
<td>优点：非阻塞，高并发性能好；缺点：需处理更新失败的重试或降级逻辑。</td>
</tr>
</tbody></table>
<h4 id="3-乐观锁的具体实现（课程案例）"><a href="#3-乐观锁的具体实现（课程案例）" class="headerlink" title="3. 乐观锁的具体实现（课程案例）"></a>3. 乐观锁的具体实现（课程案例）</h4><p>乐观锁的核心是 “<strong>更新时带条件，验证数据未被篡改</strong>”。课程中给出两种方式：</p>
<ul>
<li><p><strong>方式 1：基于 “库存相等” 的条件更新</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">seckillVoucherService.update()</span><br><span class="line">    .setSql(<span class="string">&quot;stock= stock -1&quot;</span>)</span><br><span class="line">    .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)</span><br><span class="line">    .eq(<span class="string">&quot;stock&quot;</span>, voucher.getStock()) <span class="comment">// 预期库存与查询时一致</span></span><br><span class="line">    .update();</span><br></pre></td></tr></table></figure>

<ul>
<li>问题：高并发下，只有 1 个线程能命中 “库存相等” 的条件，其余线程全部失败，<strong>成功率极低</strong>。<ul>
<li>失败的原因在于：在使用乐观锁过程中假设100个线程同时都拿到了100的库存，然后大家一起去进行扣减，但是100个人中只有1个人能扣减成功，其他的人在处理时，他们在扣减时，库存已经被修改过了，所以此时其他线程都会失败</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>方式 2：基于 “库存大于 0” 的条件更新</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">seckillVoucherService.update()</span><br><span class="line">    .setSql(<span class="string">&quot;stock= stock -1&quot;</span>)</span><br><span class="line">    .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)</span><br><span class="line">    .gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>) <span class="comment">// 只要库存&gt;0，就尝试扣减</span></span><br><span class="line">    .update();</span><br></pre></td></tr></table></figure>

<ul>
<li>优化：只要库存有剩余，就允许扣减，<strong>成功率更高</strong>，且能避免超卖（<code>gt(&quot;stock&quot;, 0)</code>保证扣减时库存至少为 1）。</li>
</ul>
</li>
</ul>
<h4 id="4-扩展：LongAdder-优化-CAS-自旋压力"><a href="#4-扩展：LongAdder-优化-CAS-自旋压力" class="headerlink" title="4. 扩展：LongAdder 优化 CAS 自旋压力"></a>4. 扩展：LongAdder 优化 CAS 自旋压力</h4><p>Java 8 提供的<code>LongAdder</code>是<code>AtomicLong</code>的优化版，用于<strong>高并发计数场景</strong>：</p>
<p><img src="https://oss.itbaima.cn/hub/928/image-202509258j8hrcfsz.png" alt="image-202509258j8hrcfsz"></p>
<ul>
<li>原理：多线程竞争激烈时，<code>LongAdder</code>会<strong>拆分多个 “cell（分段计数器）”</strong>，让线程分散到不同 cell 更新，减少 CAS 自旋冲突；最终结果由<code>base</code>（基础计数器）和所有<code>cell</code>累加得到。</li>
<li>优势：相比<code>AtomicLong</code>的<strong>全局 CAS 自旋</strong>，<code>LongAdder</code>通过 “**<u>分段 CAS</u>**” 降低竞争，大幅提升高并发下的计数性能。</li>
</ul>
<h3 id="四、核心总结"><a href="#四、核心总结" class="headerlink" title="四、核心总结"></a>四、核心总结</h3><p>秒杀场景的关键挑战是 **“高并发下的库存安全” 与 “性能” 的平衡 **。黑马点评通过：</p>
<ul>
<li>乐观锁（“库存&gt; 0 条件更新”）解决超卖问题，兼顾数据安全与高并发性能；</li>
<li>Redis 预热库存、全局唯一 ID 生成等技术，为秒杀的 “高可用、高性能” 提供支撑。</li>
</ul>
<h1 id="一人一单"><a href="#一人一单" class="headerlink" title="一人一单"></a>一人一单</h1><h2 id="单机环境"><a href="#单机环境" class="headerlink" title="单机环境"></a>单机环境</h2><h3 id="一、业务需求：优惠券-“一人一单”"><a href="#一、业务需求：优惠券-“一人一单”" class="headerlink" title="一、业务需求：优惠券 “一人一单”"></a>一、业务需求：优惠券 “一人一单”</h3><p>为避免用户重复抢购同一张优惠券，需限制<strong>同一用户对同一优惠券仅能创建一次订单</strong>。</p>
<h3 id="二、核心问题与演进"><a href="#二、核心问题与演进" class="headerlink" title="二、核心问题与演进"></a>二、核心问题与演进</h3><h4 id="1-初始问题：并发下重复下单"><a href="#1-初始问题：并发下重复下单" class="headerlink" title="1. 初始问题：并发下重复下单"></a>1. 初始问题：并发下重复下单</h4><p>VoucherOrderServiceImpl  </p>
<p><strong>初步代码：增加一人一单逻辑</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询优惠券</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">    <span class="comment">// 2.判断秒杀是否开始</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.判断秒杀是否已经结束</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.判断库存是否充足</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 库存不足</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.一人一单逻辑</span></span><br><span class="line">    <span class="comment">// 5.1.用户id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">    <span class="comment">// 5.2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 用户已经购买过了</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户已经购买过一次！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6，扣减库存</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock= stock -1&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update();</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="comment">//扣减库存</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//7.创建订单</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    <span class="comment">// 7.1.订单id</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line"></span><br><span class="line">    voucherOrder.setUserId(userId);</span><br><span class="line">    <span class="comment">// 7.3.代金券id</span></span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    save(voucherOrder);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>直接在秒杀逻辑中添加 “查询用户是否已下单” 的校验，但高并发时，多个线程同时查询到 “无订单”，会同时执行下单，导致重复。</li>
</ul>
<h4 id="2-尝试方案：加悲观锁（但粒度太粗）"><a href="#2-尝试方案：加悲观锁（但粒度太粗）" class="headerlink" title="2. 尝试方案：加悲观锁（但粒度太粗）"></a>2. 尝试方案：加悲观锁（但粒度太粗）</h4><p>给初始方案封装了一个createVoucherOrder方法，同时为了确保他线程安全，在方法上添加了一把synchronized 锁</p>
<p>给 <code>createVoucherOrder</code> 方法加 <code>synchronized</code>，但所有用户共享<strong>同一把锁</strong>，请求串行执行，性能极差。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">         <span class="comment">// 5.1.查询订单</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">        <span class="comment">// 5.2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 用户已经购买过了</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户已经购买过一次！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>) <span class="comment">// set stock = stock - 1</span></span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>) <span class="comment">// where id = ? and stock &gt; 0</span></span><br><span class="line">                .update();</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">// 扣减失败</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.创建订单</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">// 7.1.订单id</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        <span class="comment">// 7.2.用户id</span></span><br><span class="line">        voucherOrder.setUserId(userId);</span><br><span class="line">        <span class="comment">// 7.3.代金券id</span></span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        save(voucherOrder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.返回订单id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-优化锁粒度：用户维度的锁"><a href="#3-优化锁粒度：用户维度的锁" class="headerlink" title="3. 优化锁粒度：用户维度的锁"></a>3. 优化锁粒度：用户维度的锁</h4><p>使用 <code>userId.toString().intern()</code> 作为锁对象：</p>
<ul>
<li><code>userId.toString()</code> 生成的是<u>新字符串对象</u>，不同线程的同一用户 ID 会因 “新对象” 导致锁无效；</li>
<li>调用 <code>intern()</code> 后，字符串从<strong>常量池</strong>获取唯一实例，保证 “同一用户竞争同一把锁，不同用户不互斥”，大幅提升并发度。</li>
</ul>
<h4 id="4-事务与锁的冲突：代理与事务范围"><a href="#4-事务与锁的冲突：代理与事务范围" class="headerlink" title="4. 事务与锁的冲突：代理与事务范围"></a>4. 事务与锁的冲突：代理与事务范围</h4><h5 id="一、Spring-事务的-“代理生效”-原理"><a href="#一、Spring-事务的-“代理生效”-原理" class="headerlink" title="一、Spring 事务的 “代理生效” 原理"></a>一、Spring 事务的 “代理生效” 原理</h5><p><code>@Transactional</code> 是通过 <strong>代理模式</strong> 实现的（JDK 动态代理或 CGLIB 子类代理）：</p>
<ul>
<li>当调用被 <code>@Transactional</code> 修饰的方法时，<strong>代理对象</strong> 会先启动事务，再执行目标方法，最后根据执行结果提交 &#x2F; 回滚事务。</li>
<li>如果直接通过 <code>this</code>（目标对象自身）调用事务方法，<strong>不会经过代理</strong>，事务逻辑不会生效（相当于普通方法调用）。</li>
</ul>
<table>
<thead>
<tr>
<th>“代理失效“场景</th>
<th>解决方案</th>
</tr>
</thead>
<tbody><tr>
<td>内部方法调用</td>
<td>注入自身代理对象（<code>AopContext.currentProxy()</code>）</td>
</tr>
<tr>
<td>非 public 方法</td>
<td>改为 public 方法</td>
</tr>
<tr>
<td>final&#x2F;static 方法</td>
<td>重构为实例方法</td>
</tr>
<tr>
<td>非 Spring Bean</td>
<td>添加 <code>@Component</code> 等注解</td>
</tr>
<tr>
<td>多线程调用</td>
<td>使用 <code>@Async</code> + 事务传播</td>
</tr>
<tr>
<td>异常类型不匹配</td>
<td>显式指定 <code>rollbackFor</code></td>
</tr>
</tbody></table>
<h5 id="二、“锁在方法内”-的冲突问题"><a href="#二、“锁在方法内”-的冲突问题" class="headerlink" title="二、“锁在方法内” 的冲突问题"></a>二、“锁在方法内” 的冲突问题</h5><p>若锁的范围仅包裹 “目标方法内部代码”，而事务由代理控制，会出现以下时序问题：</p>
<ol>
<li>线程 A 获取锁，调用代理方法 → 代理启动事务，执行目标方法（扣减库存、创建订单）。</li>
<li>线程 A 执行完目标方法，<strong>释放锁</strong> → 但代理的 “事务提交” 还未执行（事务提交在代理方法的最后一步）。</li>
<li>线程 B 获取锁，调用代理方法 → 此时线程 A 的事务未提交，线程 B 查不到线程 A 未提交的订单，会重复下单。</li>
</ol>
<h5 id="三、解决方案：用代理对象保证-“锁包裹事务”"><a href="#三、解决方案：用代理对象保证-“锁包裹事务”" class="headerlink" title="三、解决方案：用代理对象保证 “锁包裹事务”"></a>三、解决方案：用代理对象保证 “锁包裹事务”</h5><p>通过 <code>AopContext.currentProxy()</code> 获取<strong>当前对象的代理实例</strong>，再通过代理调用事务方法，确保：</p>
<ul>
<li>锁的范围 <strong>包含整个事务过程</strong>（从 “事务启动” 到 “事务提交 &#x2F; 回滚”）。</li>
<li>事务通过代理生效，且在锁的保护下执行，避免 “锁释放后事务才提交” 导致的脏读。</li>
</ul>
<p>代码示例的核心逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (userId.toString().intern()) &#123; <span class="comment">// 1. 加用户维度的锁</span></span><br><span class="line">    <span class="comment">// 2. 获取当前Service的代理对象（含事务增强逻辑）</span></span><br><span class="line">    <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">    <span class="comment">// 3. 通过代理调用方法 → 事务在代理中启动，且被锁包裹</span></span><br><span class="line">    <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="四、关键结论"><a href="#四、关键结论" class="headerlink" title="四、关键结论"></a>四、关键结论</h5><ul>
<li>Spring 事务的生效依赖<strong>代理调用</strong>，直接 <code>this.方法()</code> 会绕过代理，导致事务失效。</li>
<li>要让 “锁保护事务的原子性”，需通过 <code>AopContext</code> 获取代理对象，保证<strong>锁的范围包含整个事务过程</strong>，解决 “锁释放后事务才提交” 的并发问题。</li>
</ul>
<h3 id="三、最终解决方案与代码剖析"><a href="#三、最终解决方案与代码剖析" class="headerlink" title="三、最终解决方案与代码剖析"></a>三、最终解决方案与代码剖析</h3><h4 id="1-核心逻辑：锁-事务-代理协同"><a href="#1-核心逻辑：锁-事务-代理协同" class="headerlink" title="1. 核心逻辑：锁 + 事务 + 代理协同"></a>1. 核心逻辑：锁 + 事务 + 代理协同</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">// 省略“秒杀时间校验、库存校验”等逻辑...</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 用用户ID的intern字符串做锁，保证同一用户竞争同一把锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (userId.toString().intern()) &#123;</span><br><span class="line">        <span class="comment">// 获取当前Service的代理对象（含事务增强）</span></span><br><span class="line">        <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">        <span class="comment">// 通过代理调用，保证事务在锁内执行</span></span><br><span class="line">        <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 1. 校验：查询用户是否已下单</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户已下单，无法重复购买&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 扣减库存（乐观锁，防止超卖）</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)</span><br><span class="line">            .gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>) <span class="comment">// 库存&gt;0才扣减</span></span><br><span class="line">            .update();</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 创建订单</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    order.setId(redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>));</span><br><span class="line">    order.setUserId(userId);</span><br><span class="line">    order.setVoucherId(voucherId);</span><br><span class="line">    save(order);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok(order.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-关键技术点剖析"><a href="#2-关键技术点剖析" class="headerlink" title="2. 关键技术点剖析"></a>2. 关键技术点剖析</h4><ul>
<li><strong><code>intern()</code> 保证锁的唯一性</strong>：<code>String.intern()</code> 从常量池返回唯一实例，确保同一用户 ID 的锁对象唯一，实现 “用户维度排他锁”，既保证安全又减少锁竞争。</li>
<li><strong><code>AopContext.currentProxy()</code> 协同事务与锁</strong>：通过代理对象调用 <code>createVoucherOrder</code>，让<strong>事务的完整生命周期（包括提交）被包含在锁内</strong>，避免 “锁释放后事务才提交” 导致的脏读。</li>
<li><strong>事务 + 乐观锁的双重保障</strong>：<code>@Transactional</code> 保证 “查询 - 扣减库存 - 创建订单” 的原子性；扣减库存时用乐观锁（<code>gt(&quot;stock&quot;, 0)</code>），进一步防止库存超卖。</li>
</ul>
<h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>“一人一单” 需求的核心是 **“并发安全、性能、事务一致性” 的平衡 **：</p>
<ul>
<li>用<strong>用户维度的悲观锁</strong>（<code>synchronized + intern</code>）解决重复下单的并发问题，同时控制锁粒度提升性能；</li>
<li>用<strong>Spring 代理与事务的协同</strong>（<code>AopContext</code>）保证 “锁内事务完整”，避免脏读；</li>
<li>结合<strong>乐观锁扣减库存</strong>，双重保障数据一致性。</li>
</ul>
<p>单机模式下，通过：</p>
<ol>
<li><code>userId.toString().intern()</code> 实现用户级别的锁粒度控制；</li>
<li><code>@EnableAspectJAutoProxy(exposeProxy = true)</code> 暴露代理对象，确保事务在锁内生效；</li>
<li>结合 <code>synchronized</code> 与乐观锁，可解决 “一人一单” 的并发安全问题。</li>
</ol>
<p>但集群环境需进一步引入分布式锁，突破单机锁的范围限制。</p>
<h3 id="单机环境下-“一人一单”-的完整配置"><a href="#单机环境下-“一人一单”-的完整配置" class="headerlink" title="单机环境下 “一人一单” 的完整配置"></a>单机环境下 “一人一单” 的完整配置</h3><p>要让 <code>synchronized(userId.toString().intern())</code> 结合事务正常生效，需完成以下配置，核心是<strong>暴露代理对象</strong>以便在锁内调用事务方法：</p>
<h4 id="1-添加-AspectJ-依赖（支持-AOP-代理暴露）"><a href="#1-添加-AspectJ-依赖（支持-AOP-代理暴露）" class="headerlink" title="1. 添加 AspectJ 依赖（支持 AOP 代理暴露）"></a>1. 添加 AspectJ 依赖（支持 AOP 代理暴露）</h4><p>AspectJ 是 Spring AOP 的底层依赖之一，用于支持代理对象的暴露。在 <code>pom.xml</code> 中添加：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 版本可根据Spring Boot版本适配 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-启动类开启代理暴露"><a href="#2-启动类开启代理暴露" class="headerlink" title="2. 启动类开启代理暴露"></a>2. 启动类开启代理暴露</h4><p>在 Spring Boot 启动类上添加 <code>@EnableAspectJAutoProxy(exposeProxy = true)</code>，作用是：</p>
<ul>
<li>允许 Spring 将代理对象暴露到 <code>ThreadLocal</code> 中，使得在目标方法内部可通过 <code>AopContext.currentProxy()</code> 获取代理实例。</li>
<li>确保 <code>@Transactional</code> 注解的事务逻辑能通过代理正常生效（避免 <code>this.方法()</code> 调用导致的事务失效）。</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(exposeProxy = true)</span> <span class="comment">// 暴露代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DianPingApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DianPingApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="集群环境下的并发问题"><a href="#集群环境下的并发问题" class="headerlink" title="集群环境下的并发问题"></a>集群环境下的并发问题</h2><h3 id="一、单机环境：synchronized-为什么能工作？"><a href="#一、单机环境：synchronized-为什么能工作？" class="headerlink" title="一、单机环境：synchronized 为什么能工作？"></a>一、单机环境：<code>synchronized</code> 为什么能工作？</h3><p><code>synchronized</code> 是 JVM 提供的<strong>内置互斥锁</strong>，其作用范围是<strong>单个 JVM 进程内部</strong>。</p>
<ul>
<li>同一 JVM 内的多个线程，会竞争<strong>同一个锁对象</strong>（比如方法锁的 “类对象”、对象锁的 “实例对象”）。</li>
<li>只有拿到锁的线程能进入 “临界区”（如 “查询订单→判断是否存在→插入新订单” 的逻辑），其他线程会被阻塞，从而保证<strong>单机内的并发安全</strong>（比如 “一人一单” 在单机下不会重复下单）。</li>
</ul>
<h3 id="二、集群环境：synchronized-为什么会失效？"><a href="#二、集群环境：synchronized-为什么会失效？" class="headerlink" title="二、集群环境：synchronized 为什么会失效？"></a>二、集群环境：<code>synchronized</code> 为什么会失效？</h3><p>集群是<strong>多台服务器 &#x2F; 多个 JVM 进程</strong>同时提供服务（比如部署 2 个 Tomcat 实例，各自对应独立的 JVM）。此时 <code>synchronized</code> 的 “进程内锁” 特性，会导致锁无法跨 JVM 生效：</p>
<ul>
<li>服务器 A 的 Tomcat（JVM 1）里，线程 1 和线程 2 会竞争<strong>JVM 1 内的锁</strong>，能保证互斥。</li>
<li>服务器 B 的 Tomcat（JVM 2）里，线程 3 和线程 4 会竞争<strong>JVM 2 内的锁</strong>，也能保证互斥。</li>
<li>但 <strong>JVM 1 的锁和 JVM 2 的锁是 “各自独立” 的</strong>！线程 1（JVM 1）和线程 3（JVM 2）可以同时拿到 “各自 JVM 内的锁”，进而同时进入 “查询订单→插入” 的逻辑 —— 这就会绕过 “一人一单” 的限制，导致<strong>重复下单</strong>。</li>
</ul>
<h3 id="三、如何解决？用「分布式锁」实现跨-JVM-的全局互斥"><a href="#三、如何解决？用「分布式锁」实现跨-JVM-的全局互斥" class="headerlink" title="三、如何解决？用「分布式锁」实现跨 JVM 的全局互斥"></a>三、如何解决？用「分布式锁」实现<strong>跨 JVM 的全局互斥</strong></h3><p>分布式锁的核心思想是：让<strong>所有 JVM &#x2F; 服务实例</strong>共享一个 “全局锁资源”，从而实现跨进程的互斥。</p>
<p>常用的分布式锁实现方案（以 Redis 为例）：</p>
<ol>
<li><p><strong>利用 Redis 原子性命令（如 <code>SETNX</code>）</strong>：</p>
<ul>
<li>当需要加锁时，向 Redis 发送 <code>SETNX lock:user:123 &quot;随机值&quot;</code>（<code>lock:user:123</code> 是锁的 key，“随机值” 用于后续释放锁时的唯一性验证），并设置<strong>过期时间</strong>（避免死锁）。</li>
<li><code>SETNX</code> 是 “Set if Not Exists” 的缩写：如果 key 不存在，就设置成功（返回 1），表示 “拿到锁”；如果 key 已存在，设置失败（返回 0），表示 “锁被占用”。</li>
</ul>
</li>
<li><p><strong>执行临界区逻辑</strong>：</p>
<p>只有拿到锁的线程（或服务实例），才能执行 “查询订单→判断→插入” 的逻辑。</p>
</li>
<li><p><strong>释放锁</strong>：</p>
<p>执行完逻辑后，需要<strong>原子性地删除锁</strong>（避免多线程环境下误删其他线程的锁）。通常用 Lua 脚本实现：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>（验证 “锁的值是否为自己的随机值”，是为了防止 “锁过期后被其他线程误删” 的情况。）</p>
</li>
</ol>
<h3 id="四、总结-1"><a href="#四、总结-1" class="headerlink" title="四、总结"></a>四、总结</h3><ul>
<li>单机下，<code>synchronized</code> 靠 “JVM 内共享锁对象” 保证互斥。</li>
<li>集群下，多 JVM 各自的锁不共享，导致 <code>synchronized</code> 失效。</li>
<li>分布式锁通过 <strong>Redis 等中间件提供 “全局共享的锁资源”</strong>，让所有服务实例竞争同一把锁，从而实现跨进程的并发安全（如 “一人一单” 的全局控制）。</li>
</ul>
</div>

    
    <section class="post-copyright">
      
      <p class="copyright-item">
        <span>作者:</span>
        <span>老江湖</span>
      </p>
        
      <p class="copyright-item">
        <span>许可证:</span>
        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
      </p>
       
      <p class="copyright-item">
        <span>口号:</span>
        <span><strong>代码是开源的,我们只是它的搬运工。</strong></span>
      </p>
       
        <p class="copyright-item">
        <span>如果觉得我的文章对你有所帮助，请随意转载，感谢支持！</span>
      </p>
      
             
        <p class="copyright-item">
        <span>如有侵权请告知删除🙏</span>
      </p>
             
        <p class="copyright-item">
        <span>如果你有很好的想法💡，请务必联系我。 </span>
        <br>
         <span>2292360909@qq.com</span>
      </p>
    </section>
    
    <section class="post-tags">
      <div>
        <span>标签:</span>
        <span class="tag">
          
        </span>
      </div>
      <div>
        <a href="javascript:window.history.back();">返回</a>
        <span>· </span>
        <a href="/">首页</a>
      </div>
    </section>
    <section class="post-nav">
      
      <a class="prev" rel="prev" href="/2025/10/12/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/06-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"
        >06-分布式锁</a
      >
       
      <a class="next" rel="next" href="/2025/10/12/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/07-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-redission/"
        >07-分布式锁-redission</a
      >
      
    </section>

    <!-- Giscus 评论区挂载点 -->
<div id="giscus-container" style="margin-top: 2.5rem;"></div>

<!-- Giscus 动态加载脚本：初始加载 + 明暗主题切换 -->
<script>
  function createGiscus(theme) {
    const giscusContainer = document.getElementById('giscus-container');
    if (!giscusContainer) return;

    // 清除旧的评论 iframe
    giscusContainer.innerHTML = '';

    const script = document.createElement('script');
    script.src = 'https://giscus.app/client.js';

    // 替换为你的 GitHub 仓库信息（格式：username/repo）
    script.setAttribute('data-repo', 'meisijiya/meisijiya.github.io');

   // 替换为你的 repo-id 和 category-id（在 giscus.app 配置页面生成）
    script.setAttribute('data-repo-id', 'R_kgDOPwTrpQ');
    script.setAttribute('data-category', 'Announcements');
    script.setAttribute('data-category-id', 'DIC_kwDOPwTrpc4CviGR');

    // 其他常规推荐设置
    script.setAttribute('data-mapping', 'pathname');           // 用页面路径匹配评论帖
    script.setAttribute('data-strict', '0');                   // 若无匹配帖则创建新帖
    script.setAttribute('data-reactions-enabled', '1');        // 启用表情反应
    script.setAttribute('data-emit-metadata', '0');            // 不输出元数据
    script.setAttribute('data-input-position', 'top');         // 输入框在评论上方
    script.setAttribute('data-theme', theme);                
    script.setAttribute('data-lang', 'zh-CN');                 // 中文界面
    script.setAttribute('crossorigin', 'anonymous');           // 跨域资源安全
    script.async = true;                                       
     
    giscusContainer.appendChild(script);
  }

  function getCurrentTheme() {
    return document.body.classList.contains('dark-theme') ? 'dark' : 'light';
  }

  document.addEventListener('DOMContentLoaded', () => {
    // 页面首次加载，根据当前主题挂载评论
    createGiscus(getCurrentTheme());

    // 监听按钮点击切换主题 → 重载评论区
    const buttons = [
      document.querySelector('.toggleBtn'),
      document.getElementById('mobile-toggle-theme')
    ];
    buttons.forEach(btn => {
      if (!btn) return;
      btn.addEventListener('click', () => {
        setTimeout(() => {
          createGiscus(getCurrentTheme());
        }, 400); // 稍作延迟，确保 class 切换完毕
      });
    });

    // 监听 body class 改变（保险方案）
    const observer = new MutationObserver(() => {
      createGiscus(getCurrentTheme());
    });
    observer.observe(document.body, { attributes: true, attributeFilter: ['class'] });
  });
</script>

  </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 老江湖 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>
<script src="/js/code-copy.js"></script>


    </div>
</body>
<!-- umami -->
<script defer src="https://cloud.umami.is/script.js" data-website-id="91b923f2-ff2d-43d0-ba5f-bc348d82426a"></script>
</html>