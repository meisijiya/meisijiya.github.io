<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="老江湖">


    <meta name="subtitle" content="记录进入房间门后的美好">


    <meta name="description" content="一年前，孤苦伶仃的老江湖，偶然间发现一处房间门，推门而入，从此进入了充满幸福的世界。">


    <meta name="keywords" content="老江湖,博客,房间门">


<title>06-分布式锁 | 欢迎来到老江湖的博客</title>



    <link rel="icon" href="/images/%E9%87%91%E6%AF%9B.png?_t=1758006391547">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    
    <link rel="stylesheet" href="/css/search.css">
    

<!-- highlight.js 样式（默认亮色） -->
<link id="hljs-theme" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/github.css">
<!-- highlight.js 自动上色功能 -->
<script src="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/lib/highlight.min.js"></script>
<script>hljs.highlightAll();</script>

<link rel="stylesheet" href="/css/custom.css">



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 7.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const pagebody = document.getElementsByTagName('body')[0]

            function setTheme(status) {

                if (status === 'dark') {
                    window.sessionStorage.theme = 'dark'
                    pagebody.classList.add('dark-theme');

                } else if (status === 'light') {
                    window.sessionStorage.theme = 'light'
                    pagebody.classList.remove('dark-theme');
                }
            };

            setTheme(window.sessionStorage.theme)
        })();
    </script>

    <div class="wrapper">
        <header>
  <nav class="navbar">
    <div class="container">
      <div class="navbar-header header-logo">
        <a href="/">老江湖的博客</a>
      </div>
      <div class="menu navbar-right">
        <!-- 在电脑端的导航链接区域添加搜索功能 -->
        <div class="search-container">
          <a href="javascript:;" onclick="toggleSearchInput()">🔍</a>
          <input
            type="text"
            id="nav-search-input-desktop"
            class="nav-search-input"
            placeholder="想知道我什么秘密呢，搜搜看吧"
            oninput="navSearch(this)"
          />
          <div id="nav-search-result-desktop" class="nav-search-result"></div>
        </div>

        
        <a class="menu-item" href="/archives">归档</a>
        
        <a class="menu-item" href="/category">分类</a>
        
        <a class="menu-item" href="/tag">标签</a>
        
        <a class="menu-item" href="/Timer">任务计时器</a>
        
        <a class="menu-item" href="/timeLine">时间线</a>
        
        <a class="menu-item" href="/tongji">网站统计</a>
        
        <a class="menu-item" href="/about">关于</a>
        

        <input id="switch_default" type="checkbox" class="switch_default" />
        <label for="switch_default" class="toggleBtn"></label>
      </div>
    </div>
  </nav>

  
  <nav class="navbar-mobile" id="nav-mobile">
    <div class="container">
      <div class="navbar-header">
        <div>
          <a href="/">老江湖的博客</a
          ><a id="mobile-toggle-theme">·&nbsp;Light</a>
        </div>

        <div class="menu-toggle" onclick="mobileBtn()">
          <svg
            class="menu-icon"
            xmlns="http://www.w3.org/2000/svg"
            width="32"
            height="32"
            viewBox="0 0 24 24"
          >
            <path
              fill="currentColor"
              d="M4.5 17.27q-.213 0-.356-.145T4 16.768t.144-.356t.356-.143h15q.213 0 .356.144q.144.144.144.357t-.144.356t-.356.143zm0-4.77q-.213 0-.356-.144T4 11.999t.144-.356t.356-.143h15q.213 0 .356.144t.144.357t-.144.356t-.356.143zm0-4.77q-.213 0-.356-.143Q4 7.443 4 7.23t.144-.356t.356-.143h15q.213 0 .356.144T20 7.23t-.144.356t-.356.144z"
            />
          </svg>
          <svg
            class="close-icon"
            xmlns="http://www.w3.org/2000/svg"
            width="32"
            height="32"
            viewBox="0 0 24 24"
          >
            <!-- Icon from Material Symbols Light by Google - https://github.com/google/material-design-icons/blob/master/LICENSE -->
            <path
              fill="currentColor"
              d="m12 12.708l-5.246 5.246q-.14.14-.344.15t-.364-.15t-.16-.354t.16-.354L11.292 12L6.046 6.754q-.14-.14-.15-.344t.15-.364t.354-.16t.354.16L12 11.292l5.246-5.246q.14-.14.345-.15q.203-.01.363.15t.16.354t-.16.354L12.708 12l5.246 5.246q.14.14.15.345q.01.203-.15.363t-.354.16t-.354-.16z"
            />
          </svg>
        </div>
      </div>

      <div class="menu" id="mobile-menu">
        
        <a class="menu-item" href="/archives">归档</a>
        
        <a class="menu-item" href="/category">分类</a>
        
        <a class="menu-item" href="/tag">标签</a>
        
        <a class="menu-item" href="/Timer">任务计时器</a>
        
        <a class="menu-item" href="/timeLine">时间线</a>
        
        <a class="menu-item" href="/tongji">网站统计</a>
        
        <a class="menu-item" href="/about">关于</a>
        
        <!-- 手机模式搜索框 -->
        <div class="search-container mobile-container">
          <a class="menu-item" href="javascript:;" onclick="toggleSearchInput()"
            >🔍</a
          >
          <input
            type="text"
            id="nav-search-input-mobile"
            class="nav-search-input"
            placeholder="想知道我什么秘密呢，搜搜看吧"
            oninput="navSearch(this)"
          />
          <div id="nav-search-result-mobile" class="nav-search-result"></div>
        </div>
      </div>
    </div>
  </nav>
</header>
<script>
  var mobileBtn = function f() {
    var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
    var mobileMenu = document.getElementById("mobile-menu");
    if (toggleMenu.classList.contains("active")) {
      toggleMenu.classList.remove("active");
      mobileMenu.classList.remove("active");
    } else {
      toggleMenu.classList.add("active");
      mobileMenu.classList.add("active");
    }
  };

  function toggleSearchInput() {
    const inputs = document.querySelectorAll(".nav-search-input");
    const results = document.querySelectorAll(".nav-search-result");
    inputs.forEach((input) => {
      input.classList.toggle("active");
      if (input.classList.contains("active")) input.focus();
    });
    results.forEach((r) => (r.style.display = "none"));
  }

  // 点击外部区域隐藏搜索框和结果容器的函数
  function handleClickOutsideSearch(event) {
    const searchContainers = document.querySelectorAll(".search-container");
    searchContainers.forEach((container) => {
      const searchInput = container.querySelector(".nav-search-input");
      const searchIcon = container.querySelector("a");

      // 如果点击的元素不是搜索输入框或搜索图标，则隐藏搜索框和结果容器
      if (
        !searchInput.contains(event.target) &&
        !searchIcon.contains(event.target)
      ) {
        searchInput.classList.remove("active");
        searchInput.value = ""
        // 根据输入框ID确定对应的结果容器
        let resultContainer;
        if (searchInput.id === "nav-search-input-mobile") {
          // 移动端结果容器
          resultContainer = document.querySelector(
            ".navbar-mobile .nav-search-result"
          );
        } else {
          // 桌面端结果容器
          resultContainer = document.getElementById(
            "nav-search-result-desktop"
          );
        }

        if (resultContainer) {
          resultContainer.style.display = "none";
          resultContainer.innerHTML = ""; // 清空结果容器内容
        }
      }
    });
  }

  // 添加全局点击事件监听器
  document.addEventListener("click", function (event) {
    handleClickOutsideSearch(event);
  });

  // 新增：搜索功能实现
  let searchData = []; // 全局变量存储搜索数据

  // 页面加载完成后获取搜索数据
  document.addEventListener("DOMContentLoaded", function () {
    fetch("/search.xml")
      .then((res) => res.text())
      .then((xmlText) => {
        const parser = new DOMParser();
        const xml = parser.parseFromString(xmlText, "text/xml");
        const entries = xml.getElementsByTagName("entry");
        for (let entry of entries) {
          searchData.push({
            title: entry.getElementsByTagName("title")[0]?.textContent || "",
            content:
              entry.getElementsByTagName("content")[0]?.textContent || "",
            url: entry.getElementsByTagName("url")[0]?.textContent || "",
          });
        }
      })
      .catch((err) => {
        console.error("Failed to load search data:", err);
      });
  });

  // 新增：导航搜索方法
  function navSearch(inputElement) {
    const keyword = inputElement.value.trim().toLowerCase();
    // 查找对应的搜索结果容器
    let resultContainer;

    if (inputElement.id === "nav-search-input-desktop") {
      // 桌面端
      resultContainer = document.getElementById("nav-search-result-desktop");
    } else if (inputElement.id === "nav-search-input-mobile") {
      // 移动端
      resultContainer =
        inputElement.parentNode.querySelector(".nav-search-result");
    }

    if (!resultContainer) return;

    resultContainer.innerHTML = "";

    if (!keyword) {
      resultContainer.style.display = "none";
      return;
    }

    // 显示结果容器
    resultContainer.style.display = "block";

    // 过滤搜索数据
    const results = searchData.filter(
      (data) =>
        (data.title && data.title.toLowerCase().includes(keyword)) ||
        (data.content && data.content.toLowerCase().includes(keyword))
    );

    if (results.length === 0) {
      resultContainer.innerHTML =
        '<p class="no-result">没有结果哟，换个关键词试试吧</p>';
      return;
    }

    // 限制显示结果数量
    const maxResults = 10;
    const limitedResults = results.slice(0, maxResults);

    // 构建结果HTML
    const html = limitedResults
      .map((item) => {
        // 提取包含关键字的内容片段
        let contentSnippet = "";
        if (item.content) {
          // 找到包含关键字的内容片段
          const contentLower = item.content.toLowerCase();
          const keywordIndex = contentLower.indexOf(keyword);

          // 提取关键字前后的内容
          const start = Math.max(0, keywordIndex - 3 * keyword.length);
          const end = Math.min(
            item.content.length,
            keywordIndex + 3 * keyword.length
          );
          contentSnippet = item.content.substring(start, end);
        // 高亮关键字
      const keywordRegex = new RegExp(`(${keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
      contentSnippet = contentSnippet.replace(
        keywordRegex,
        "<mark>$1</mark>"
      );
        }

        return `<div class="search-result-item">
  <a href="${item.url}">
    <div>标题：${item.title}</div>
    <div>内容：${contentSnippet}</div>
  </a>
</div>`;
      })
      .join("");
    resultContainer.innerHTML = html;
  }
</script>
<style>
  /* 手机端使用flexbox布局搜索容器 */
  .mobile-container {
    display: flex;
    align-items: center;
    flex-direction: row;
    margin-bottom: 10px;
    margin-left: 10px;
    flex-grow: 1;
    max-width: calc(100% - 40px);
  }


  .search-result-item {
  border: 1px solid #ddd; /* 边框 */
  margin: 4px 0; /* 外层间距 */
  padding: 0; /* 无内边距 */
  background: #fff; /* 背景色 */
}

.search-result-item a {
  display: block;
  text-decoration: none;
  color: inherit;
}

.search-result-item div {
  padding: 3px 8px; /* 紧凑的内边距 */
  margin: 0; /* 无外边距 */
  line-height: 1.3; /* 紧凑的行高 */
  word-wrap: break-word; /* 允许长单词换行 */
  white-space: normal; /* 允许正常换行 */
}

.search-result-item div:first-child {
  border-bottom: 1px solid #eee; /* 标题和内容之间的分隔线 */
}


</style>

            <div class="main">
                <div class="container">
    <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">展开所有</a>
        <a onclick="go_top()">返回顶部</a>
        <a onclick="go_bottom()">返回底部</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? '展开所有' : '折叠所有';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>  
  <article class="post-wrap">
    <header class="post-header">
      <h1 class="post-title">06-分布式锁</h1>
      
      <div class="post-meta">
         作者:
        <a itemprop="author" rel="author" href="/">老江湖</a>
         
        <span class="post-time">
          <br />日期:
          <a href="#"
            >十月 12, 2025&nbsp;&nbsp;0:00:00</a
          >
        </span>
         
        <span class="post-category"
          ><br />
          分类: 
          <a href="/categories/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/">黑马点评</a>
          
        </span>
        
      </div>
      
    </header>

    <div class="post-content"><h1 id="分布式锁的原理、实现分析"><a href="#分布式锁的原理、实现分析" class="headerlink" title="分布式锁的原理、实现分析"></a>分布式锁的原理、实现分析</h1><h3 id="一、分布式锁的背景：单机锁的局限性"><a href="#一、分布式锁的背景：单机锁的局限性" class="headerlink" title="一、分布式锁的背景：单机锁的局限性"></a>一、分布式锁的背景：单机锁的局限性</h3><p>单机模式下的 <code>synchronized</code>、JUC 锁（如 <code>ReentrantLock</code>）仅作用于<strong>单个 JVM 进程</strong>，无法在<strong>集群 &#x2F; 分布式环境</strong>（多服务器部署）下共享锁状态。若系统是集群部署，多进程间因锁不可见，会导致 “一人一单” 等并发安全逻辑失效，因此需要<strong>跨进程、多节点可见的分布式锁</strong>。</p>
<h3 id="二、Redis-分布式锁的核心原理"><a href="#二、Redis-分布式锁的核心原理" class="headerlink" title="二、Redis 分布式锁的核心原理"></a>二、Redis 分布式锁的核心原理</h3><p>利用 Redis 的 <strong><code>SETNX</code> 命令的 “互斥性”</strong> + <strong>超时释放机制</strong> 实现：</p>
<ul>
<li><strong>互斥性</strong>：<code>SETNX key value</code>（Set if Not Exists）命令的逻辑是：<strong>只有当 Key 不存在时，才会设置成功并返回 1</strong>；若 Key 已存在，设置失败返回 0。多进程竞争时，只有一个能成功创建 Key（即 “抢到锁”），保证 “串行执行”。</li>
<li><strong>超时释放</strong>：为避免进程异常（如宕机）导致锁无法释放，需给锁 Key 设置<strong>超时时间</strong>（如 <code>EX seconds</code>），确保锁能自动过期，防止死锁。</li>
</ul>
<h3 id="三、Redis-分布式锁的核心流程与实现"><a href="#三、Redis-分布式锁的核心流程与实现" class="headerlink" title="三、Redis 分布式锁的核心流程与实现"></a>三、Redis 分布式锁的核心流程与实现</h3><h4 id="1-获取锁（原子性操作是关键）"><a href="#1-获取锁（原子性操作是关键）" class="headerlink" title="1. 获取锁（原子性操作是关键）"></a>1. 获取锁（原子性操作是关键）</h4><p>需同时完成 “<code>SETNX</code> 占锁” 和 “设置超时时间”，否则可能出现 <strong>“锁创建成功但未设置超时，进程宕机导致锁永久占用”</strong> 的问题。</p>
<ul>
<li><p>推荐方案：使用 Redis 原子命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SET key value NX EX seconds</span><br><span class="line">------参数--------</span><br><span class="line">‌NX‌（Not eXists）</span><br><span class="line">仅当键key不存在时才执行设置操作，保证互斥性。若键已存在，则返回nil（相当于加锁失败）</span><br><span class="line">‌EX seconds‌</span><br><span class="line">设置键的过期时间（单位为秒），自动释放锁防止死锁。例如EX 30表示30秒后自动删除该键</span><br></pre></td></tr></table></figure>

<p>（或<code>PX milliseconds</code>），一次性完成 “互斥占锁 + 超时设置”。</p>
<ul>
<li>示例（Redis 命令）：<code>SET lock:order UUID NX EX 30</code>（尝试创建 <code>lock:order</code> 键，值为 UUID，仅当键不存在时成功，且超时 30 秒）。</li>
<li>逻辑：若返回 <code>OK</code>，表示获取锁成功，可执行业务；若返回 <code>nil</code>，表示锁已被占用，需等待或重试。</li>
</ul>
</li>
</ul>
<h4 id="2-释放锁（需避免-“误删他人锁”）"><a href="#2-释放锁（需避免-“误删他人锁”）" class="headerlink" title="2. 释放锁（需避免 “误删他人锁”）"></a>2. 释放锁（需避免 “误删他人锁”）</h4><p>业务执行完毕后，需删除锁 Key 让其他进程竞争。为避免 “进程 A 误删进程 B 的锁”（比如进程 A 锁超时后，进程 B 刚抢到锁，进程 A 执行 <code>DEL</code> 误删），需增加 <strong>“锁归属校验”</strong>：</p>
<ul>
<li><p>思路：占锁时，给 <code>value</code> 赋值为<strong>唯一标识</strong>（如 UUID）；释放前，先校验 <code>value</code> 是否与自身一致，再执行 <code>DEL</code>。</p>
</li>
<li><p>实现：通过<strong>Lua 脚本</strong>保证 “校验 + 删除” 的原子性（<u>Redis 执行 Lua 时是单线程的，不会被中断</u>）。<br><a target="_blank" rel="noopener" href="https://www.runoob.com/lua/lua-tutorial.html">Lua 教程 | 菜鸟教程</a></p>
<p>示例 Lua 脚本：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="四、Redis-分布式锁的特性与优势"><a href="#四、Redis-分布式锁的特性与优势" class="headerlink" title="四、Redis 分布式锁的特性与优势"></a>四、Redis 分布式锁的特性与优势</h3><table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>多进程可见</td>
<td>Redis 是独立服务，多进程（集群节点）共享其数据，锁状态全局可见。</td>
</tr>
<tr>
<td>互斥性</td>
<td><code>SETNX</code> 命令保证 “同一时间只有一个进程能抢到锁”。</td>
</tr>
<tr>
<td>高可用</td>
<td>Redis 支持主从、集群部署，保障锁服务不宕机。</td>
</tr>
<tr>
<td>高性能</td>
<td>Redis 是内存数据库，<code>SETNX</code>&#x2F;<code>DEL</code> 等操作是低延迟的原子操作，适合高并发。</td>
</tr>
<tr>
<td>安全性</td>
<td>超时时间避免 “死锁”；锁归属校验避免 “误删他人锁”，保障锁的安全释放。</td>
</tr>
</tbody></table>
<h3 id="五、与其他分布式锁方案的对比"><a href="#五、与其他分布式锁方案的对比" class="headerlink" title="五、与其他分布式锁方案的对比"></a>五、与其他分布式锁方案的对比</h3><p><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/zookeeper-tutorial.html">1.0 Zookeeper 教程 | 菜鸟教程</a></p>
<table>
<thead>
<tr>
<th>方案</th>
<th>互斥实现方式</th>
<th>高可用</th>
<th>高性能</th>
<th>安全性</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>Redis</td>
<td><code>SETNX</code> 命令</td>
<td>好</td>
<td>好</td>
<td>超时释放 + 归属校验保障</td>
<td>高并发场景（如秒杀、订单）</td>
</tr>
<tr>
<td>MySQL</td>
<td>数据库行锁 &#x2F; 表锁</td>
<td>好</td>
<td>一般</td>
<td>断开连接自动释放锁</td>
<td>并发度不高的场景</td>
</tr>
<tr>
<td>Zookeeper</td>
<td>临时节点 + Watcher 机制</td>
<td>好</td>
<td>一般</td>
<td>临时节点断开自动释放锁</td>
<td>一致性要求极高的场景</td>
</tr>
</tbody></table>
<p>Redis 分布式锁<strong>平衡了性能与可靠性</strong>，是企业中最常用的分布式锁方案之一，尤其适合秒杀、订单等高并发业务场景。</p>
<h1 id="实现集群环境的秒杀业务代码（版本一）"><a href="#实现集群环境的秒杀业务代码（版本一）" class="headerlink" title="实现集群环境的秒杀业务代码（版本一）"></a>实现集群环境的秒杀业务代码（版本一）</h1><h3 id="一、Redis-分布式锁（版本一）的核心实现"><a href="#一、Redis-分布式锁（版本一）的核心实现" class="headerlink" title="一、Redis 分布式锁（版本一）的核心实现"></a>一、Redis 分布式锁（版本一）的核心实现</h3><h4 id="1-锁的接口定义（ILock）"><a href="#1-锁的接口定义（ILock）" class="headerlink" title="1. 锁的接口定义（ILock）"></a>1. 锁的接口定义（<code>ILock</code>）</h4><p>通过接口规范分布式锁的行为，定义两个核心方法：</p>
<ul>
<li><code>tryLock(long timeoutSec)</code>：尝试获取锁，参数为 “锁的超时时间（秒）”，成功返回<code>true</code>，失败返回<code>false</code>。</li>
<li><code>unlock()</code>：释放锁。</li>
</ul>
<h4 id="2-SimpleRedisLock（基础实现）"><a href="#2-SimpleRedisLock（基础实现）" class="headerlink" title="2. SimpleRedisLock（基础实现）"></a>2. SimpleRedisLock（基础实现）</h4><p>基于 Redis 实现分布式锁的核心逻辑：</p>
<h5 id="（1）加锁逻辑"><a href="#（1）加锁逻辑" class="headerlink" title="（1）加锁逻辑"></a>（1）加锁逻辑</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 获取当前线程ID，作为锁的“归属标识”</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">    <span class="comment">// 2. 调用Redis的setIfAbsent（对应SETNX命令），同时设置超时时间</span></span><br><span class="line">    <span class="comment">// 作用：原子性完成“占锁 + 设过期时间”，避免死锁（如加锁后服务宕机，锁自动过期释放）</span></span><br><span class="line">    <span class="comment">//setIfAbsent()返回布尔值表示操作是否成功（true=键不存在且设置成功，false=键已存在）</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">            .setIfAbsent(KEY_PREFIX + name, threadId + <span class="string">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">// 包装为Boolean.TRUE，避免空指针</span></span><br><span class="line">    <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="（2）释放锁逻辑"><a href="#（2）释放锁逻辑" class="headerlink" title="（2）释放锁逻辑"></a>（2）释放锁逻辑</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 直接删除Redis中的锁Key，释放锁</span></span><br><span class="line">    stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-业务集成（秒杀下单场景）"><a href="#3-业务集成（秒杀下单场景）" class="headerlink" title="3. 业务集成（秒杀下单场景）"></a>3. 业务集成（秒杀下单场景）</h4><p>在 “一人一单” 的秒杀逻辑中，集成分布式锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">// 省略“秒杀时间校验、库存校验”等逻辑...</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 1. 创建“用户维度”的分布式锁（锁Key为：lock:order:用户ID）</span></span><br><span class="line">    <span class="type">SimpleRedisLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleRedisLock</span>(<span class="string">&quot;order:&quot;</span> + userId, stringRedisTemplate);</span><br><span class="line">    <span class="comment">// 2. 尝试加锁（超时时间1200秒）</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1200</span>);</span><br><span class="line">    <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;不允许重复下单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 3. 通过AOP代理执行事务方法（保证事务在锁的范围内执行）</span></span><br><span class="line">        <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">        <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 4. 最终释放锁（无论业务成功/失败，都保证锁释放）</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二、版本一的核心知识点与优缺点"><a href="#二、版本一的核心知识点与优缺点" class="headerlink" title="二、版本一的核心知识点与优缺点"></a>二、版本一的核心知识点与优缺点</h3><h4 id="1-优点：解决-“集群环境下的并发安全”"><a href="#1-优点：解决-“集群环境下的并发安全”" class="headerlink" title="1. 优点：解决 “集群环境下的并发安全”"></a>1. 优点：解决 “集群环境下的并发安全”</h4><ul>
<li><strong>原子性加锁</strong>：利用<code>setIfAbsent</code>（Redis <code>SET NX EX</code>命令），保证 “加锁 + 设置过期时间” 是原子操作，避免 “加锁后宕机导致锁永久占用” 的死锁问题。</li>
<li><strong>跨 JVM 生效</strong>：Redis 是独立服务，多集群节点（不同 JVM）共享锁状态，解决了 “单机<code>synchronized</code>锁在集群下失效” 的问题。</li>
<li><strong>实现简单</strong>：代码逻辑清晰，快速满足分布式场景下 “一人一单” 的并发控制需求。</li>
</ul>
<h4 id="2-缺点：存在-“锁误删”-和-“超时失控”-风险"><a href="#2-缺点：存在-“锁误删”-和-“超时失控”-风险" class="headerlink" title="2. 缺点：存在 “锁误删” 和 “超时失控” 风险"></a>2. 缺点：存在 “锁误删” 和 “超时失控” 风险</h4><ul>
<li><strong>锁误删问题</strong>：释放锁时，<strong>没有校验锁的归属</strong>。若线程 A 的锁因 “超时” 被自动释放，线程 B 抢到新锁，此时线程 A 执行完业务后，会误删线程 B 的锁（因为都操作同一个<code>lock:order:用户ID</code>键）。</li>
<li><strong>超时失控问题</strong>：锁的超时时间是<strong>固定值</strong>，若业务执行时间超过超时时间，锁会提前释放，导致 “多个线程同时执行业务” 的并发安全问题（比如线程 A 锁超时释放，线程 B 加锁成功，此时线程 A 仍在执行业务，线程 B 也开始执行）。</li>
</ul>
<h3 id="三、关键技术点总结"><a href="#三、关键技术点总结" class="headerlink" title="三、关键技术点总结"></a>三、关键技术点总结</h3><ul>
<li><strong>Redis 命令核心</strong>：<code>SET key value NX EX seconds</code>（<code>setIfAbsent</code>的底层逻辑），是分布式锁 “互斥性 + 自动超时释放” 的基础。</li>
<li><strong>事务与锁的协同</strong>：通过<code>AopContext</code>获取代理对象，保证<strong>事务在锁的范围内执行</strong>（避免 “锁释放后事务才提交” 导致的脏读）。</li>
<li><strong>finally 的必要性</strong>：无论业务是否异常，都通过<code>finally</code>块释放锁，防止 “锁泄漏”（锁长期不释放，导致其他线程无法获取）。</li>
</ul>
<p>该版本是 Redis 分布式锁的<strong>基础实现</strong>，能解决大部分集群场景的并发问题，但需后续优化 “锁归属校验” 和 “动态超时” 等问题。</p>
<h1 id="Redis-分布式锁的-“误删”-与-“原子性”-问题及解决方案"><a href="#Redis-分布式锁的-“误删”-与-“原子性”-问题及解决方案" class="headerlink" title="Redis 分布式锁的 “误删” 与 “原子性” 问题及解决方案"></a>Redis 分布式锁的 “误删” 与 “原子性” 问题及解决方案</h1><h4 id="一、误删问题：锁超时后误删其他线程的锁"><a href="#一、误删问题：锁超时后误删其他线程的锁" class="headerlink" title="一、误删问题：锁超时后误删其他线程的锁"></a>一、误删问题：锁超时后误删其他线程的锁</h4><p><strong>场景</strong>：</p>
<p>线程 A 持有锁，但因业务阻塞（如 GC 停顿、网络延迟）导致锁<strong>超时自动释放</strong>；后续线程 A 执行 “释放锁” 操作时，会误删已被线程 B 获取的新锁，引发并发安全问题（如 “一人一单” 逻辑失效）。</p>
<p><strong>解决方案：锁与线程标识绑定，释放前校验</strong></p>
<p>核心思路：加锁时存入<strong>线程唯一标识</strong>（如 “UUID 前缀 + 线程 ID”），释放时校验标识是否匹配，仅释放自身持有的锁。</p>
<ol>
<li><p><strong>加锁逻辑</strong>：</p>
<p>生成线程唯一标识，通过 <code>SETNX + EX</code> 原子性占锁并设置超时，确保锁归属可追溯。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ID_PREFIX</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>) + <span class="string">&quot;-&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">    <span class="comment">// 生成当前线程的唯一标识</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">    <span class="comment">// 原子性执行：SET key value NX EX seconds（占锁 + 设超时）</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">            .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>释放锁逻辑（初步优化）</strong>：</p>
<p>释放前校验锁的标识是否与当前线程一致，一致才删除（避免误删其他线程的锁）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">    <span class="comment">// 获取Redis中存储的锁标识</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">storedId</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);</span><br><span class="line">    <span class="comment">// 仅当标识匹配时，才删除锁</span></span><br><span class="line">    <span class="keyword">if</span> (threadId.equals(storedId)) &#123;</span><br><span class="line">        stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="二、原子性问题：“校验标识-删除锁”-非原子操作"><a href="#二、原子性问题：“校验标识-删除锁”-非原子操作" class="headerlink" title="二、原子性问题：“校验标识 + 删除锁” 非原子操作"></a>二、原子性问题：“校验标识 + 删除锁” 非原子操作</h4><p><strong>场景</strong>：</p>
<p>线程 A 执行 “校验标识” 后，锁因超时自动释放，线程 B 获取该锁；此时线程 A 继续执行 “删除锁”，会误删线程 B 的锁 —— 因为 “校验” 和 “删除” 是<strong>两步操作</strong>，中间可被其他操作打断，不具备原子性。</p>
<p><strong>解决方案：Lua 脚本保证原子性</strong></p>
<p>Redis 执行 Lua 脚本时是<strong>单线程</strong>的，脚本内的多条命令会<strong>原子性执行</strong>（中间不会被其他命令打断）。因此，将 “校验标识 + 删除锁” 封装为 Lua 脚本，确保两步操作的原子性。</p>
<ol>
<li><p><strong>Lua 脚本逻辑</strong>：</p>
<p>仅当锁的标识与当前线程一致时，原子性删除锁。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- KEYS[1]：锁的Key；ARGV[1]：当前线程的唯一标识</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;GET&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">return</span> redis.call(<span class="string">&#x27;DEL&#x27;</span>, KEYS[<span class="number">1</span>])  <span class="comment">-- 原子性删除锁</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>  <span class="comment">-- 标识不匹配，不操作</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Java 中调用 Lua 脚本</strong>：</p>
<p>通过 <code>RedisTemplate</code> 执行 Lua 脚本，确保 “校验 + 删除” 的原子性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义Lua脚本（从类路径加载，如unlock.lua文件）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">    UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>)); <span class="comment">// 脚本路径</span></span><br><span class="line">    UNLOCK_SCRIPT.setResultType(Long.class); <span class="comment">// 脚本返回值类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> KEY_PREFIX + name; <span class="comment">// 锁的Key（如&quot;lock:order:用户ID&quot;）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId(); <span class="comment">// 当前线程唯一标识</span></span><br><span class="line">    <span class="comment">// 执行Lua脚本，参数为：脚本、锁Key列表、线程标识</span></span><br><span class="line">    stringRedisTemplate.execute(</span><br><span class="line">            UNLOCK_SCRIPT,</span><br><span class="line">            Collections.singletonList(lockKey),</span><br><span class="line">            threadId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="三、方案价值与延伸问题"><a href="#三、方案价值与延伸问题" class="headerlink" title="三、方案价值与延伸问题"></a>三、方案价值与延伸问题</h4><ul>
<li><strong>价值</strong>：结合 “线程标识校验” 和 “Lua 原子性脚本”，彻底解决 “误删锁” 问题，确保分布式锁在高并发场景下的安全性。</li>
<li><strong>延伸问题</strong>：若<strong>业务执行时间 &gt; 锁超时时间</strong>，锁仍会提前释放（导致多线程并发执行业务）。需通过<strong>锁续期机制</strong>（如 Redisson 的 “看门狗”）自动延长锁的超时时间，匹配业务执行时长。</li>
</ul>
<h4 id="四、延伸问题：锁续期"><a href="#四、延伸问题：锁续期" class="headerlink" title="四、延伸问题：锁续期"></a>四、延伸问题：锁续期</h4><p>当前方案仍未解决 “<strong>锁超时时间 &lt; 业务执行时间</strong>” 的问题（若业务执行过慢，锁会提前释放，导致多线程并发执行）。后续需通过<strong>锁续期机制</strong>（如 Redisson 的 “看门狗”），自动延长锁的超时时间，匹配业务执行时长。</p>
<p>通过以上步骤，Redis 分布式锁既解决了 “误删他人锁” 的安全问题，又通过 Lua 脚本保证了 “释放锁” 操作的原子性，为高并发场景提供可靠的并发控制。</p>
</div>

    
    <section class="post-copyright">
      
      <p class="copyright-item">
        <span>作者:</span>
        <span>老江湖</span>
      </p>
        
      <p class="copyright-item">
        <span>许可证:</span>
        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
      </p>
       
      <p class="copyright-item">
        <span>口号:</span>
        <span><strong>代码是开源的,我们只是它的搬运工。</strong></span>
      </p>
       
        <p class="copyright-item">
        <span>如果觉得我的文章对你有所帮助，请随意转载，感谢支持！</span>
      </p>
      
             
        <p class="copyright-item">
        <span>如有侵权请告知删除🙏</span>
      </p>
             
        <p class="copyright-item">
        <span>如果你有很好的想法💡，请务必联系我。 </span>
        <br>
         <span>2292360909@qq.com</span>
      </p>
    </section>
    
    <section class="post-tags">
      <div>
        <span>标签:</span>
        <span class="tag">
          
        </span>
      </div>
      <div>
        <a href="javascript:window.history.back();">返回</a>
        <span>· </span>
        <a href="/">首页</a>
      </div>
    </section>
    <section class="post-nav">
      
      <a class="prev" rel="prev" href="/2025/10/12/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/03-%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95-%E5%9F%BA%E4%BA%8ERedis%E6%96%B9%E6%A1%88/"
        >03-短信登录-基于Redis方案</a
      >
       
      <a class="next" rel="next" href="/2025/10/12/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/05-%E4%BC%98%E6%83%A0%E5%8D%B7%E7%A7%92%E6%9D%80/"
        >05-优惠卷秒杀</a
      >
      
    </section>

    <!-- Giscus 评论区挂载点 -->
<div id="giscus-container" style="margin-top: 2.5rem;"></div>

<!-- Giscus 动态加载脚本：初始加载 + 明暗主题切换 -->
<script>
  function createGiscus(theme) {
    const giscusContainer = document.getElementById('giscus-container');
    if (!giscusContainer) return;

    // 清除旧的评论 iframe
    giscusContainer.innerHTML = '';

    const script = document.createElement('script');
    script.src = 'https://giscus.app/client.js';

    // 替换为你的 GitHub 仓库信息（格式：username/repo）
    script.setAttribute('data-repo', 'meisijiya/meisijiya.github.io');

   // 替换为你的 repo-id 和 category-id（在 giscus.app 配置页面生成）
    script.setAttribute('data-repo-id', 'R_kgDOPwTrpQ');
    script.setAttribute('data-category', 'Announcements');
    script.setAttribute('data-category-id', 'DIC_kwDOPwTrpc4CviGR');

    // 其他常规推荐设置
    script.setAttribute('data-mapping', 'pathname');           // 用页面路径匹配评论帖
    script.setAttribute('data-strict', '0');                   // 若无匹配帖则创建新帖
    script.setAttribute('data-reactions-enabled', '1');        // 启用表情反应
    script.setAttribute('data-emit-metadata', '0');            // 不输出元数据
    script.setAttribute('data-input-position', 'top');         // 输入框在评论上方
    script.setAttribute('data-theme', theme);                
    script.setAttribute('data-lang', 'zh-CN');                 // 中文界面
    script.setAttribute('crossorigin', 'anonymous');           // 跨域资源安全
    script.async = true;                                       
     
    giscusContainer.appendChild(script);
  }

  function getCurrentTheme() {
    return document.body.classList.contains('dark-theme') ? 'dark' : 'light';
  }

  document.addEventListener('DOMContentLoaded', () => {
    // 页面首次加载，根据当前主题挂载评论
    createGiscus(getCurrentTheme());

    // 监听按钮点击切换主题 → 重载评论区
    const buttons = [
      document.querySelector('.toggleBtn'),
      document.getElementById('mobile-toggle-theme')
    ];
    buttons.forEach(btn => {
      if (!btn) return;
      btn.addEventListener('click', () => {
        setTimeout(() => {
          createGiscus(getCurrentTheme());
        }, 400); // 稍作延迟，确保 class 切换完毕
      });
    });

    // 监听 body class 改变（保险方案）
    const observer = new MutationObserver(() => {
      createGiscus(getCurrentTheme());
    });
    observer.observe(document.body, { attributes: true, attributeFilter: ['class'] });
  });
</script>

  </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 老江湖 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>
<script src="/js/code-copy.js"></script>


    </div>
</body>
<!-- umami -->
<script defer src="https://cloud.umami.is/script.js" data-website-id="91b923f2-ff2d-43d0-ba5f-bc348d82426a"></script>
</html>