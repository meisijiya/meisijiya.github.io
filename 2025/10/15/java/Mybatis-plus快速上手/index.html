<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="老江湖">


    <meta name="subtitle" content="记录进入房间门后的美好">


    <meta name="description" content="一年前，孤苦伶仃的老江湖，偶然间发现一处房间门，推门而入，从此进入了充满幸福的世界。">


    <meta name="keywords" content="老江湖,博客,房间门">


<title>Mybatis-plus快速上手 | 欢迎来到老江湖的博客</title>



    <link rel="icon" href="/images/%E9%87%91%E6%AF%9B.png?_t=1758006391547">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    
    <link rel="stylesheet" href="/css/search.css">
    

<!-- highlight.js 样式（默认亮色） -->
<link id="hljs-theme" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/github.css">
<!-- highlight.js 自动上色功能 -->
<script src="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/lib/highlight.min.js"></script>
<script>hljs.highlightAll();</script>

<link rel="stylesheet" href="/css/custom.css">



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 7.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const pagebody = document.getElementsByTagName('body')[0]

            function setTheme(status) {

                if (status === 'dark') {
                    window.sessionStorage.theme = 'dark'
                    pagebody.classList.add('dark-theme');

                } else if (status === 'light') {
                    window.sessionStorage.theme = 'light'
                    pagebody.classList.remove('dark-theme');
                }
            };

            setTheme(window.sessionStorage.theme)
        })();
    </script>

    <div class="wrapper">
        <header>
  <nav class="navbar">
    <div class="container">
      <div class="navbar-header header-logo">
        <a href="/">老江湖的博客</a>
      </div>
      <div class="menu navbar-right">
        <!-- 在电脑端的导航链接区域添加搜索功能 -->
        <div class="search-container">
          <a href="javascript:;" onclick="toggleSearchInput()">🔍</a>
          <input
            type="text"
            id="nav-search-input-desktop"
            class="nav-search-input"
            placeholder="想知道我什么秘密呢，搜搜看吧"
            oninput="navSearch(this)"
          />
          <div id="nav-search-result-desktop" class="nav-search-result"></div>
        </div>

        
        <a class="menu-item" href="/archives">归档</a>
        
        <a class="menu-item" href="/category">分类</a>
        
        <a class="menu-item" href="/tag">标签</a>
        
        <a class="menu-item" href="/Timer">任务计时器</a>
        
        <a class="menu-item" href="/timeLine">时间线</a>
        
        <a class="menu-item" href="/tongji">网站统计</a>
        
        <a class="menu-item" href="/about">关于</a>
        

        <input id="switch_default" type="checkbox" class="switch_default" />
        <label for="switch_default" class="toggleBtn"></label>
      </div>
    </div>
  </nav>

  
  <nav class="navbar-mobile" id="nav-mobile">
    <div class="container">
      <div class="navbar-header">
        <div>
          <a href="/">老江湖的博客</a
          ><a id="mobile-toggle-theme">·&nbsp;Light</a>
        </div>

        <div class="menu-toggle" onclick="mobileBtn()">
          <svg
            class="menu-icon"
            xmlns="http://www.w3.org/2000/svg"
            width="32"
            height="32"
            viewBox="0 0 24 24"
          >
            <path
              fill="currentColor"
              d="M4.5 17.27q-.213 0-.356-.145T4 16.768t.144-.356t.356-.143h15q.213 0 .356.144q.144.144.144.357t-.144.356t-.356.143zm0-4.77q-.213 0-.356-.144T4 11.999t.144-.356t.356-.143h15q.213 0 .356.144t.144.357t-.144.356t-.356.143zm0-4.77q-.213 0-.356-.143Q4 7.443 4 7.23t.144-.356t.356-.143h15q.213 0 .356.144T20 7.23t-.144.356t-.356.144z"
            />
          </svg>
          <svg
            class="close-icon"
            xmlns="http://www.w3.org/2000/svg"
            width="32"
            height="32"
            viewBox="0 0 24 24"
          >
            <!-- Icon from Material Symbols Light by Google - https://github.com/google/material-design-icons/blob/master/LICENSE -->
            <path
              fill="currentColor"
              d="m12 12.708l-5.246 5.246q-.14.14-.344.15t-.364-.15t-.16-.354t.16-.354L11.292 12L6.046 6.754q-.14-.14-.15-.344t.15-.364t.354-.16t.354.16L12 11.292l5.246-5.246q.14-.14.345-.15q.203-.01.363.15t.16.354t-.16.354L12.708 12l5.246 5.246q.14.14.15.345q.01.203-.15.363t-.354.16t-.354-.16z"
            />
          </svg>
        </div>
      </div>

      <div class="menu" id="mobile-menu">
        
        <a class="menu-item" href="/archives">归档</a>
        
        <a class="menu-item" href="/category">分类</a>
        
        <a class="menu-item" href="/tag">标签</a>
        
        <a class="menu-item" href="/Timer">任务计时器</a>
        
        <a class="menu-item" href="/timeLine">时间线</a>
        
        <a class="menu-item" href="/tongji">网站统计</a>
        
        <a class="menu-item" href="/about">关于</a>
        
        <!-- 手机模式搜索框 -->
        <div class="search-container mobile-container">
          <a class="menu-item" href="javascript:;" onclick="toggleSearchInput()"
            >🔍</a
          >
          <input
            type="text"
            id="nav-search-input-mobile"
            class="nav-search-input"
            placeholder="想知道我什么秘密呢，搜搜看吧"
            oninput="navSearch(this)"
          />
          <div id="nav-search-result-mobile" class="nav-search-result"></div>
        </div>
      </div>
    </div>
  </nav>
</header>
<script>
  var mobileBtn = function f() {
    var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
    var mobileMenu = document.getElementById("mobile-menu");
    if (toggleMenu.classList.contains("active")) {
      toggleMenu.classList.remove("active");
      mobileMenu.classList.remove("active");
    } else {
      toggleMenu.classList.add("active");
      mobileMenu.classList.add("active");
    }
  };

  function toggleSearchInput() {
    const inputs = document.querySelectorAll(".nav-search-input");
    const results = document.querySelectorAll(".nav-search-result");
    inputs.forEach((input) => {
      input.classList.toggle("active");
      if (input.classList.contains("active")) input.focus();
    });
    results.forEach((r) => (r.style.display = "none"));
  }

  // 点击外部区域隐藏搜索框和结果容器的函数
  function handleClickOutsideSearch(event) {
    const searchContainers = document.querySelectorAll(".search-container");
    searchContainers.forEach((container) => {
      const searchInput = container.querySelector(".nav-search-input");
      const searchIcon = container.querySelector("a");

      // 如果点击的元素不是搜索输入框或搜索图标，则隐藏搜索框和结果容器
      if (
        !searchInput.contains(event.target) &&
        !searchIcon.contains(event.target)
      ) {
        searchInput.classList.remove("active");
        searchInput.value = ""
        // 根据输入框ID确定对应的结果容器
        let resultContainer;
        if (searchInput.id === "nav-search-input-mobile") {
          // 移动端结果容器
          resultContainer = document.querySelector(
            ".navbar-mobile .nav-search-result"
          );
        } else {
          // 桌面端结果容器
          resultContainer = document.getElementById(
            "nav-search-result-desktop"
          );
        }

        if (resultContainer) {
          resultContainer.style.display = "none";
          resultContainer.innerHTML = ""; // 清空结果容器内容
        }
      }
    });
  }

  // 添加全局点击事件监听器
  document.addEventListener("click", function (event) {
    handleClickOutsideSearch(event);
  });

  // 新增：搜索功能实现
  let searchData = []; // 全局变量存储搜索数据

  // 页面加载完成后获取搜索数据
  document.addEventListener("DOMContentLoaded", function () {
    fetch("/search.xml")
      .then((res) => res.text())
      .then((xmlText) => {
        const parser = new DOMParser();
        const xml = parser.parseFromString(xmlText, "text/xml");
        const entries = xml.getElementsByTagName("entry");
        for (let entry of entries) {
          searchData.push({
            title: entry.getElementsByTagName("title")[0]?.textContent || "",
            content:
              entry.getElementsByTagName("content")[0]?.textContent || "",
            url: entry.getElementsByTagName("url")[0]?.textContent || "",
          });
        }
      })
      .catch((err) => {
        console.error("Failed to load search data:", err);
      });
  });

  // 新增：导航搜索方法
  function navSearch(inputElement) {
    const keyword = inputElement.value.trim().toLowerCase();
    // 查找对应的搜索结果容器
    let resultContainer;

    if (inputElement.id === "nav-search-input-desktop") {
      // 桌面端
      resultContainer = document.getElementById("nav-search-result-desktop");
    } else if (inputElement.id === "nav-search-input-mobile") {
      // 移动端
      resultContainer =
        inputElement.parentNode.querySelector(".nav-search-result");
    }

    if (!resultContainer) return;

    resultContainer.innerHTML = "";

    if (!keyword) {
      resultContainer.style.display = "none";
      return;
    }

    // 显示结果容器
    resultContainer.style.display = "block";

    // 过滤搜索数据
    const results = searchData.filter(
      (data) =>
        (data.title && data.title.toLowerCase().includes(keyword)) ||
        (data.content && data.content.toLowerCase().includes(keyword))
    );

    if (results.length === 0) {
      resultContainer.innerHTML =
        '<p class="no-result">没有结果哟，换个关键词试试吧</p>';
      return;
    }

    // 限制显示结果数量
    const maxResults = 10;
    const limitedResults = results.slice(0, maxResults);

    // 构建结果HTML
    const html = limitedResults
      .map((item) => {
        // 提取包含关键字的内容片段
        let contentSnippet = "";
        if (item.content) {
          // 找到包含关键字的内容片段
          const contentLower = item.content.toLowerCase();
          const keywordIndex = contentLower.indexOf(keyword);

          // 提取关键字前后的内容
          const start = Math.max(0, keywordIndex - 3 * keyword.length);
          const end = Math.min(
            item.content.length,
            keywordIndex + 3 * keyword.length
          );
          contentSnippet = item.content.substring(start, end);
        // 高亮关键字
      const keywordRegex = new RegExp(`(${keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
      contentSnippet = contentSnippet.replace(
        keywordRegex,
        "<mark>$1</mark>"
      );
        }

        return `<div class="search-result-item">
  <a href="${item.url}">
    <div>标题：${item.title}</div>
    <div>内容：${contentSnippet}</div>
  </a>
</div>`;
      })
      .join("");
    resultContainer.innerHTML = html;
  }
</script>
<style>
  /* 手机端使用flexbox布局搜索容器 */
  .mobile-container {
    display: flex;
    align-items: center;
    flex-direction: row;
    margin-bottom: 10px;
    margin-left: 10px;
    flex-grow: 1;
    max-width: calc(100% - 40px);
  }


  .search-result-item {
  border: 1px solid #ddd; /* 边框 */
  margin: 4px 0; /* 外层间距 */
  padding: 0; /* 无内边距 */
  background: #fff; /* 背景色 */
}

.search-result-item a {
  display: block;
  text-decoration: none;
  color: inherit;
}

.search-result-item div {
  padding: 3px 8px; /* 紧凑的内边距 */
  margin: 0; /* 无外边距 */
  line-height: 1.3; /* 紧凑的行高 */
  word-wrap: break-word; /* 允许长单词换行 */
  white-space: normal; /* 允许正常换行 */
}

.search-result-item div:first-child {
  border-bottom: 1px solid #eee; /* 标题和内容之间的分隔线 */
}


</style>

            <div class="main">
                <div class="container">
    <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">展开所有</a>
        <a onclick="go_top()">返回顶部</a>
        <a onclick="go_bottom()">返回底部</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? '展开所有' : '折叠所有';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>  
  <article class="post-wrap">
    <header class="post-header">
      <h1 class="post-title">Mybatis-plus快速上手</h1>
      
      <div class="post-meta">
         作者:
        <a itemprop="author" rel="author" href="/">老江湖</a>
         
        <span class="post-time">
          <br />日期:
          <a href="#"
            >十月 15, 2025&nbsp;&nbsp;1:03:45</a
          >
        </span>
         
        <span class="post-category"
          ><br />
          分类: 
          <a href="/categories/java/">java</a>
          
        </span>
        
      </div>
      
    </header>

    <div class="post-content"><h2 id="一、环境说明"><a href="#一、环境说明" class="headerlink" title="一、环境说明"></a>一、环境说明</h2><ul>
<li><strong>技术栈版本</strong>：SpringBoot3、JDK17、IntelliJ IDEA、MyBatisPlus 3.5.11</li>
<li><strong>核心依赖（关键版本）：</strong><ul>
<li><code>mybatis-plus-spring-boot3-starter:3.5.11</code></li>
<li><code>mysql-connector-java:8.0.33</code></li>
<li><code>hutool-all:5.8.22</code></li>
<li><code>lombok</code>（简化实体类）</li>
</ul>
</li>
</ul>
<h2 id="二、核心章节内容（12-章）"><a href="#二、核心章节内容（12-章）" class="headerlink" title="二、核心章节内容（12 章）"></a>二、核心章节内容（12 章）</h2><h3 id="第-1-章：快速入门"><a href="#第-1-章：快速入门" class="headerlink" title="第 1 章：快速入门"></a>第 1 章：快速入门</h3><h4 id="1-1-MyBatis-Plus-简介"><a href="#1-1-MyBatis-Plus-简介" class="headerlink" title="1.1 MyBatis-Plus 简介"></a>1.1 MyBatis-Plus 简介</h4><p><strong>核心特性：</strong></p>
<ul>
<li><strong>无侵入：不改变现有工程结构</strong></li>
<li><strong>损耗小：启动自动注入基础 CRUD，性能无感知损耗</strong></li>
<li><strong>强 CRUD：内置通用 Mapper、通用 Service</strong></li>
<li><strong>支持 Lambda 调用：避免字段硬编码</strong></li>
<li><strong>内置代码生成器、分页插件（支持多数据库）</strong></li>
</ul>
<h4 id="1-2-环境准备"><a href="#1-2-环境准备" class="headerlink" title="1.2 环境准备"></a>1.2 环境准备</h4><ol>
<li><strong>建库建表 SQL：</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE `mybatis_plus_demo` DEFAULT CHARACTER SET utf8mb4;</span><br><span class="line">CREATE TABLE `user` (</span><br><span class="line">  `id` int NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(255) DEFAULT NULL,</span><br><span class="line">  `age` int DEFAULT NULL,</span><br><span class="line">  `email` varchar(255) DEFAULT NULL,</span><br><span class="line">  `status` varchar(255) DEFAULT NULL,</span><br><span class="line">  `create_time` datetime DEFAULT NULL,</span><br><span class="line">  `update_time` datetime DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1571093847 DEFAULT CHARSET=utf8mb4;</span><br></pre></td></tr></table></figure></li>
<li><strong>配置文件（application.yml）：</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql://你的数据库地址?useSSL=false&amp;serverTimezone=UTC</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">mybatis-plus:</span><br><span class="line">  configuration:</span><br><span class="line">    log-impl:org.apache.ibatis.logging.stdout.StdOutImpl # 打印SQL</span><br></pre></td></tr></table></figure></li>
<li><strong>核心代码：</strong><ul>
<li><strong>实体类</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> @Data</span><br><span class="line">@TableName(value = &quot;user&quot;, autoResultMap = true)</span><br><span class="line">public class User &#123;</span><br><span class="line">    @TableId(type = IdType.AUTO)</span><br><span class="line">     private Integer id;</span><br><span class="line">     private String name;</span><br><span class="line">     private Integer age;</span><br><span class="line">     private String email;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>Mapper 接口</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public interface UserMapper extends BaseMapper&lt;User&gt; &#123;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>启动类</strong>：添加 <code>@MapperScan(&quot;com.lglbc.mybatisplusdemo.mapper&quot;)</code></li>
</ul>
</li>
</ol>
<h4 id="1-3-基础-CRUD-操作（测试用例）"><a href="#1-3-基础-CRUD-操作（测试用例）" class="headerlink" title="1.3 基础 CRUD 操作（测试用例）"></a>1.3 基础 CRUD 操作（测试用例）</h4><ul>
<li><strong>插入：</strong><code>userMapper.insert(user)</code><ul>
<li><pre><code>@Test
 public void testInsert() &#123;
 User user = new User();
        user.setAge(10);
        user.setName(&quot;ljh&quot;);
        user.setEmail(&quot;ljh@fjm&quot;);
        userMapper.insert(user);
 &#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">* **查询：**`selectById(id)`、`selectList(null)`（查所有）</span><br><span class="line">  * ```</span><br><span class="line">    // 根据ID查询</span><br><span class="line">    @Test</span><br><span class="line">     public void testSelectById() &#123;</span><br><span class="line">     User user = userMapper.selectById(12);</span><br><span class="line">     System.out.println(user);</span><br><span class="line">     &#125;</span><br><span class="line">     // 查询所有</span><br><span class="line">    @Test</span><br><span class="line">     public void testSelect() &#123;</span><br><span class="line">     List&lt;User&gt; users = userMapper.selectList(null);</span><br><span class="line">            users.forEach(System.out::println);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><strong>更新：</strong><code>updateById(user)</code><ul>
<li><pre><code>@Test
 public void testUpdate() &#123;
 User user = userMapper.selectById(12);
        user.setName(&quot;更新&quot;);
        userMapper.updateById(user);
 &#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* **删除：**`deleteById(id)`</span><br><span class="line">  * ```</span><br><span class="line">    @Test</span><br><span class="line">     public void testDelete() &#123;</span><br><span class="line">            userMapper.deleteById(1);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="第-2-章：IService-接口"><a href="#第-2-章：IService-接口" class="headerlink" title="第 2 章：IService 接口"></a>第 2 章：IService 接口</h3><h4 id="2-1-基础配置"><a href="#2-1-基础配置" class="headerlink" title="2.1 基础配置"></a>2.1 基础配置</h4><ul>
<li><strong>Service 接口：</strong><ul>
<li><pre><code>public interface UserService extends IService&lt;User&gt; &#123;
     // 可以在此添加⾃定义⽅法
    List&lt;User&gt; selectByAgeRange(Integer minAge, Integer maxAge);
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">* **Service 实现类：**</span><br><span class="line">  * ```</span><br><span class="line">    @Service</span><br><span class="line">     public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public List&lt;User&gt; selectByAgeRange(Integer minAge, Integer maxAge) &#123;</span><br><span class="line">             LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">             wrapper.between(User::getAge, minAge, maxAge);</span><br><span class="line">             return this.list(wrapper);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="2-2-IService-核心方法演示（含批量-链式）"><a href="#2-2-IService-核心方法演示（含批量-链式）" class="headerlink" title="2.2 IService 核心方法演示（含批量 &#x2F; 链式）"></a>2.2 IService 核心方法演示（含批量 &#x2F; 链式）</h4><table>
<thead>
<tr>
<th><strong>操作类型</strong></th>
<th><strong>关键方法</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>保存</strong></td>
<td><code>save(user)</code>（单条）、<code>saveBatch(users, 1000)</code>（批量，每 1000 条一批）</td>
</tr>
<tr>
<td><strong>保存或更新</strong></td>
<td><code>saveOrUpdate(user)</code>（按 ID 判断）、<code>saveOrUpdateBatch(users)</code></td>
</tr>
<tr>
<td><strong>删除</strong></td>
<td><code>removeById(id)</code>、<code>removeByMap(map)</code>、<code>remove(wrapper)</code>、<code>removeByIds(ids)</code></td>
</tr>
<tr>
<td><strong>更新</strong></td>
<td><code>updateById(user)</code>、<code>update(wrapper)</code>（条件更新）、<code>updateBatchById(users)</code></td>
</tr>
<tr>
<td><strong>查询</strong></td>
<td><code>getById(id)</code>、<code>getOne(wrapper)</code>、<code>list()</code>、<code>list(wrapper)</code>、<code>count(wrapper)</code></td>
</tr>
<tr>
<td><strong>分页</strong></td>
<td><strong>配置</strong><code>PaginationInnerInterceptor</code> 后，调用 <code>page(new Page&lt;&gt;(1,2), wrapper)</code></td>
</tr>
</tbody></table>
<p><strong>IService 接口提供了比 BaseMapper 更丰富的 CRUD 操作，以下通过具体测试用例（基于 JUnit）演示各核心方法的使用，所有示例均来自课程文档中的实战代码。</strong></p>
<h5 id="一、保存操作"><a href="#一、保存操作" class="headerlink" title="一、保存操作"></a>一、保存操作</h5><p><strong>包含单条数据保存与批量数据保存，批量保存可指定每批处理条数以优化性能。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 1. 测试保存单个实体</span><br><span class="line">@Test </span><br><span class="line">void testSave() &#123;</span><br><span class="line">    User user = new User(); </span><br><span class="line">    user.setName(&quot;张三&quot;); </span><br><span class="line">    user.setAge(25); </span><br><span class="line">    user.setEmail(&quot;zhangsan@example.com&quot;); </span><br><span class="line">    boolean result = userService.save(user); // 单条保存核心方法</span><br><span class="line">    System.out.println(&quot;保存结果: &quot; + result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2. 测试批量保存（每1000条为一批，避免内存溢出）</span><br><span class="line">@Test </span><br><span class="line">void testSaveBatch() &#123;</span><br><span class="line">    List&lt;User&gt; users = new ArrayList&lt;&gt;(); </span><br><span class="line">    for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">        User user = new User();</span><br><span class="line">        user.setName(&quot;用户&quot; + i); </span><br><span class="line">        user.setAge(20 + i); </span><br><span class="line">        users.add(user);</span><br><span class="line">    &#125;</span><br><span class="line">    boolean result = userService.saveBatch(users, 1000); // 批量保存核心方法（指定批次大小）</span><br><span class="line">    System.out.println(&quot;批量保存结果:&quot; + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="二、保存或更新操作"><a href="#二、保存或更新操作" class="headerlink" title="二、保存或更新操作"></a>二、保存或更新操作</h5><p><strong>根据实体是否包含 ID 自动判断：ID 存在则执行更新，ID 不存在则执行插入，支持单条与批量操作。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 1. 单条保存或更新（按ID判断）</span><br><span class="line">@Test</span><br><span class="line">void testSaveOrUpdate() &#123; </span><br><span class="line">    User user = new User(); </span><br><span class="line">    user.setId(1L); // ID存在，执行更新；ID不存在，执行插入</span><br><span class="line">    user.setName(&quot;更新后的名字&quot;);</span><br><span class="line">    boolean result = userService.saveOrUpdate(user); // 单条保存或更新核心方法</span><br><span class="line">    System.out.println(&quot;保存或更新结果:&quot; + result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2. 批量保存或更新</span><br><span class="line">@Test</span><br><span class="line">void testSaveOrUpdateBatch() &#123; </span><br><span class="line">    List&lt;User&gt; users = userService.list(); // 先查询已有数据</span><br><span class="line">    users.forEach(user -&gt; user.setName(user.getName() + &quot;_updated&quot;)); // 批量修改字段</span><br><span class="line">    boolean result = userService.saveOrUpdateBatch(users); // 批量保存或更新核心方法</span><br><span class="line">    System.out.println(&quot;批量保存或更新结果:&quot; + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="三、删除操作"><a href="#三、删除操作" class="headerlink" title="三、删除操作"></a>三、删除操作</h5><p><strong>支持按 ID、按条件（Map &#x2F; 条件构造器）、批量删除，覆盖多种删除场景。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 1. 根据ID删除</span><br><span class="line">@Test</span><br><span class="line">void testRemoveById() &#123; </span><br><span class="line">    boolean result = userService.removeById(1L); // 按ID删除核心方法</span><br><span class="line">    System.out.println(&quot;删除结果:&quot; + result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2. 根据Map条件删除（Map的key为字段名，value为字段值）</span><br><span class="line">@Test</span><br><span class="line">void testRemoveByMap() &#123; </span><br><span class="line">    Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    map.put(&quot;name&quot;, &quot;张三&quot;); </span><br><span class="line">    map.put(&quot;age&quot;, 25); // 条件：name=张三 且 age=25</span><br><span class="line">    boolean result = userService.removeByMap(map); // 按Map条件删除核心方法</span><br><span class="line">    System.out.println(&quot;根据Map条件删除结果:&quot; + result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3. 根据条件构造器删除（支持复杂条件）</span><br><span class="line">@Test</span><br><span class="line">void testRemove() &#123; </span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); </span><br><span class="line">    wrapper.eq(User::getName, &quot;张三&quot;).gt(User::getAge, 20); // 条件：name=张三 且 age&gt;20</span><br><span class="line">    boolean result = userService.remove(wrapper); // 按条件构造器删除核心方法</span><br><span class="line">    System.out.println(&quot;根据条件构造器删除结果:&quot; + result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 4. 批量删除（按ID集合）</span><br><span class="line">@Test</span><br><span class="line">void testRemoveByIds() &#123; </span><br><span class="line">    List&lt;Long&gt; ids = Arrays.asList(1L, 2L, 3L); // 待删除的ID集合</span><br><span class="line">    boolean result = userService.removeByIds(ids); // 批量删除核心方法</span><br><span class="line">    System.out.println(&quot;批量删除结果:&quot; + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="四、更新操作"><a href="#四、更新操作" class="headerlink" title="四、更新操作"></a>四、更新操作</h5><p><strong>支持按 ID、按条件（条件构造器）、批量更新，满足不同更新需求。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 1. 根据ID更新</span><br><span class="line">@Test</span><br><span class="line">void testUpdateById() &#123; </span><br><span class="line">    User user = userService.getById(1L); // 先查询待更新数据</span><br><span class="line">    user.setName(&quot;新名字&quot;); // 修改字段</span><br><span class="line">    boolean result = userService.updateById(user); // 按ID更新核心方法</span><br><span class="line">    System.out.println(&quot;更新结果:&quot; + result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2. 根据条件更新（统一修改符合条件的记录）</span><br><span class="line">@Test</span><br><span class="line">void testUpdate() &#123; </span><br><span class="line">    UpdateWrapper&lt;User&gt; wrapper = new UpdateWrapper&lt;&gt;(); </span><br><span class="line">    wrapper.set(&quot;name&quot;, &quot;统一新名字&quot;).gt(&quot;age&quot;, 20); // 操作：name设为&quot;统一新名字&quot;；条件：age&gt;20</span><br><span class="line">    boolean result = userService.update(wrapper); // 按条件更新核心方法</span><br><span class="line">    System.out.println(&quot;条件更新结果:&quot; + result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3. 批量更新（按ID集合批量修改）</span><br><span class="line">@Test</span><br><span class="line">void testUpdateBatchById() &#123; </span><br><span class="line">    List&lt;User&gt; users = userService.list(); // 先查询已有数据</span><br><span class="line">    users.forEach(user -&gt; user.setAge(user.getAge() + 1)); // 批量修改age字段（+1）</span><br><span class="line">    boolean result = userService.updateBatchById(users); // 批量更新核心方法</span><br><span class="line">    System.out.println(&quot;批量更新结果:&quot; + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="五、查询操作"><a href="#五、查询操作" class="headerlink" title="五、查询操作"></a>五、查询操作</h5><p><strong>覆盖单条查询、列表查询、数量统计等场景，支持按 ID、按条件查询，且兼容 Lambda 条件构造器。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 1. 根据ID查询单条数据</span><br><span class="line">@Test</span><br><span class="line">void testGetById() &#123; </span><br><span class="line">    User user = userService.getById(1L); // 按ID查询核心方法</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2. 根据条件查询单条数据（若有多条，默认抛异常，可设置allowMultipleResults=true允许返回第一条）</span><br><span class="line">@Test</span><br><span class="line">void testGetOne() &#123; </span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); </span><br><span class="line">    wrapper.gt(User::getAge, 20); // 条件：age&gt;20</span><br><span class="line">    User user = userService.getOne(wrapper); // 按条件查询单条核心方法</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3. 查询列表（查询所有/按条件查询）</span><br><span class="line">@Test</span><br><span class="line">void testList() &#123; </span><br><span class="line">    // 3.1 查询所有数据</span><br><span class="line">    List&lt;User&gt; users = userService.list(); // 查询所有核心方法</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    // 3.2 按条件查询列表</span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); </span><br><span class="line">    wrapper.like(User::getName, &quot;张&quot;); // 条件：name包含&quot;张&quot;</span><br><span class="line">    List&lt;User&gt; filteredUsers = userService.list(wrapper); // 按条件查询列表核心方法</span><br><span class="line">    filteredUsers.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 4. 查询记录总数（统计所有/按条件统计）</span><br><span class="line">@Test</span><br><span class="line">void testCount() &#123; </span><br><span class="line">    // 4.1 统计所有记录数</span><br><span class="line">    long count = userService.count(); // 统计所有核心方法</span><br><span class="line">    System.out.println(&quot;总记录数: &quot; + count);</span><br><span class="line"></span><br><span class="line">    // 4.2 按条件统计记录数</span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); </span><br><span class="line">    wrapper.gt(User::getAge, 20); // 条件：age&gt;20</span><br><span class="line">    long filteredCount = userService.count(wrapper); // 按条件统计核心方法</span><br><span class="line">    System.out.println(&quot;年龄大于20的记录数:&quot; + filteredCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="六、分页查询操作"><a href="#六、分页查询操作" class="headerlink" title="六、分页查询操作"></a>六、分页查询操作</h5><p><strong>需先配置分页插件（</strong><code>PaginationInnerInterceptor</code>），再通过 <code>page()</code> 方法实现分页，支持无条件 &#x2F; 有条件分页。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 1. 配置分页插件（全局配置，需在配置类中声明）</span><br><span class="line">@Configuration </span><br><span class="line">public class MybatisPlusConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public MybatisPlusInterceptor mybatisPlusInterceptor() &#123; </span><br><span class="line">        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();</span><br><span class="line">        interceptor.addInnerInterceptor(new PaginationInnerInterceptor()); // 注册分页插件</span><br><span class="line">        return interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2. 分页查询测试</span><br><span class="line">@Test</span><br><span class="line">void testPage() &#123; </span><br><span class="line">    Page&lt;User&gt; page = new Page&lt;&gt;(1, 2); // 构建分页对象：当前页（1）、每页条数（2）</span><br><span class="line"></span><br><span class="line">    // 2.1 无条件分页</span><br><span class="line">    Page&lt;User&gt; result1 = userService.page(page); // 无条件分页核心方法</span><br><span class="line">    System.out.println(&quot;总记录数:&quot; + result1.getTotal()); </span><br><span class="line">    result1.getRecords().forEach(System.out::println); // 打印当前页数据</span><br><span class="line"></span><br><span class="line">    // 2.2 有条件分页</span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); </span><br><span class="line">    wrapper.gt(User::getAge, 20); // 条件：age&gt;20</span><br><span class="line">    Page&lt;User&gt; result2 = userService.page(page, wrapper); // 有条件分页核心方法</span><br><span class="line">    System.out.println(&quot;年龄大于20的记录数:&quot; + result2.getTotal());</span><br><span class="line">    result2.getRecords().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="七、链式调用操作"><a href="#七、链式调用操作" class="headerlink" title="七、链式调用操作"></a>七、链式调用操作</h5><p><strong>通过 Lambda 链式语法简化查询、更新、删除逻辑，代码更简洁易读。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">void testChain() &#123; </span><br><span class="line">    // 1. 查询链式调用：age&gt;20 且 name包含&quot;张&quot;，直接返回列表</span><br><span class="line">    List&lt;User&gt; users = userService.lambdaQuery()</span><br><span class="line">                                  .gt(User::getAge, 20)</span><br><span class="line">                                  .like(User::getName, &quot;张&quot;)</span><br><span class="line">                                  .list();</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    // 2. 更新链式调用：name=张三 的用户，将age设为30</span><br><span class="line">    boolean updateResult = userService.lambdaUpdate()</span><br><span class="line">                                      .eq(User::getName, &quot;张三&quot;)</span><br><span class="line">                                      .set(User::getAge, 30)</span><br><span class="line">                                      .update();</span><br><span class="line">    System.out.println(&quot;更新结果:&quot; + updateResult);</span><br><span class="line"></span><br><span class="line">    // 3. 删除链式调用：name=李四 的用户，直接执行删除</span><br><span class="line">    boolean removeResult = userService.lambdaUpdate() </span><br><span class="line">                                      .eq(User::getName, &quot;李四&quot;)</span><br><span class="line">                                      .remove();</span><br><span class="line">    System.out.println(&quot;删除结果:&quot; + removeResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-链式调用示例"><a href="#2-3-链式调用示例" class="headerlink" title="2.3 链式调用示例"></a>2.3 链式调用示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 查询：年龄&gt;20且名字含“张”</span><br><span class="line">userService</span><br><span class="line">    .lambdaQuery()</span><br><span class="line">    .gt(User::getAge, 20)</span><br><span class="line">    .like(User::getName, &quot;张&quot;)</span><br><span class="line">    .list();</span><br><span class="line">// 更新：名字=“张三”的用户年龄设为30</span><br><span class="line">userService</span><br><span class="line">    .lambdaUpdate()</span><br><span class="line">    .eq(User::getName, &quot;张三&quot;)</span><br><span class="line">    .set(User::getAge, 30)</span><br><span class="line">    .update();</span><br><span class="line">//删除：删除名字=“李四”的用户</span><br><span class="line"> userService</span><br><span class="line">     .lambdaUpdate()</span><br><span class="line">     .eq(User::getName, &quot;李四&quot;)</span><br><span class="line">     .remove();</span><br></pre></td></tr></table></figure>

<h4 id="2-4-自定义方法"><a href="#2-4-自定义方法" class="headerlink" title="2.4 自定义方法"></a>2.4 自定义方法</h4><p><strong>在 Service 接口定义</strong><code>List&lt;User&gt; selectByAgeRange(Integer minAge, Integer maxAge)</code>，实现类用 <code>LambdaQueryWrapper</code> 实现条件查询。</p>
<h5 id="一、Service-接口定义（自定义方法声明）"><a href="#一、Service-接口定义（自定义方法声明）" class="headerlink" title="一、Service 接口定义（自定义方法声明）"></a>一、Service 接口定义（自定义方法声明）</h5><p>**在 **<code>UserService</code> 接口中继承 <code>IService&lt;User&gt;</code>，并添加自定义方法 <code>selectByAgeRange</code>，用于根据传入的最小年龄和最大年龄查询用户列表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">// 继承IService&lt;User&gt;获得基础CRUD能力，同时声明自定义方法</span><br><span class="line">public interface UserService extends IService&lt;User&gt; &#123;</span><br><span class="line">    // 自定义方法：根据年龄范围（minAge~maxAge）查询用户列表</span><br><span class="line">    List&lt;User&gt; selectByAgeRange(Integer minAge, Integer maxAge);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="二、Service-实现类（自定义方法逻辑实现）"><a href="#二、Service-实现类（自定义方法逻辑实现）" class="headerlink" title="二、Service 实现类（自定义方法逻辑实现）"></a>二、Service 实现类（自定义方法逻辑实现）</h5><p>**创建 **<code>UserServiceImpl</code> 类，继承 <code>ServiceImpl&lt;UserMapper, User&gt;</code> 并实现 <code>UserService</code> 接口，在自定义方法中通过 <code>LambdaQueryWrapper</code> 构建 “年龄在 minAge 和 maxAge 之间” 的查询条件，最终调用 <code>this.list(wrapper)</code> 执行查询。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line">import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">@Service // 交给Spring容器管理，确保能被注入使用</span><br><span class="line">public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService &#123;</span><br><span class="line"></span><br><span class="line">    // 实现自定义方法：按年龄范围查询</span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;User&gt; selectByAgeRange(Integer minAge, Integer maxAge) &#123;</span><br><span class="line">        // 1. 创建LambdaQueryWrapper（类型安全，避免字段硬编码）</span><br><span class="line">        LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        // 2. 构建条件：年龄 between minAge 和 maxAge（包含边界值）</span><br><span class="line">        wrapper.between(User::getAge, minAge, maxAge);</span><br><span class="line"></span><br><span class="line">        // 3. 调用list()方法执行查询，返回符合条件的用户列表</span><br><span class="line">        return this.list(wrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-批量操作性能优化"><a href="#2-5-批量操作性能优化" class="headerlink" title="2.5 批量操作性能优化"></a>2.5 批量操作性能优化</h4><p><strong>在处理大批量数据时，直接执行全量批量操作可能导致内存占用过高（甚至 OOM）、数据库连接压力过大等问题。IService 接口的批量操作性能优化核心方案为****分批处理</strong>，通过控制单次批量操作的数据量，平衡内存消耗与数据库交互效率。</p>
<p><strong>针对大批量数据（如万级、十万级数据）的批量新增、更新等操作，不直接调用无批次限制的批量方法（如 <strong><code>saveBatch(users)</code>），而是手动指定</strong>单次批次大小</strong>，将全量数据拆分为多批逐步执行，避免一次性加载大量数据到内存。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Test </span><br><span class="line">void testBatchPerformance() &#123;</span><br><span class="line">    // 1. 模拟大批量数据（示例：10万条用户数据）</span><br><span class="line">    List&lt;User&gt; users = new ArrayList&lt;&gt;(); </span><br><span class="line">    for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">        User user = new User();</span><br><span class="line">        user.setName(&quot;用户_&quot; + i); // 构造用户姓名</span><br><span class="line">        user.setAge(i % 100); // 构造用户年龄（0-99随机分布）</span><br><span class="line">        users.add(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2. 分批执行批量插入：每1000条数据为一批</span><br><span class="line">    boolean result = userService.saveBatch(users, 1000); </span><br><span class="line">    System.out.println(&quot;批量插入结果:&quot; + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>上述代码中，</strong><code>saveBatch(users, 1000)</code> 方法的第二个参数 <code>1000</code> 即为<strong>单次批次大小</strong>，表示每积累 1000 条数据执行一次批量插入操作，10 万条数据最终会拆分为 100 批逐步处理。</p>
<h3 id="第-3-章：条件构造器（Wrapper）"><a href="#第-3-章：条件构造器（Wrapper）" class="headerlink" title="第 3 章：条件构造器（Wrapper）"></a>第 3 章：条件构造器（Wrapper）</h3><h4 id="3-1-构造器类型"><a href="#3-1-构造器类型" class="headerlink" title="3.1 构造器类型"></a>3.1 构造器类型</h4><ul>
<li><code>QueryWrapper</code>：通用查询构造器（需硬编码字段名，易出错）</li>
<li><code>LambdaQueryWrapper</code>：Lambda 语法查询（类型安全，推荐）</li>
<li><code>UpdateWrapper</code>&#x2F;<code>LambdaUpdateWrapper</code>：更新操作构造器</li>
</ul>
<h4 id="3-2-核心查询条件（Lambda-方式示例）"><a href="#3-2-核心查询条件（Lambda-方式示例）" class="headerlink" title="3.2 核心查询条件（Lambda 方式示例）"></a>3.2 核心查询条件（Lambda 方式示例）</h4><table>
<thead>
<tr>
<th><strong>条件类型</strong></th>
<th><strong>代码示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>等值 &#x2F; 不等值</strong></td>
<td><code>eq(User::getName, &quot;张三&quot;).ne(User::getAge, 18)</code></td>
</tr>
<tr>
<td><strong>范围</strong></td>
<td><code>gt(User::getAge, 18).between(User::getAge, 20, 30)</code></td>
</tr>
<tr>
<td><strong>模糊查询</strong></td>
<td><code>like(User::getName, &quot;张&quot;).likeLeft(User::getName, &quot;张&quot;)</code>（% 张）</td>
</tr>
<tr>
<td><strong>AND&#x2F;OR 嵌套</strong></td>
<td><code>and(w -&gt; w.eq(User::getName, &quot;张三&quot;).or().eq(User::getName, &quot;李四&quot;))</code></td>
</tr>
<tr>
<td><strong>字段选择</strong></td>
<td><code>select(User::getId, User::getName, User::getAge)</code>（只查指定字段）</td>
</tr>
<tr>
<td><strong>动态条件</strong></td>
<td><code>eq(StringUtils.isNotBlank(name), User::getName, name)</code>（非空才加条件）</td>
</tr>
<tr>
<td><strong>子查询</strong></td>
<td><code>inSql(User::getId, &quot;select id from user where age &gt; 20&quot;)</code></td>
</tr>
</tbody></table>
<h5 id="一、基础查询条件"><a href="#一、基础查询条件" class="headerlink" title="一、基础查询条件"></a>一、基础查询条件</h5><h6 id="一、等值-不等值查询"><a href="#一、等值-不等值查询" class="headerlink" title="一、等值 &#x2F; 不等值查询"></a>一、等值 &#x2F; 不等值查询</h6><p>**通过 **<code>eq</code>（等于）、<code>ne</code>（不等于）方法构建字段与值的匹配条件，Lambda 方式直接引用实体类字段（如 <code>User::getName</code>），避免硬编码字段名导致的错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Lambda方式：查询姓名为“张三”且年龄不等于18的用户</span><br><span class="line">LambdaQueryWrapper&lt;User&gt; lambdaWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">lambdaWrapper.eq(User::getName, &quot;张三&quot;) // 等值条件：name = &quot;张三&quot;</span><br><span class="line">             .ne(User::getAge, 18);    // 不等值条件：age != 18</span><br></pre></td></tr></table></figure>

<h6 id="二、范围查询"><a href="#二、范围查询" class="headerlink" title="二、范围查询"></a>二、范围查询</h6><p>**通过 **<code>gt</code>（大于）、<code>ge</code>（大于等于）、<code>lt</code>（小于）、<code>le</code>（小于等于）、<code>between</code>（区间包含）方法构建数值型字段的范围条件，适用于年龄、时间等字段的范围筛选。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Lambda方式：查询年龄大于18、大于等于20、小于30、小于等于25，且在20-30区间内的用户</span><br><span class="line">LambdaQueryWrapper&lt;User&gt; lambdaWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">lambdaWrapper.gt(User::getAge, 18)     // 范围条件：age &gt; 18</span><br><span class="line">             .ge(User::getAge, 20)     // 范围条件：age &gt;= 20</span><br><span class="line">             .lt(User::getAge, 30)     // 范围条件：age &lt; 30</span><br><span class="line">             .le(User::getAge, 25)     // 范围条件：age &lt;= 25</span><br><span class="line">             .between(User::getAge, 20, 30); // 区间条件：age BETWEEN 20 AND 30</span><br></pre></td></tr></table></figure>

<h6 id="三、模糊查询"><a href="#三、模糊查询" class="headerlink" title="三、模糊查询"></a>三、模糊查询</h6><p>**通过 **<code>like</code>（全模糊，% 值 %）、<code>likeLeft</code>（左模糊，% 值）、<code>likeRight</code>（右模糊，值 %）、<code>notLike</code>（不包含，NOT LIKE % 值 %）方法构建字符串字段的模糊匹配条件，适用于姓名、邮箱等字段的模糊搜索。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Lambda方式：查询姓名包含“张”、以“张”结尾、以“张”开头，且不包含“李”的用户</span><br><span class="line">LambdaQueryWrapper&lt;User&gt; lambdaWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">lambdaWrapper.like(User::getName, &quot;张&quot;)     // 全模糊：name LIKE %张%</span><br><span class="line">             .likeLeft(User::getName, &quot;张&quot;) // 左模糊：name LIKE %张</span><br><span class="line">             .likeRight(User::getName, &quot;张&quot;)// 右模糊：name LIKE 张%</span><br><span class="line">             .notLike(User::getName, &quot;李&quot;); // 不包含：name NOT LIKE %李%</span><br></pre></td></tr></table></figure>

<h5 id="二、复杂条件组合"><a href="#二、复杂条件组合" class="headerlink" title="二、复杂条件组合"></a>二、复杂条件组合</h5><h6 id="一、AND-OR-条件组合（多条件并列与分支）"><a href="#一、AND-OR-条件组合（多条件并列与分支）" class="headerlink" title="一、AND&#x2F;OR 条件组合（多条件并列与分支）"></a>一、AND&#x2F;OR 条件组合（多条件并列与分支）</h6><p>**通过 **<code>and()</code> 和 <code>or()</code> 方法实现多条件的并列或分支组合，Lambda 表达式内可嵌套子条件，确保查询逻辑与业务需求一致。适用于 “满足 A 条件且（满足 B 或 C 条件）”“满足 A 条件或（满足 B 且 C 条件）” 等场景。</p>
<p><strong>示例代码（查询逻辑：姓名为 “张三” 或 “李四”，****且</strong> 年龄大于 20；<strong>或</strong> 年龄大于 20 且小于 30）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LambdaQueryWrapper&lt;User&gt; lambdaWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">// 1. and() 内嵌套 OR 分支：整体为“（姓名=张三 或 姓名=李四）”的条件，与后续条件用 AND 连接</span><br><span class="line">lambdaWrapper.and(w -&gt; w.eq(User::getName, &quot;张三&quot;).or().eq(User::getName, &quot;李四&quot;))</span><br><span class="line">             // 2. or() 内嵌套 AND 分支：整体为“（年龄&gt;20 且 年龄&lt;30）”的条件，与前面条件用 OR 连接</span><br><span class="line">             .or(w -&gt; w.gt(User::getAge, 20).lt(User::getAge, 30));</span><br></pre></td></tr></table></figure>

<p><strong>上述代码中，</strong><code>and()</code> 和 <code>or()</code> 方法的参数为 Lambda 表达式，用于定义分支内的子条件，避免因条件优先级混乱导致的查询错误，且字段引用（如 <code>User::getName</code>）无硬编码风险。</p>
<h6 id="二、嵌套条件（强制条件优先级）"><a href="#二、嵌套条件（强制条件优先级）" class="headerlink" title="二、嵌套条件（强制条件优先级）"></a>二、嵌套条件（强制条件优先级）</h6><p>**通过 **<code>nested()</code> 方法将一组子条件包裹为 “嵌套块”，强制该组子条件优先执行，适用于 “（满足 A 或 B 条件）且（满足 C 且 D 条件）” 等需要明确优先级的场景（类似 SQL 中的括号分组）。</p>
<p><strong>示例代码（查询逻辑：（姓名为 “张三” 或 “李四”）****且</strong>（年龄大于 20 且小于 30））：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LambdaQueryWrapper&lt;User&gt; lambdaWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">// 1. nested() 包裹第一个子条件块：（姓名=张三 或 姓名=李四），优先执行</span><br><span class="line">lambdaWrapper.nested(w -&gt; w.eq(User::getName, &quot;张三&quot;).or().eq(User::getName, &quot;李四&quot;))</span><br><span class="line">             // 2. and() 连接第二个子条件块：（年龄&gt;20 且 年龄&lt;30），与嵌套块用 AND 连接</span><br><span class="line">             .and(w -&gt; w.gt(User::getAge, 20).lt(User::getAge, 30));</span><br></pre></td></tr></table></figure>

<p>**与普通 **<code>and()</code>&#x2F;<code>or()</code> 组合不同，<code>nested()</code> 明确标识子条件块的优先级，即使后续条件复杂，也能保证嵌套块内的逻辑优先执行，避免 SQL 解析时的优先级错乱。</p>
<h5 id="三、排序与分页"><a href="#三、排序与分页" class="headerlink" title="三、排序与分页"></a>三、排序与分页</h5><h6 id="一、排序（控制结果集顺序）"><a href="#一、排序（控制结果集顺序）" class="headerlink" title="一、排序（控制结果集顺序）"></a>一、排序（控制结果集顺序）</h6><p>**通过 **<code>orderByAsc</code>（升序）和 <code>orderByDesc</code>（降序）方法指定排序字段，支持单字段或多字段排序，Lambda 方式直接引用实体类字段，避免字段名硬编码错误。</p>
<ol>
<li><strong>核心逻辑</strong></li>
</ol>
<ul>
<li><strong>升序：</strong><code>orderByAsc(实体类::字段名1, 实体类::字段名2)</code>（按字段 1 升序，字段 1 相同则按字段 2 升序）</li>
<li><strong>降序：</strong><code>orderByDesc(实体类::字段名)</code></li>
<li><strong>可组合使用升序与降序方法，满足复杂排序需求。</strong></li>
</ul>
<ol start="2">
<li><strong>示例代码</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Lambda方式：按年龄升序、ID升序，再按创建时间降序排序</span><br><span class="line">LambdaQueryWrapper&lt;User&gt; lambdaWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">lambdaWrapper.orderByAsc(User::getAge, User::getId)  // 多字段升序：先age，再id</span><br><span class="line">             .orderByDesc(User::getCreateTime);       // 单字段降序：create_time</span><br><span class="line">// 执行查询，结果按上述规则排序</span><br><span class="line">List&lt;User&gt; sortedUsers = userMapper.selectList(lambdaWrapper);</span><br></pre></td></tr></table></figure>

<p><strong>上述排序逻辑对应文档中 Lambda 方式的排序实现，通过链式调用明确排序规则，可读性与可维护性更强。</strong></p>
<h6 id="二、分页（大数据量分批获取）"><a href="#二、分页（大数据量分批获取）" class="headerlink" title="二、分页（大数据量分批获取）"></a>二、分页（大数据量分批获取）</h6><p>**分页需先配置分页插件，再通过 **<code>Page</code> 对象指定分页参数（当前页、每页大小），结合 LambdaQueryWrapper 实现条件分页查询，支持获取总记录数、当前页数据等关键信息。</p>
<p><strong>1. 前置步骤：配置分页插件</strong></p>
<p>**需在配置类中注册 **<code>PaginationInnerInterceptor</code> 插件（指定数据库类型），确保分页功能生效：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MybatisPlusConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public MybatisPlusInterceptor mybatisPlusInterceptor() &#123;</span><br><span class="line">        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();</span><br><span class="line">        // 注册分页插件，指定数据库类型（如MySQL）</span><br><span class="line">        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));</span><br><span class="line">        return interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>上述分页插件配置为文档中生产环境的标准配置，是分页查询的前提。</strong></p>
<p><strong>2. 分页查询示例（Lambda 方式）</strong></p>
<p>**通过 **<code>Page</code> 对象定义分页参数，结合 <code>selectPage</code> 方法执行分页查询，返回的 <code>Page</code> 对象包含总记录数、当前页数据等信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 1. 构建分页对象：参数1=当前页（从1开始），参数2=每页大小</span><br><span class="line">Page&lt;User&gt; page = new Page&lt;&gt;(1, 10);  // 第1页，每页10条数据</span><br><span class="line"></span><br><span class="line">// 2. 构建Lambda查询条件：查询年龄&gt;20的用户</span><br><span class="line">LambdaQueryWrapper&lt;User&gt; lambdaWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">lambdaWrapper.gt(User::getAge, 20);</span><br><span class="line"></span><br><span class="line">// 3. 执行分页查询：调用selectPage方法，传入分页对象与查询条件</span><br><span class="line">Page&lt;User&gt; resultPage = userMapper.selectPage(page, lambdaWrapper);</span><br><span class="line"></span><br><span class="line">// 4. 解析分页结果</span><br><span class="line">long total = resultPage.getTotal();  // 获取总记录数</span><br><span class="line">List&lt;User&gt; currentPageUsers = resultPage.getRecords();  // 获取当前页数据</span><br><span class="line">System.out.println(&quot;总记录数：&quot; + total);</span><br><span class="line">System.out.println(&quot;第1页数据：&quot; + currentPageUsers);</span><br></pre></td></tr></table></figure>

<p>**该分页逻辑与文档中 Lambda 方式的分页实现一致，通过分页插件与 **<code>Page</code> 对象配合，高效处理大数据量查询，避免一次性加载过多数据导致内存溢出。</p>
<h5 id="四、字段选择（筛选返回字段）"><a href="#四、字段选择（筛选返回字段）" class="headerlink" title="四、字段选择（筛选返回字段）"></a>四、字段选择（筛选返回字段）</h5><p>**通过 **<code>select</code> 方法指定需要查询的实体类字段，仅返回目标字段数据（而非全表字段），减少数据传输量与数据库查询开销，适用于只需要部分字段的场景。</p>
<ol>
<li><strong>核心逻辑</strong></li>
</ol>
<ul>
<li><strong>语法：</strong><code>select(实体类::目标字段1, 实体类::目标字段2, ...)</code></li>
<li>**作用：仅查询指定字段，例如只查 **<code>id</code>、<code>name</code>、<code>age</code>，不查 <code>email</code>、<code>createTime</code> 等无关字段。</li>
</ul>
<ol start="2">
<li><strong>示例代码</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Lambda方式：仅查询用户的id、name、age字段，排除其他字段</span><br><span class="line">LambdaQueryWrapper&lt;User&gt; lambdaWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">lambdaWrapper.select(User::getId, User::getName, User::getAge)  // 指定返回字段</span><br><span class="line">             .eq(User::getAge, 25);  // 附加查询条件：年龄=25</span><br><span class="line">// 执行查询，返回的User对象中仅id、name、age有值，其他字段为null</span><br><span class="line">List&lt;User&gt; partialUsers = userMapper.selectList(lambdaWrapper);</span><br></pre></td></tr></table></figure>

<p>**该实现与文档中 Lambda 方式的字段选择逻辑完全一致，通过 **<code>select</code> 方法精准控制返回字段，优化查询性能。</p>
<h4 id="3-3-更新构造器示例"><a href="#3-3-更新构造器示例" class="headerlink" title="3.3 更新构造器示例"></a>3.3 更新构造器示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// LambdaUpdateWrapper：更新名字=“张三”的用户</span><br><span class="line">LambdaUpdateWrapper&lt;User&gt; lambdaUpdate = new LambdaUpdateWrapper&lt;&gt;();</span><br><span class="line">lambdaUpdate.set(User::getAge,30)</span><br><span class="line">    .set(User::getEmail,&quot;new@example.com&quot;)</span><br><span class="line">    .eq(User::getName, &quot;张三&quot;);</span><br><span class="line">userMapper.update(null, lambdaUpdate);</span><br><span class="line">//UpdateWrapper</span><br><span class="line">UpdateWrapper&lt;User&gt; updateWrapper = new UpdateWrapper&lt;&gt;();</span><br><span class="line"> updateWrapper.set(&quot;age&quot;, 30)</span><br><span class="line">     .set(&quot;email&quot;, &quot;new@example.com&quot;)</span><br><span class="line">     .eq(&quot;name&quot;, &quot;张三&quot;);</span><br><span class="line"> userMapper.update(null, updateWrapper);</span><br></pre></td></tr></table></figure>

<h4 id="3-4-动态条件构建"><a href="#3-4-动态条件构建" class="headerlink" title="3.4 动态条件构建"></a>3.4 动态条件构建</h4><p><strong>根据参数有效性（非空 &#x2F; 非空白）决定是否添加查询条件</strong>，避免因参数无效导致的冗余 SQL 或错误查询，通过参数有效性判断实现条件的动态开关，避免编写大量 <code>if-else</code> 逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 定义可能为空的查询参数</span><br><span class="line">String name = &quot;张三&quot;;    // 示例：姓名参数（非空）</span><br><span class="line">Integer minAge = 20;    // 示例：最小年龄参数（非空）</span><br><span class="line">Integer maxAge = 30;    // 示例：最大年龄参数（非空）</span><br><span class="line"></span><br><span class="line">// 1. 创建LambdaQueryWrapper</span><br><span class="line">LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line"></span><br><span class="line">// 2. 动态添加条件：仅当参数有效时，条件才生效</span><br><span class="line">wrapper.eq(StringUtils.isNotBlank(name), User::getName, name)  // 姓名非空白时，添加“name=张三”</span><br><span class="line">       .gt(minAge != null, User::getAge, minAge)              // 最小年龄非空时，添加“age&gt;20”</span><br><span class="line">       .lt(maxAge != null, User::getAge, maxAge);             // 最大年龄非空时，添加“age&lt;30”</span><br><span class="line"></span><br><span class="line">// 执行查询：最终条件为“name=张三 AND age&gt;20 AND age&lt;30”</span><br><span class="line">List&lt;User&gt; users = userMapper.selectList(wrapper);</span><br></pre></td></tr></table></figure>

<h4 id="3-5-子查询（Lambda-方式）"><a href="#3-5-子查询（Lambda-方式）" class="headerlink" title="3.5 子查询（Lambda 方式）"></a>3.5 子查询（Lambda 方式）</h4><p>**子查询是将一个查询结果作为另一个查询的条件（如 **<code>IN</code> 子句），MyBatis-Plus 支持传统字符串拼接、Lambda 语法及更安全的 “子 Wrapper” 三种方式，其中 Lambda 方式避免字段硬编码，“子 Wrapper” 方式进一步减少 SQL 注入风险。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 传统⽅式</span><br><span class="line">queryWrapper.inSql(&quot;id&quot;, &quot;select id from user where age &gt; 20&quot;);</span><br><span class="line"> // Lambda⽅式</span><br><span class="line">lambdaWrapper.inSql(User::getId, &quot;select id from user where age &gt; 20&quot;);</span><br><span class="line"> // 更安全的⼦查询⽅式</span><br><span class="line">LambdaQueryWrapper&lt;User&gt; subWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line"> subWrapper</span><br><span class="line">     .select(User::getId)</span><br><span class="line">     .gt(User::getAge, 20);</span><br><span class="line"> lambdaWrapper</span><br><span class="line">     .in(User::getId, userMapper.selectObjs(subWrapper))</span><br></pre></td></tr></table></figure>

<h4 id="3-6-最佳实践"><a href="#3-6-最佳实践" class="headerlink" title="3.6 最佳实践"></a>3.6 最佳实践</h4><ul>
<li><strong>优先使⽤ Lambda ⽅式：类型安全，重构友好</strong></li>
<li>**合理使⽤动态条件：避免构建过于复杂的条件 **</li>
<li>**注意 SQL 注⼊⻛险：避免直接拼接⽤户输⼊ **</li>
<li><strong>批量操作优化：对于⼤批量数据，使⽤分批处理</strong></li>
</ul>
<h3 id="第-4-章：流式查询（处理大数据）"><a href="#第-4-章：流式查询（处理大数据）" class="headerlink" title="第 4 章：流式查询（处理大数据）"></a>第 4 章：流式查询（处理大数据）</h3><h4 id="4-1-两种实现方式"><a href="#4-1-两种实现方式" class="headerlink" title="4.1 两种实现方式"></a>4.1 两种实现方式</h4><ol>
<li><p><strong>ResultHandler 方式（推荐）：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Mapper接口定义</span><br><span class="line">@Select(&quot;SELECT * FROM user $&#123;ew.customSqlSegment&#125;&quot;)</span><br><span class="line">@Options(resultSetType = ResultSetType.FORWARD_ONLY)</span><br><span class="line">@ResultType(User.class)</span><br><span class="line">void selectStream(@Param(Constants.WRAPPER) Wrapper&lt;User&gt; wrapper, ResultHandler&lt;User&gt; handler);</span><br><span class="line"></span><br><span class="line">// 使用：逐行处理数据，避免OOM</span><br><span class="line">userMapper.selectStream(Wrappers.emptyWrapper(), context -&gt; &#123;</span><br><span class="line">  User user = context.getResultObject();</span><br><span class="line">  // 处理逻辑</span><br><span class="line">  System.out.println(&quot;已处理第&quot; + context.getResultCount() + &quot;条&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Cursor 方式（Java8+，需事务）：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Mapper定义</span><br><span class="line">@Select(&quot;SELECT * FROM user LIMIT #&#123;limit&#125;&quot;)</span><br><span class="line">Cursor&lt;User&gt; scan(@Param(&quot;limit&quot;) int limit);</span><br><span class="line"></span><br><span class="line">// 使用（try-with-resources自动关闭）</span><br><span class="line">@Transactional // 必须加事务，保持连接</span><br><span class="line">try (Cursor&lt;User&gt; cursor = userMapper.scan(100000)) &#123;</span><br><span class="line">  cursor.forEach(user -&gt; &#123; /* 处理逻辑 */ &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：必须⼿动关闭 Cursor 或使⽤ try-with-resources</strong></p>
</li>
</ol>
<h4 id="4-2-结合-MyBatis-Plus-特性的实现"><a href="#4-2-结合-MyBatis-Plus-特性的实现" class="headerlink" title="4.2 结合 MyBatis-Plus 特性的实现"></a>4.2 结合 MyBatis-Plus 特性的实现</h4><p><strong>结合 MyBatis-Plus 特性的流式查询主要包含****通用 BaseMapper 流式查询</strong>与<strong>带条件的分页流式处理</strong>两类，核心是借助 BaseMapper 原生方法 + ResultHandler 实现数据逐行 &#x2F; 分批处理，避免大数据量加载导致的内存溢出（OOM）。</p>
<h5 id="1、通用-BaseMapper-流式查询"><a href="#1、通用-BaseMapper-流式查询" class="headerlink" title="1、通用 BaseMapper 流式查询"></a>1、通用 BaseMapper 流式查询</h5><p><strong>无需自定义 Mapper 接口方法，直接使用 BaseMapper 自带的</strong><code>selectList</code> 方法，通过传入 <code>Wrappers.emptyWrapper()</code>（无额外查询条件时）和 <code>ResultHandler</code> 接口，实现对查询结果的逐行流式处理。该方式支持 BaseMapper 的所有查询方法（如带条件的 <code>selectList</code>），无需额外扩展，简化开发流程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 直接调用BaseMapper的selectList方法，实现流式查询</span><br><span class="line">userMapper.selectList(</span><br><span class="line">    Wrappers.emptyWrapper(), // 无额外查询条件（若需条件，可替换为LambdaQueryWrapper）</span><br><span class="line">    new ResultHandler&lt;User&gt;() &#123; // 结果处理器：逐行处理查询到的数据</span><br><span class="line">        @Override</span><br><span class="line">        public void handleResult(ResultContext&lt;? extends User&gt; context) &#123;</span><br><span class="line">            // 1. 获取当前流式处理的单条数据</span><br><span class="line">            User currentUser = context.getResultObject();</span><br><span class="line"></span><br><span class="line">            // 2. 自定义数据处理逻辑（如数据校验、格式转换、写入文件等）</span><br><span class="line">            // 示例：打印当前处理的数据ID</span><br><span class="line">            System.out.println(&quot;正在处理用户ID：&quot; + currentUser.getId());</span><br><span class="line"></span><br><span class="line">            // 注意：此处逻辑需轻量化，避免阻塞流式处理</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>Wrappers.emptyWrapper()</code>**：当无需筛选条件（查询全表数据）时使用，若需添加查询条件（如年龄 &gt; 20），可替换为 <code>Wrappers.lambdaQuery().gt(User::getAge, 20)</code>，兼容所有 Lambda 条件构造器用法；</li>
<li>**<code>ResultContext</code>**：用于获取流式处理的上下文信息，核心方法 <code>getResultObject()</code> 获取当前行数据，还可通过 <code>getResultCount()</code> 获取已处理的数据总数；</li>
<li><strong>支持范围</strong>：文档明确说明 “支持所有 BaseMapper 的查询方法”，即 BaseMapper 中带 <code>ResultHandler</code> 参数的查询方法（如 <code>selectByMap</code>、<code>selectOne</code> 等），均可用此方式实现流式处理。</li>
</ul>
<h5 id="2、带条件的分页流式处理"><a href="#2、带条件的分页流式处理" class="headerlink" title="2、带条件的分页流式处理"></a>2、带条件的分页流式处理</h5><p><strong>针对 “需筛选条件 + 大数据量分批处理” 场景，结合****分页（控制每批数据量）</strong> 与 <strong>Lambda 条件（筛选目标数据）</strong>，通过 BaseMapper 的 <code>selectList</code> 方法传入 <code>Page</code>（分页参数）、<code>LambdaQueryWrapper</code>（查询条件）和 <code>ResultHandler</code>（批量处理逻辑），实现 “按批次流式处理符合条件的数据”，精准控制内存占用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 1. 构建分页对象：控制每批处理的数据量（当前页=1，每页大小=10000，即每批处理1万条）</span><br><span class="line">Page&lt;User&gt; page = new Page&lt;&gt;(1, 10000); </span><br><span class="line"></span><br><span class="line">// 2. 构建Lambda查询条件：筛选“年龄&gt;20”的用户（可根据业务扩展条件）</span><br><span class="line">LambdaQueryWrapper&lt;User&gt; wrapper = Wrappers.lambdaQuery();</span><br><span class="line">wrapper.gt(User::getAge, 20); // 筛选条件：age &gt; 20</span><br><span class="line"></span><br><span class="line">// 3. 调用BaseMapper的selectList，实现分页流式处理</span><br><span class="line">userMapper.selectList(</span><br><span class="line">    page,          // 分页参数：控制每批数据量</span><br><span class="line">    wrapper,       // 条件构造器：筛选目标数据</span><br><span class="line">    context -&gt; &#123;   // 结果处理器：批量处理当前批次的数据</span><br><span class="line">        // 1. 获取当前批次中的单条数据</span><br><span class="line">        User user = context.getResultObject();</span><br><span class="line"></span><br><span class="line">        // 2. 批量处理逻辑（如批量写入数据库、批量导出Excel等）</span><br><span class="line">        // 示例：将当前用户数据添加到临时集合，累计到1000条时统一处理</span><br><span class="line">        tempUserList.add(user);</span><br><span class="line">        if (tempUserList.size() &gt;= 1000) &#123;</span><br><span class="line">            batchExport(tempUserList); // 自定义批量导出方法</span><br><span class="line">            tempUserList.clear(); // 清空集合，释放内存</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>分页参数作用</strong>：<code>Page&lt;&gt;(1, 10000)</code> 中 “10000” 为<strong>每批处理的最大条数</strong>，即使待处理数据总量为 100 万条，也会自动拆分为 100 批（每批 1 万条）逐步处理，避免一次性加载 100 万条数据到内存；</li>
<li><strong>条件与流式结合</strong>：Lambda 条件（<code>gt(User::getAge, 20)</code>）先筛选出符合条件的数据，再按分页批量流式处理，避免对无关数据进行无效处理，提升效率；</li>
<li><strong>批量处理优势</strong>：相比 “逐行处理”，“每批 1 万条 + 批量逻辑” 减少 IO 次数（如批量写入文件 &#x2F; 数据库），平衡内存占用与处理效率。</li>
</ul>
<h4 id="4-3-场景选择"><a href="#4-3-场景选择" class="headerlink" title="4.3 场景选择"></a>4.3 场景选择</h4><table>
<thead>
<tr>
<th><strong>场景</strong></th>
<th><strong>推荐方案</strong></th>
<th><strong>特点</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>简单流式处理</strong></td>
<td><strong>ResultHandler</strong></td>
<td><strong>配置简单，无需事务</strong></td>
</tr>
<tr>
<td><strong>Java8 流式操作</strong></td>
<td><strong>Cursor</strong></td>
<td><strong>支持 Stream API</strong></td>
</tr>
<tr>
<td><strong>大数据量批处理</strong></td>
<td><strong>分页 + 流式</strong></td>
<td><strong>内存控制更精确（每批 1 万条）</strong></td>
</tr>
<tr>
<td><strong>复杂事务场景</strong></td>
<td><strong>@Transactional</strong></td>
<td><strong>保证数据一致性</strong></td>
</tr>
</tbody></table>
<h4 id="4-4-注意事项"><a href="#4-4-注意事项" class="headerlink" title="4.4 注意事项"></a>4.4 注意事项</h4><ul>
<li><strong>流式查询期间保持数据库连接打开，避免中途断连；</strong></li>
<li><strong>合理设置</strong><code>fetchSize</code>（500-5000），避免频繁 IO；</li>
<li><strong>不建议在流式处理中执行其他数据库操作。</strong></li>
<li><strong>结果集类型必须为</strong><code>FORWARD_ONLY</code></li>
</ul>
<h3 id="第-5-章：枚举映射（自动转换）"><a href="#第-5-章：枚举映射（自动转换）" class="headerlink" title="第 5 章：枚举映射（自动转换）"></a>第 5 章：枚举映射（自动转换）</h3><h4 id="5-1-两种实现方式"><a href="#5-1-两种实现方式" class="headerlink" title="5.1 两种实现方式"></a>5.1 两种实现方式</h4><ol>
<li><strong>@EnumValue 注解（推荐）：</strong> **通过 **<code>@EnumValue</code> 直接标记枚举中 “需存入数据库的属性”，MyBatis-Plus 会自动将该属性值与数据库字段关联，支持 String、Integer 等多种类型。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public enum GenderEnum &#123;</span><br><span class="line">  MALE(&quot;M&quot;, &quot;男性&quot;), FEMALE(&quot;F&quot;, &quot;女性&quot;);</span><br><span class="line">  @EnumValue // 标记存入数据库的值</span><br><span class="line">  private final String code;</span><br><span class="line">  private final String desc;</span><br><span class="line">  // 构造器+getter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>实现 IEnum 接口：</strong> **通过实现 MyBatis-Plus 提供的 **<code>IEnum</code> 接口，并覆写 <code>getValue()</code> 方法，指定 “存入数据库的枚举值”。该方式需强绑定接口，灵活性略低于 <code>@EnumValue</code> 注解。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public enum StatusEnum implements IEnum&lt;Integer&gt; &#123;</span><br><span class="line">  LOCK(1, &quot;锁定&quot;), DISABLE(2, &quot;禁用&quot;);</span><br><span class="line">  private final int value;</span><br><span class="line">  private final String desc;</span><br><span class="line">  @Override public Integer getValue() &#123; return this.value; &#125; // 必须实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="5-2-配置差异"><a href="#5-2-配置差异" class="headerlink" title="5.2 配置差异"></a>5.2 配置差异</h4><ul>
<li><strong>3.5.2 + 版本</strong>：无需额外配置，直接在实体类用枚举字段即可；</li>
<li><strong>3.5.2 之前：需在 application.yml 配置枚举包路径：</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus:</span><br><span class="line">  type-enums-package: com.example.enums</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="5-3-实体类与数据库设计（对应关系）"><a href="#5-3-实体类与数据库设计（对应关系）" class="headerlink" title="5.3 实体类与数据库设计（对应关系）"></a>5.3 实体类与数据库设计（对应关系）</h4><h5 id="1-实体类中使用枚举"><a href="#1-实体类中使用枚举" class="headerlink" title="1. 实体类中使用枚举"></a>1. 实体类中使用枚举</h5><p>**在实体类（如 **<code>User</code>）中直接声明枚举类型属性，无需额外注解（除 <code>@Data</code> 等 Lombok 注解）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import lombok.Data;</span><br><span class="line">import com.baomidou.mybatisplus.annotation.TableName;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">@TableName(&quot;user&quot;) // 关联数据库表</span><br><span class="line">public class User &#123;</span><br><span class="line">    private Long id; // 主键</span><br><span class="line">    private String name; // 用户名</span><br><span class="line"></span><br><span class="line">    // 枚举属性1：使用IEnum接口的枚举（对应数据库status字段）</span><br><span class="line">    private StatusEnum status; </span><br><span class="line">    // 枚举属性2：使用@EnumValue注解的枚举（对应数据库gender字段）</span><br><span class="line">    private GenderEnum gender; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-数据库表设计"><a href="#2-数据库表设计" class="headerlink" title="2. 数据库表设计"></a>2. 数据库表设计</h5><p>**数据库表字段类型需与枚举的 “映射值类型” 一致（如 **<code>StatusEnum</code> 的 <code>value</code> 为 <code>int</code>，数据库字段设为 <code>INT</code>；<code>GenderEnum</code> 的 <code>code</code> 为 <code>String</code>，数据库字段设为 <code>CHAR(1)</code>）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE user (</span><br><span class="line">    id BIGINT PRIMARY KEY AUTO_INCREMENT, -- 主键自增</span><br><span class="line">    name VARCHAR(50) NOT NULL COMMENT &#x27;用户名&#x27;, -- 用户名</span><br><span class="line">    status INT DEFAULT 1 COMMENT &#x27;状态（1=锁定，2=禁用）&#x27;, -- 对应StatusEnum的value（int类型）</span><br><span class="line">    gender CHAR(1) COMMENT &#x27;性别（M=男性，F=女性）&#x27; -- 对应GenderEnum的code（char(1)类型）</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</span><br></pre></td></tr></table></figure>

<h4 id="5-4-常见问题"><a href="#5-4-常见问题" class="headerlink" title="5.4 常见问题"></a>5.4 常见问题</h4><ul>
<li><strong>枚举值为 null</strong>：检查数据库字段类型与枚举值类型匹配（如 tinyint 不能映射 boolean）；</li>
<li><strong>JSON 序列化</strong>：用 Jackson 时添加 <code>@JsonValue</code> 注解指定序列化值（如 <code>@JsonValue private final String code</code>）。</li>
</ul>
<h3 id="第-6-章：自动填充（审计字段）"><a href="#第-6-章：自动填充（审计字段）" class="headerlink" title="第 6 章：自动填充（审计字段）"></a>第 6 章：自动填充（审计字段）</h3><p><strong>MyBatis-Plus 提供了强⼤的⾃动填充功能，可以⾃动为创建时间、更新时间等公共字段赋值，极⼤简化了开发⼯作。以下是完 整的实现⽅案：</strong></p>
<h4 id="6-1-基础配置"><a href="#6-1-基础配置" class="headerlink" title="6.1 基础配置"></a>6.1 基础配置</h4><ol>
<li><strong>实体类标注填充规则：</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class User &#123;</span><br><span class="line">  @TableField(fill = FieldFill.INSERT) // 插入时填充（创建时间/创建人）</span><br><span class="line">  private LocalDateTime createTime;</span><br><span class="line">  @TableField(fill = FieldFill.INSERT_UPDATE) // 插入+更新时填充（更新时间/更新人）</span><br><span class="line">  private LocalDateTime updateTime;</span><br><span class="line">  @TableField(fill = FieldFill.INSERT)</span><br><span class="line">  private Long createUser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>实现 MetaObjectHandler：</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Component // 必须交给Spring管理</span><br><span class="line">public class MyMetaObjectHandler implements MetaObjectHandler &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void insertFill(MetaObject metaObject) &#123;</span><br><span class="line">    // 严格模式：字段类型必须匹配（推荐）</span><br><span class="line">    this.strictInsertFill(metaObject, &quot;createTime&quot;, LocalDateTime.class, LocalDateTime.now());</span><br><span class="line">    this.strictInsertFill(metaObject, &quot;createUser&quot;, Long.class, getCurrentUserId());</span><br><span class="line">    this.strictInsertFill(metaObject, &quot;updateTime&quot;, LocalDateTime.class, LocalDateTime.now());</span><br><span class="line">  &#125;</span><br><span class="line">  @Override</span><br><span class="line">  public void updateFill(MetaObject metaObject) &#123;</span><br><span class="line">    this.strictUpdateFill(metaObject, &quot;updateTime&quot;, LocalDateTime.class, LocalDateTime.now());</span><br><span class="line">    this.strictUpdateFill(metaObject, &quot;updateUser&quot;, Long.class, getCurrentUserId());</span><br><span class="line">  &#125;</span><br><span class="line">  // 用ThreadLocal获取当前用户ID（登录时设置）</span><br><span class="line">  private Long getCurrentUserId() &#123; return BaseContext.getCurrentId(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="6-2-高级功能"><a href="#6-2-高级功能" class="headerlink" title="6.2 高级功能"></a>6.2 高级功能</h4><ul>
<li><p><strong>ThreadLocal 存储用户</strong>：<code>BaseContext</code> 类用 <code>static ThreadLocal&lt;Long&gt;</code> 存当前用户 ID，登录拦截器中设置；</p>
<ul>
<li><pre><code>public class BaseContext &#123;
     private static ThreadLocal&lt;Long&gt; threadLocal = new ThreadLocal&lt;&gt;();
     public static void setCurrentId(Long id) &#123;
            threadLocal.set(id);
         &#125;
     public static Long getCurrentId() &#123;
         return threadLocal.get();
         &#125;
 &#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* **在登录过滤器或拦截器中设置⽤户 ID：**</span><br></pre></td></tr></table></figure>
//登录成功后设置
BaseContext.setCurrentId(loginUser.getId())
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* **填充模式：**</span><br><span class="line"></span><br><span class="line">  * **严格模式（**`strictInsertFill`）：字段类型不匹配则不填充，安全性高；</span><br><span class="line">  * **非严格模式（**`setFieldValByName`）：更灵活，但易出错。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
// 严格模式（推荐）
this.strictInsertFill(metaObject, &quot;createTime&quot;, LocalDateTime.class, LocalDateTime.now());
 // ⾮严格模式
metaObject.setValue(&quot;createTime&quot;, new Date());
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 6.3 常见问题</span><br><span class="line"></span><br><span class="line">* **填充不生效**：检查 `@Component` 是否添加、实体字段名与填充方法一致、strict 模式下类型匹配；</span><br><span class="line">* **时间类型**：推荐用 `LocalDateTime`（JDK8+），避免 `Date` 的线程安全问题。</span><br><span class="line"></span><br><span class="line">### 第 7 章：主键策略</span><br><span class="line"></span><br><span class="line">#### 7.1 策略类型（IdType 枚举）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">| **策略值**       | **描述**                                          |</span><br><span class="line">| ---------------- | ------------------------------------------------- |</span><br><span class="line">| **AUTO**         | **数据库自增（需表字段设 AUTO\_INCREMENT）**      |</span><br><span class="line">| **NONE**         | **跟随全局配置（默认全局为 ASSIGN\_ID）**         |</span><br><span class="line">| **INPUT**        | **手动设置主键（或实现 IKeyGenerator）**          |</span><br><span class="line">| **ASSIGN\_ID**   | **自动分配 ID（默认雪花算法，支持 Long/String）** |</span><br><span class="line">| **ASSIGN\_UUID** | **自动分配 UUID（String 类型，无中划线）**        |</span><br><span class="line"></span><br><span class="line">#### 7.2 配置优先级</span><br><span class="line"></span><br><span class="line">1. **局部注解（最高）**：`@TableId(type = IdType.AUTO) private Long id`；</span><br></pre></td></tr></table></figure>
 @Data
public class Permission &#123;
   @TableId(value = &quot;id&quot;, type = IdType.AUTO) // 数据库⾃增
   private Long id;
   @TableId(type = IdType.ASSIGN_ID) // 雪花算法（默认）
   private String orderId;
&#125;
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2. **全局配置（中）：**</span><br></pre></td></tr></table></figure>
 mybatis-plus:
 global-config:
   db-config:
     id-type: assign_id # 全局默认雪花算法
</code></pre>
</li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">3. **默认策略（最低）**：未配置时默认 `ASSIGN_ID`。</span><br><span class="line"></span><br><span class="line">#### 7.3 策略详解</span><br><span class="line"></span><br><span class="line">* **雪花算法（ASSIGN\_ID）**： 默认实现类：`DefaultIdentifierGenerator`</span><br><span class="line">  * **64 位 ID（1 符号位 + 41 时间戳 + 10 机器 ID+12 序列号），支持分布式，每秒生成 400 万 + ID；**</span><br><span class="line">* **数据库自增（AUTO）**：需表字段设 `AUTO_INCREMENT`，适合单机项目；</span><br><span class="line">  * **实体类配置：**</span><br></pre></td></tr></table></figure>
<p>   @TableId(type &#x3D; IdType.AUTO)<br>  private Long id;<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* **UUID（ASSIGN\_UUID）**：无需数据库依赖，适合字符串主键场景。</span><br><span class="line">  * ```</span><br><span class="line">    @TableId(type = IdType.ASSIGN_UUID)</span><br><span class="line">     private String uuid;</span><br></pre></td></tr></table></figure></p>
</li>
</ul>
<h4 id="7-4-自定义策略"><a href="#7-4-自定义策略" class="headerlink" title="7.4 自定义策略"></a>7.4 自定义策略</h4><p><strong>实现</strong><code>IdentifierGenerator</code> 接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class CustomIdGenerator implements IdentifierGenerator &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public Long nextId(Object entity) &#123;</span><br><span class="line">    return IdWorker.getId(); // 自定义ID生成逻辑</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-8-章：逻辑删除（软删除）"><a href="#第-8-章：逻辑删除（软删除）" class="headerlink" title="第 8 章：逻辑删除（软删除）"></a>第 8 章：逻辑删除（软删除）</h3><h4 id="8-1-基础实现"><a href="#8-1-基础实现" class="headerlink" title="8.1 基础实现"></a>8.1 基础实现</h4><ol>
<li><strong>数据库准备</strong>：添加逻辑删除字段 <code>ALTER TABLE user ADD COLUMN deleted TINYINT DEFAULT 0 COMMENT &#39;逻辑删除标识&#39;</code>；</li>
<li><strong>配置方式：</strong><ul>
<li><strong>方式 1：实体类注解</strong><code>@TableLogic private Integer deleted</code>；</li>
<li><strong>方式 2：全局配置（推荐，统一规则）：</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus:</span><br><span class="line">  global-config:</span><br><span class="line">    db-config:</span><br><span class="line">      logic-delete-field: deleted # 实体类字段名</span><br><span class="line">      logic-delete-value: 1 # 已删除值</span><br><span class="line">      logic-not-delete-value: 0 # 未删除值</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h4 id="8-2-核心特性"><a href="#8-2-核心特性" class="headerlink" title="8.2 核心特性"></a>8.2 核心特性</h4><ul>
<li><strong>自动 SQL 改写：</strong><ul>
<li><strong>删除：</strong><code>DELETE FROM user WHERE id=?</code> → <code>UPDATE user SET deleted=1 WHERE id=? AND deleted=0</code>；</li>
<li><strong>查询：自动添加</strong><code>WHERE deleted=0</code>（无需手动写条件）；</li>
</ul>
</li>
<li><strong>无感知使用</strong>：调用 <code>userMapper.deleteById(id)</code> 即可触发逻辑删除，与物理删除用法一致。</li>
</ul>
<h4 id="8-3-注意事项"><a href="#8-3-注意事项" class="headerlink" title="8.3 注意事项"></a>8.3 注意事项</h4><ul>
<li><strong>性能优化</strong>：为 <code>deleted</code> 字段加索引（<code>ALTER TABLE user ADD INDEX idx_deleted (deleted)</code>）；</li>
<li><strong>查询已删除数据</strong>：用 <code>wrapper.last(&quot;OR deleted = 1&quot;)</code> 关闭自动过滤；</li>
<li><strong>自定义 SQL</strong>：手写 SQL 需手动处理 <code>deleted</code> 条件。</li>
</ul>
<h4 id="8-4-高级用法"><a href="#8-4-高级用法" class="headerlink" title="8.4 高级用法"></a>8.4 高级用法</h4><ol>
<li>**查询包含已删除数据 **</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 1. 创建LambdaQueryWrapper，查询ID为1的用户（包含已删除数据）</span><br><span class="line">LambdaQueryWrapper&lt;User&gt; wrapper = Wrappers.lambdaQuery();</span><br><span class="line">wrapper.eq(User::getId, 1L) // 基础条件：ID = 1</span><br><span class="line">       .last(&quot;OR deleted = 1&quot;); // 关键：追加条件，包含已删除数据（假设已删除值为1）</span><br><span class="line"></span><br><span class="line">// 2. 执行查询：返回ID=1的所有数据（无论是否删除）</span><br><span class="line">List&lt;User&gt; userList = userMapper.selectList(wrapper);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>⾃定义删除值</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  // 自定义逻辑删除值：未删除=0，已删除=2（覆盖默认的0/1）</span><br><span class="line">//@TableLogic 注解的 value（未删除值）和 delval（已删除值）参数配置，优先级高于全局配置。</span><br><span class="line">   @TableLogic(value = &quot;0&quot;, delval = &quot;2&quot;) </span><br><span class="line">   private Integer deleted; // 逻辑删除字段</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>全局配置优先级</strong></li>
</ol>
<table>
<thead>
<tr>
<th><strong>配置层级</strong></th>
<th><strong>配置方式</strong></th>
<th><strong>优先级</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>注解配置</strong></td>
<td><strong>在实体类字段上用</strong><code>@TableLogic(value = &quot;...&quot;, delval = &quot;...&quot;)</code> 配置</td>
<td><strong>最高</strong></td>
</tr>
<tr>
<td><strong>全局配置</strong></td>
<td><strong>在</strong><code>application.yml</code> 中通过 <code>mybatis-plus.global-config.db-config</code> 配置</td>
<td><strong>中间</strong></td>
</tr>
<tr>
<td><strong>默认配置</strong></td>
<td><strong>未任何配置时，默认 “未删除 &#x3D; 0，已删除 &#x3D; 1”，逻辑删除字段名为</strong><code>deleted</code></td>
<td><strong>最低</strong></td>
</tr>
</tbody></table>
<h3 id="第-9-章：多数据源（动态切换）"><a href="#第-9-章：多数据源（动态切换）" class="headerlink" title="第 9 章：多数据源（动态切换）"></a>第 9 章：多数据源（动态切换）</h3><h4 id="9-1-基础配置"><a href="#9-1-基础配置" class="headerlink" title="9.1 基础配置"></a>9.1 基础配置</h4><ol>
<li><strong>引入依赖：</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;dynamic-datasource-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;3.6.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><strong>YAML 配置（主从分离示例）：</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    dynamic:</span><br><span class="line">      primary: master # 默认数据源</span><br><span class="line">      strict: false # 不严格匹配数据源（不存在时用默认）</span><br><span class="line">      datasource:</span><br><span class="line">        master:</span><br><span class="line">          url: jdbc:mysql://你的数据库url?useSSL=false&amp;serverTimezone=UTC</span><br><span class="line">          username: root</span><br><span class="line">          password: root</span><br><span class="line">        slave1:</span><br><span class="line">          url: jdbc:mysql://你的数据库url?useSSL=false&amp;serverTimezone=UTC</span><br><span class="line">          username: root</span><br><span class="line">          password: 123456</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="9-2-核心使用方式"><a href="#9-2-核心使用方式" class="headerlink" title="9.2 核心使用方式"></a>9.2 核心使用方式</h4><ol>
<li><strong>注解切换（@DS）：</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">@DS(&quot;slave1&quot;) // 类级别默认数据源</span><br><span class="line">public class UserServiceImpl &#123;</span><br><span class="line">  @DS(&quot;master&quot;) // 方法级别覆盖（优先级更高）</span><br><span class="line">  public void saveUser(User user) &#123; userMapper.insert(user); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>编程式切换（动态场景）：</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  DynamicDataSourceContextHolder.push(&quot;slave2&quot;); // 切换到slave2</span><br><span class="line">  // 执行数据库操作</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  DynamicDataSourceContextHolder.clear(); // 必须清理，避免连接泄漏</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="9-3-最佳实践"><a href="#9-3-最佳实践" class="headerlink" title="9.3 最佳实践"></a>9.3 最佳实践</h4><ul>
<li><strong>连接池</strong>：推荐配合 Druid 或 HikariCP 使用；</li>
<li><strong>事务</strong>：跨数据源操作需用 <code>@DSTransactional</code>（而非 <code>@Transactional</code>）；</li>
<li><strong>监控</strong>：集成 Actuator 监控各数据源连接状态。</li>
</ul>
<h3 id="第-10-章：类型处理器（字段转换）"><a href="#第-10-章：类型处理器（字段转换）" class="headerlink" title="第 10 章：类型处理器（字段转换）"></a>第 10 章：类型处理器（字段转换）</h3><h4 id="10-1-内置-JSON-处理器（常用）"><a href="#10-1-内置-JSON-处理器（常用）" class="headerlink" title="10.1 内置 JSON 处理器（常用）"></a>10.1 内置 JSON 处理器（常用）</h4><ol>
<li><p><strong>配置步骤：</strong></p>
<ul>
<li><strong>实体类：</strong><code>@TableName(autoResultMap = true)</code>（必须开启）+<code>@TableField(typeHandler = JacksonTypeHandler.class)</code>；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">@TableName(autoResultMap = true)</span><br><span class="line">public class User &#123;</span><br><span class="line">  @TableField(typeHandler = JacksonTypeHandler.class)</span><br><span class="line">  private Map&lt;String, String&gt; contact; // 自动转为JSON存储到数据库</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>引入依赖：</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.13.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>测试</strong>：插入时 <code>contact</code>（Map）自动转 JSON，查询时自动转 Map。</p>
</li>
</ol>
<h4 id="10-2-注意事项"><a href="#10-2-注意事项" class="headerlink" title="10.2 注意事项"></a>10.2 注意事项</h4><ul>
<li><code>@TableName(autoResultMap = true)</code> 必须加，否则查询时无法反序列化；</li>
<li><strong>字段为 null 时，检查类型处理器是否注册、数据库字段是否允许 NULL。</strong></li>
</ul>
<h3 id="第-11-章：扩展插件（生产必备）"><a href="#第-11-章：扩展插件（生产必备）" class="headerlink" title="第 11 章：扩展插件（生产必备）"></a>第 11 章：扩展插件（生产必备）</h3><h4 id="11-1-分页插件（PaginationInnerInterceptor）"><a href="#11-1-分页插件（PaginationInnerInterceptor）" class="headerlink" title="11.1 分页插件（PaginationInnerInterceptor）"></a>11.1 分页插件（PaginationInnerInterceptor）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MybatisPlusConfig &#123;</span><br><span class="line">  @Bean</span><br><span class="line">  public MybatisPlusInterceptor mybatisPlusInterceptor() &#123;</span><br><span class="line">    MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();</span><br><span class="line">    // 设置数据库类型（MySQL/Oracle等）</span><br><span class="line">    interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));</span><br><span class="line">    return interceptor;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用：查询第1页，每页10条，条件“status=1”</span><br><span class="line">Page&lt;User&gt; page = new Page&lt;&gt;(1, 10);</span><br><span class="line">userMapper.selectPage(page, Wrappers.&lt;User&gt;query().eq(&quot;status&quot;, 1));</span><br><span class="line">System.out.println(&quot;总记录数：&quot; + page.getTotal());</span><br></pre></td></tr></table></figure>

<h4 id="11-2-乐观锁插件（OptimisticLockerInnerInterceptor）"><a href="#11-2-乐观锁插件（OptimisticLockerInnerInterceptor）" class="headerlink" title="11.2 乐观锁插件（OptimisticLockerInnerInterceptor）"></a>11.2 乐观锁插件（OptimisticLockerInnerInterceptor）</h4><ul>
<li><strong>作用</strong>：解决高并发数据冲突（基于版本号）；</li>
<li><strong>配置：</strong><ol>
<li><strong>实体类加版本字段：</strong><code>@Version private Integer version</code>；</li>
<li><strong>注册插件（同上</strong><code>MybatisPlusConfig</code>）；</li>
</ol>
</li>
<li><strong>测试：</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">User user1 = userMapper.selectById(1L); // version=1</span><br><span class="line">User user2 = userMapper.selectById(1L); // version=1</span><br><span class="line">user1.setName(&quot;A&quot;);</span><br><span class="line">userMapper.updateById(user1); // 成功，version=2</span><br><span class="line">user2.setName(&quot;B&quot;);</span><br><span class="line">userMapper.updateById(user2); // 失败，version不匹配</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="11-3-防全表操作插件（BlockAttackInnerInterceptor）"><a href="#11-3-防全表操作插件（BlockAttackInnerInterceptor）" class="headerlink" title="11.3 防全表操作插件（BlockAttackInnerInterceptor）"></a>11.3 防全表操作插件（BlockAttackInnerInterceptor）</h4><ul>
<li><strong>作用</strong>：阻止 <code>delete null</code>&#x2F;<code>update null</code>（避免误删全表）；</li>
<li><strong>配置</strong>：注册插件后，执行 <code>userMapper.delete(null)</code> 会抛出 <code>MybatisPlusException</code>。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line"> public MybatisPlusInterceptor mybatisPlusInterceptor() &#123;</span><br><span class="line"> MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();</span><br><span class="line">    interceptor.addInnerInterceptor(new BlockAttackInnerInterceptor());</span><br><span class="line"> return interceptor;</span><br><span class="line"> &#125;</span><br><span class="line"> // 测试⾮法操作（会抛出异常）</span><br><span class="line">userMapper.delete(null); // 抛出MybatisPlusException</span><br><span class="line"> userMapper.update(new User(), null); // 抛出异常</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="11-4-动态表名插件（DynamicTableNameInnerInterceptor）"><a href="#11-4-动态表名插件（DynamicTableNameInnerInterceptor）" class="headerlink" title="11.4 动态表名插件（DynamicTableNameInnerInterceptor）"></a>11.4 动态表名插件（DynamicTableNameInnerInterceptor）</h4><ul>
<li><strong>作用</strong>：按规则动态切换表名（如分年表 <code>order_2024</code>&#x2F;<code>order_2025</code>）；</li>
<li><strong>配置：</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interceptor.addInnerInterceptor(new DynamicTableNameInnerInterceptor() &#123;&#123;</span><br><span class="line">  setTableNameHandler((sql, tableName) -&gt; &#123;</span><br><span class="line">    if (&quot;order&quot;.equals(tableName)) &#123;</span><br><span class="line">      return &quot;order_&quot; + LocalDate.now().getYear(); // 动态拼接年份</span><br><span class="line">    &#125;</span><br><span class="line">    return tableName;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="11-5-多租户插件（TenantLineInnerInterceptor）"><a href="#11-5-多租户插件（TenantLineInnerInterceptor）" class="headerlink" title="11.5 多租户插件（TenantLineInnerInterceptor）"></a>11.5 多租户插件（TenantLineInnerInterceptor）</h4><ul>
<li><strong>作用</strong>：数据隔离（自动给 SQL 加 <code>tenant_id = ?</code> 条件）；</li>
<li><strong>配置：</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interceptor.addInnerInterceptor(new TenantLineInnerInterceptor(new TenantLineHandler() &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public Expression getTenantId() &#123;</span><br><span class="line">    return new LongValue(1L); // 从上下文获取当前租户ID（如ThreadLocal）</span><br><span class="line">  &#125;</span><br><span class="line">  @Override</span><br><span class="line">  public String getTenantIdColumn() &#123;</span><br><span class="line">    return &quot;tenant_id&quot;; // 租户字段名</span><br><span class="line">  &#125;</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"> // 实体类需包含tenant_id字段</span><br><span class="line">@Data</span><br><span class="line"> public class User &#123;</span><br><span class="line">     private Long tenantId;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>实体类需包含</strong><code>tenant_id</code> 字段。</li>
</ul>
<h4 id="11-6-插件执行顺序（推荐）"><a href="#11-6-插件执行顺序（推荐）" class="headerlink" title="11.6 插件执行顺序（推荐）"></a>11.6 插件执行顺序（推荐）</h4><ol>
<li><strong>多租户插件（TenantLineInnerInterceptor）</strong></li>
<li><strong>动态表名插件（DynamicTableNameInnerInterceptor）</strong></li>
<li><strong>分页插件（PaginationInnerInterceptor）</strong></li>
<li><strong>乐观锁插件（OptimisticLockerInnerInterceptor）</strong></li>
<li><strong>防全表插件（BlockAttackInnerInterceptor）</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interceptor.addInnerInterceptor(new TenantLineInnerInterceptor()); // 多租户第⼀</span><br><span class="line">interceptor.addInnerInterceptor(new DynamicTableNameInnerInterceptor()); // 动态表名第⼆</span><br><span class="line">interceptor.addInnerInterceptor(new PaginationInnerInterceptor()); // 分⻚第三</span><br><span class="line">interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor()); // 乐观锁第四</span><br><span class="line">interceptor.addInnerInterceptor(new BlockAttackInnerInterceptor()); // 防全表最后</span><br></pre></td></tr></table></figure>

<h3 id="第-12-章：代码生成（效率提升-200-）"><a href="#第-12-章：代码生成（效率提升-200-）" class="headerlink" title="第 12 章：代码生成（效率提升 200%）"></a>第 12 章：代码生成（效率提升 200%）</h3><h4 id="12-1-基础配置（FastAutoGenerator）"><a href="#12-1-基础配置（FastAutoGenerator）" class="headerlink" title="12.1 基础配置（FastAutoGenerator）"></a>12.1 基础配置（FastAutoGenerator）</h4><ol>
<li><strong>引入依赖：</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;3.5.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><strong>生成器类：</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class AutoCodeGenerator &#123;</span><br><span class="line">  public static void main(String[] args) throws IOException &#123;</span><br><span class="line">    String url = &quot;jdbc:mysql://10.211.55.7:3306/mybatis_plus_demo?useSSL=false&amp;serverTimezone=UTC&quot;;</span><br><span class="line">    String username = &quot;root&quot;;</span><br><span class="line">    String password = &quot;root&quot;;</span><br><span class="line">    String tableName = &quot;test_code_generator&quot;; // 多表用逗号分隔</span><br><span class="line">    String projectPath = System.getProperty(&quot;user.dir&quot;);</span><br><span class="line"></span><br><span class="line">    FastAutoGenerator.create(new DataSourceConfig.Builder(url, username, password))</span><br><span class="line">      // 全局配置：作者、输出路径</span><br><span class="line">      .globalConfig(builder -&gt; builder.author(&quot;乐哥聊编程&quot;).outputDir(projectPath + &quot;/src/main/java&quot;))</span><br><span class="line">      // 包配置：父包名、模块名、各层包名</span><br><span class="line">      .packageConfig(builder -&gt; builder</span><br><span class="line">        .parent(&quot;com.lglbc&quot;)</span><br><span class="line">        .moduleName(&quot;demo&quot;)</span><br><span class="line">        .entity(&quot;entity&quot;)</span><br><span class="line">        .mapper(&quot;mapper&quot;)</span><br><span class="line">        .service(&quot;service&quot;)</span><br><span class="line">        .controller(&quot;controller&quot;)</span><br><span class="line">      )</span><br><span class="line">      // 策略配置：表名、主键策略、命名规则</span><br><span class="line">      .strategyConfig(builder -&gt; builder</span><br><span class="line">        .addInclude(tableName.split(&quot;,&quot;))</span><br><span class="line">        .entityBuilder()</span><br><span class="line">        .idType(IdType.AUTO)</span><br><span class="line">        .naming(NamingStrategy.underline_to_camel) // 下划线转驼峰</span><br><span class="line">        .columnNaming(NamingStrategy.underline_to_camel)</span><br><span class="line">        .RestControllerStyle() // Controller加@RestController</span><br><span class="line">      )</span><br><span class="line">      .templateEngine(new FreemarkerTemplateEngine()) // 模板引擎</span><br><span class="line">      .execute();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="12-2-生成文件"><a href="#12-2-生成文件" class="headerlink" title="12.2 生成文件"></a>12.2 生成文件</h4><ul>
<li><strong>自动生成：实体类（含</strong><code>@Data</code>&#x2F;<code>@TableName</code>）、Mapper 接口、Service（含 IService&#x2F;ServiceImpl）、Controller（含 CRUD 接口）。</li>
</ul>
<h4 id="12-3-IDEA-插件（可选）"><a href="#12-3-IDEA-插件（可选）" class="headerlink" title="12.3 IDEA 插件（可选）"></a>12.3 IDEA 插件（可选）</h4><ul>
<li><strong>安装「MyBatisPlus」插件，配置数据库后，选中表即可一键生成代码，支持自定义模板。</strong></li>
</ul>
<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><ol>
<li><strong>极简开发：</strong><ul>
<li><strong>告别 XML 配置，用 Lambda 写查询，代码量减少 50%；</strong></li>
<li><strong>示例：传统 MyBatis 需写 XML，MP 直接</strong><code>userMapper.selectList(Wrappers.&lt;User&gt;lambdaQuery().eq(User::getName, &quot;张三&quot;))</code>。</li>
</ul>
</li>
<li><strong>企业级插件实战：</strong><ul>
<li><strong>分页：5 行代码实现百万级数据分页；</strong></li>
<li><strong>乐观锁：解决高并发冲突；</strong></li>
<li><strong>多租户：一套代码支持多客户数据隔离。</strong></li>
</ul>
</li>
<li><strong>性能优化：</strong><ul>
<li><strong>动态表名应对分库分表；</strong></li>
<li><strong>字段加密保护敏感数据；</strong></li>
<li><strong>内置 SQL 注入防御。</strong></li>
</ul>
</li>
</ol>
</div>

    
    <section class="post-copyright">
      
      <p class="copyright-item">
        <span>作者:</span>
        <span>老江湖</span>
      </p>
        
      <p class="copyright-item">
        <span>许可证:</span>
        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
      </p>
       
      <p class="copyright-item">
        <span>口号:</span>
        <span><strong>代码是开源的,我们只是它的搬运工。</strong></span>
      </p>
       
        <p class="copyright-item">
        <span>如果觉得我的文章对你有所帮助，请随意转载，感谢支持！</span>
      </p>
      
             
        <p class="copyright-item">
        <span>如有侵权请告知删除🙏</span>
      </p>
             
        <p class="copyright-item">
        <span>如果你有很好的想法💡，请务必联系我。 </span>
        <br>
         <span>2292360909@qq.com</span>
      </p>
    </section>
    
    <section class="post-tags">
      <div>
        <span>标签:</span>
        <span class="tag">
           
          <a href="/tags/Mybatis-plus/"># Mybatis-plus</a>
           
        </span>
      </div>
      <div>
        <a href="javascript:window.history.back();">返回</a>
        <span>· </span>
        <a href="/">首页</a>
      </div>
    </section>
    <section class="post-nav">
       
      <a class="next" rel="next" href="/2025/10/15/java/Mybatis%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"
        >Mybatis快速上手</a
      >
      
    </section>

    <!-- Giscus 评论区挂载点 -->
<div id="giscus-container" style="margin-top: 2.5rem;"></div>

<!-- Giscus 动态加载脚本：初始加载 + 明暗主题切换 -->
<script>
  function createGiscus(theme) {
    const giscusContainer = document.getElementById('giscus-container');
    if (!giscusContainer) return;

    // 清除旧的评论 iframe
    giscusContainer.innerHTML = '';

    const script = document.createElement('script');
    script.src = 'https://giscus.app/client.js';

    // 替换为你的 GitHub 仓库信息（格式：username/repo）
    script.setAttribute('data-repo', 'meisijiya/meisijiya.github.io');

   // 替换为你的 repo-id 和 category-id（在 giscus.app 配置页面生成）
    script.setAttribute('data-repo-id', 'R_kgDOPwTrpQ');
    script.setAttribute('data-category', 'Announcements');
    script.setAttribute('data-category-id', 'DIC_kwDOPwTrpc4CviGR');

    // 其他常规推荐设置
    script.setAttribute('data-mapping', 'pathname');           // 用页面路径匹配评论帖
    script.setAttribute('data-strict', '0');                   // 若无匹配帖则创建新帖
    script.setAttribute('data-reactions-enabled', '1');        // 启用表情反应
    script.setAttribute('data-emit-metadata', '0');            // 不输出元数据
    script.setAttribute('data-input-position', 'top');         // 输入框在评论上方
    script.setAttribute('data-theme', theme);                
    script.setAttribute('data-lang', 'zh-CN');                 // 中文界面
    script.setAttribute('crossorigin', 'anonymous');           // 跨域资源安全
    script.async = true;                                       
     
    giscusContainer.appendChild(script);
  }

  function getCurrentTheme() {
    return document.body.classList.contains('dark-theme') ? 'dark' : 'light';
  }

  document.addEventListener('DOMContentLoaded', () => {
    // 页面首次加载，根据当前主题挂载评论
    createGiscus(getCurrentTheme());

    // 监听按钮点击切换主题 → 重载评论区
    const buttons = [
      document.querySelector('.toggleBtn'),
      document.getElementById('mobile-toggle-theme')
    ];
    buttons.forEach(btn => {
      if (!btn) return;
      btn.addEventListener('click', () => {
        setTimeout(() => {
          createGiscus(getCurrentTheme());
        }, 400); // 稍作延迟，确保 class 切换完毕
      });
    });

    // 监听 body class 改变（保险方案）
    const observer = new MutationObserver(() => {
      createGiscus(getCurrentTheme());
    });
    observer.observe(document.body, { attributes: true, attributeFilter: ['class'] });
  });
</script>

  </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 老江湖 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>
<script src="/js/code-copy.js"></script>


    </div>
</body>
<!-- umami -->
<script defer src="https://cloud.umami.is/script.js" data-website-id="91b923f2-ff2d-43d0-ba5f-bc348d82426a"></script>
</html>